--- tetex-src-3.0/texk/web2c/pdftexdir/pdftosrc.cc.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/pdftosrc.cc	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2006 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: //depot/Build/source.development/TeX/texk/web2c/pdftexdir/pdftosrc.cc#10 $
+$Id: pdftosrc.cc 217 2007-07-31 16:55:39Z oneiros $
 */
 
 #include <stdlib.h>
@@ -159,10 +159,10 @@
             }
         }
     } else {
-    s = srcStream.getStream();
-    s->reset();
-    while ((c = s->getChar()) != EOF)
-        fputc(c, outfile);
+        s = srcStream.getStream();
+        s->reset();
+        while ((c = s->getChar()) != EOF)
+            fputc(c, outfile);
         srcStream.free();
     }
     if (objnum == 0)
--- tetex-src-3.0/texk/web2c/pdftexdir/image.h.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/image.h	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2002 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: //depot/Build/source.development/TeX/texk/web2c/pdftexdir/image.h#10 $
+$Id: image.h 217 2007-07-31 16:55:39Z oneiros $
 */
 
 #include <png.h>
@@ -29,10 +29,10 @@
 #define JPG_UINT8       unsigned char
 
 typedef struct {
-    int color_space;    /* used color space. See JPG_ constants */
-    JPG_UINT8  bits_per_component; /* bits per component                         */
-    JPG_UINT32 length;             /* length of file/data                        */
-    FILE *file;                    /* jpg file                                   */
+    int color_space;            /* used color space. See JPG_ constants */
+    JPG_UINT8 bits_per_component;       /* bits per component                         */
+    JPG_UINT32 length;          /* length of file/data                        */
+    FILE *file;                 /* jpg file                                   */
 } JPG_IMAGE_INFO;
 
 typedef struct {
--- tetex-src-3.0/texk/web2c/pdftexdir/ttf2afm.c.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/ttf2afm.c	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2006 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: //depot/Build/source.development/TeX/texk/web2c/pdftexdir/ttf2afm.c#21 $
+$Id: ttf2afm.c 217 2007-07-31 16:55:39Z oneiros $
 */
 
 /*
@@ -104,11 +104,11 @@
 char *bname = NULL;
 FILE *fontfile, *encfile, *outfile = NULL;
 char enc_line[ENC_BUF_SIZE];
-int print_glyph = AS_NAME;    /* print glyph as names by default*/
+int print_glyph = AS_NAME;      /* print glyph as names by default */
 int print_cmap = 0;
-int use_ext_enc = 0;    /* use external encoding? */
-int select_unicode = 1; /* use the first unicode mapping by default */
-int printing_enc = 0; /* set to 1 while printing encodings */
+int use_ext_enc = 0;            /* use external encoding? */
+int select_unicode = 1;         /* use the first unicode mapping by default */
+int printing_enc = 0;           /* set to 1 while printing encodings */
 
 
 TTF_USHORT upem;
@@ -133,7 +133,7 @@
 
 #include "macnames.c"
 
-void ttf_fail(char *fmt,...)
+void ttf_fail(char *fmt, ...)
 {
     va_list args;
     va_start(args, fmt);
@@ -147,7 +147,7 @@
     exit(-1);
 }
 
-void ttf_warn(char *fmt,...)
+void ttf_warn(char *fmt, ...)
 {
     va_list args;
     va_start(args, fmt);
@@ -160,7 +160,7 @@
     va_end(args);
 }
 
-int xgetc(FILE *stream)
+int xgetc(FILE * stream)
 {
     int c = getc(stream);
     if (c < 0 && c != EOF)
@@ -263,7 +263,7 @@
 {
     char *p;
     int c;
-restart:
+  restart:
     if (enc_eof())
         ttf_fail("unexpected end of file");
     p = enc_line;
@@ -287,7 +287,7 @@
     if (*enc_line != '/' || (r = strchr(enc_line, '[')) == 0)
         ttf_fail("invalid encoding vector: name or `[' missing:\n%s", enc_line);
     for (i = 0; i < 256; i++)
-        enc_names[i] = (char*) notdef;
+        enc_names[i] = (char *) notdef;
     if (r[1] == 32)
         r += 2;
     else
@@ -315,10 +315,10 @@
         enc_getline();
         r = enc_line;
     }
-done:
+  done:
     xfclose(encfile, cur_file_name);
     if (names_count != 256)
-        ttf_warn("encoding vector contains only %i names (expected %i)", 
+        ttf_warn("encoding vector contains only %i names (expected %i)",
                  names_count, 256);
 }
 
@@ -346,9 +346,9 @@
     TTF_USHORT *glyphId, format, segCount;
     long int n, i, k, length, index;
     int unicode_map_count = 0;
-    ttf_seek_tab("cmap", TTF_USHORT_SIZE); /* skip the table vesrion number (=0) */
+    ttf_seek_tab("cmap", TTF_USHORT_SIZE);      /* skip the table vesrion number (=0) */
     ncmapsubtabs = get_ushort();
-    cmap_offset = xftell(fontfile, cur_file_name) - 2*TTF_USHORT_SIZE;
+    cmap_offset = xftell(fontfile, cur_file_name) - 2 * TTF_USHORT_SIZE;
     cmap_tab = xtalloc(ncmapsubtabs, cmap_entry);
     for (e = cmap_tab; e - cmap_tab < ncmapsubtabs; e++) {
         e->platform_id = get_ushort();
@@ -366,10 +366,10 @@
                 goto read_unicode_mapping;
         }
         continue;
-read_unicode_mapping:
-        length = get_ushort(); /* length of subtable */
+      read_unicode_mapping:
+        length = get_ushort();  /* length of subtable */
         (void) get_ushort();    /* skip the version number */
-        segCount = get_ushort()/2;
+        segCount = get_ushort() / 2;
         (void) get_ushort();    /* skip searchRange */
         (void) get_ushort();    /* skip entrySelector */
         (void) get_ushort();    /* skip rangeShift */
@@ -383,8 +383,8 @@
             s->idDelta = get_ushort();
         for (s = seg_tab; s - seg_tab < segCount; s++)
             s->idRangeOffset = get_ushort();
-        length -= 8*TTF_USHORT_SIZE + 4*segCount*TTF_USHORT_SIZE;
-        n = length/TTF_USHORT_SIZE; /* number of glyphID's */
+        length -= 8 * TTF_USHORT_SIZE + 4 * segCount * TTF_USHORT_SIZE;
+        n = length / TTF_USHORT_SIZE;   /* number of glyphID's */
         glyphId = xtalloc(n, TTF_USHORT);
         for (i = 0; i < n; i++)
             glyphId[i] = get_ushort();
@@ -396,8 +396,8 @@
                     if (s->idRangeOffset == 0)
                         index = (s->idDelta + i) & 0xFFFF;
                     else {
-                        k = (i - s->startCode) + s->idRangeOffset/2 + 
-                            (s - seg_tab) - segCount ;
+                        k = (i - s->startCode) + s->idRangeOffset / 2 +
+                            (s - seg_tab) - segCount;
                         assert(k >= 0 && k < n);
                         index = glyphId[k];
                         if (index != 0)
@@ -436,7 +436,7 @@
     mtx_entry *pm;
     ttf_skip(TTF_FIXED_SIZE);
     ntabs = get_ushort();
-    ttf_skip(3*TTF_USHORT_SIZE);
+    ttf_skip(3 * TTF_USHORT_SIZE);
     dir_tab = xtalloc(ntabs, dirtab_entry);
     for (pd = dir_tab; pd - dir_tab < ntabs; pd++) {
         pd->tag[0] = get_char();
@@ -462,7 +462,7 @@
     nglyphs = get_ushort();
     mtx_tab = xtalloc(nglyphs + 1, mtx_entry);
     for (pm = mtx_tab; pm - mtx_tab < nglyphs + 1; pm++) {
-        pm->name = NULL; /* notdef */
+        pm->name = NULL;        /* notdef */
         pm->found = 0;
         pm->unicode_list = NULL;
     }
@@ -486,14 +486,14 @@
     UnderlinePosition = get_fword();
     UnderlineThickness = get_fword();
     IsFixedPitch = get_ulong();
-    ttf_skip(4*TTF_ULONG_SIZE);
+    ttf_skip(4 * TTF_ULONG_SIZE);
     switch (post_format) {
     case 0x00010000:
         for (pm = mtx_tab; pm - mtx_tab < NMACGLYPHS; pm++)
             pm->name = (char *) mac_glyph_names[pm - mtx_tab];
         break;
     case 0x00020000:
-        l = get_ushort(); /* some fonts have this value different from nglyphs */
+        l = get_ushort();       /* some fonts have this value different from nglyphs */
         for (pm = mtx_tab; pm - mtx_tab < l; pm++)
             pm->index = get_ushort();
         if ((pd = name_lookup("post")) == NULL)
@@ -513,10 +513,10 @@
                 k = pm->index - NMACGLYPHS;
                 if (k < m) {
                     for (p = ps_glyphs_buf; k > 0; k--)
-                        p = (char *)strend(p) + 1;
+                        p = (char *) strend(p) + 1;
                     pm->name = p;
                 } else {
-                    pm->name = NULL; /* index out of valid range, fix name to notdef */
+                    pm->name = NULL;    /* index out of valid range, fix name to notdef */
                 }
             }
         }
@@ -548,16 +548,16 @@
     ttf_seek_tab("name", 0);
     i = ftell(fontfile);
     (void) get_ushort();        /* skip Format selector (=0) */
-    n = get_ushort();       /* number of name records */
-    j = get_ushort() + i;   /* start of string storage */
-    i += 3*TTF_USHORT_SIZE; /* update the current offset */
+    n = get_ushort();           /* number of name records */
+    j = get_ushort() + i;       /* start of string storage */
+    i += 3 * TTF_USHORT_SIZE;   /* update the current offset */
     while (n-- > 0) {
         ttf_seek_off("name", i);
         platform_id = get_ushort();
         encoding_id = get_ushort();
         (void) get_ushort();    /* skip language_id */
-        k = get_ushort(); /* name_id */
-        l = get_ushort(); /* string length */
+        k = get_ushort();       /* name_id */
+        l = get_ushort();       /* string length */
         if ((platform_id == 1 && encoding_id == 0) &&
             (k == 0 || k == 1 || k == 4 || k == 5 || k == 6)) {
             ttf_seek_off("name", j + get_ushort());
@@ -582,11 +582,11 @@
                 FontName = p;
                 break;
             }
-            if (Notice != NULL && FamilyName != NULL && 
+            if (Notice != NULL && FamilyName != NULL &&
                 FullName != NULL && FontName != NULL && Version != NULL)
                 break;
         }
-        i += 6*TTF_USHORT_SIZE;
+        i += 6 * TTF_USHORT_SIZE;
     }
     if ((pd = name_lookup("PCLT")) != NULL) {
         ttf_seek_off("PCLT",
@@ -595,16 +595,16 @@
         XHeight = get_ushort();
         if (XHeight > FontBBox4) {
             ttf_warn("XHeight is too big (%i)\n"
-                     "This is likely a font bug, so I discarded this parameter.", 
-                     (int)get_ttf_funit(XHeight));
+                     "This is likely a font bug, so I discarded this parameter.",
+                     (int) get_ttf_funit(XHeight));
             XHeight = 0;
         }
-        ttf_skip(2*TTF_USHORT_SIZE);
+        ttf_skip(2 * TTF_USHORT_SIZE);
         CapHeight = get_ushort();
         if (CapHeight > FontBBox4) {
             ttf_warn("CapHeight is too big (%i)\n"
-                     "This is likely a font bug, so I discarded this parameter.", 
-                     (int)get_ttf_funit(CapHeight));
+                     "This is likely a font bug, so I discarded this parameter.",
+                     (int) get_ttf_funit(CapHeight));
             CapHeight = 0;
         }
     }
@@ -650,7 +650,7 @@
     }
     ttf_seek_off("kern", pd->offset + TTF_USHORT_SIZE);
     for (n = get_ushort(); n > 0; n--) {
-        ttf_skip(2*TTF_USHORT_SIZE);
+        ttf_skip(2 * TTF_USHORT_SIZE);
         k = get_ushort();
         if (!(k & 1) || (k & 2) || (k & 4))
             return;
@@ -660,7 +660,7 @@
             continue;
         }
         k = get_ushort();
-        ttf_skip(3*TTF_USHORT_SIZE);
+        ttf_skip(3 * TTF_USHORT_SIZE);
         while (k-- > 0) {
             i = get_ushort();
             j = get_ushort();
@@ -677,14 +677,14 @@
 {
     return (s == NULL || s == notdef);
     /*
-        strcmp(s, ".null") == 0 ||
-        strcmp(s, ".notdef") == 0 ||
-        strcmp(s, "CR") == 0 ||
-        strcmp(s, "nonmarkingreturn") == 0
-    */
+       strcmp(s, ".null") == 0 ||
+       strcmp(s, ".notdef") == 0 ||
+       strcmp(s, "CR") == 0 ||
+       strcmp(s, "nonmarkingreturn") == 0
+     */
 }
 
-void print_glyph_name(FILE *f, long glyph_index, int convention)
+void print_glyph_name(FILE * f, long glyph_index, int convention)
 {
     unicode_entry *u;
     static char buf[1024];
@@ -723,24 +723,24 @@
                 }
                 ttf_warn
                     ("glyph %li have multiple encodings (the first one being used): %s",
-                         glyph_index, buf);
+                     glyph_index, buf);
             }
         }
         break;
     }
 }
 
-void print_char_metric(FILE *f, int charcode, long glyph_index)
+void print_char_metric(FILE * f, int charcode, long glyph_index)
 {
     assert(glyph_index >= 0 && glyph_index < nglyphs);
-    fprintf(f, "C %i ; WX %i ; N ", (int) charcode, 
-            (int)get_ttf_funit(mtx_tab[glyph_index].wx));
+    fprintf(f, "C %i ; WX %i ; N ", (int) charcode,
+            (int) get_ttf_funit(mtx_tab[glyph_index].wx));
     print_glyph_name(f, glyph_index, print_glyph);
-    fprintf(f, " ; B %i %i %i %i ;\n", 
-            (int)get_ttf_funit(mtx_tab[glyph_index].bbox[0]),
-            (int)get_ttf_funit(mtx_tab[glyph_index].bbox[1]),
-            (int)get_ttf_funit(mtx_tab[glyph_index].bbox[2]),
-            (int)get_ttf_funit(mtx_tab[glyph_index].bbox[3]));
+    fprintf(f, " ; B %i %i %i %i ;\n",
+            (int) get_ttf_funit(mtx_tab[glyph_index].bbox[0]),
+            (int) get_ttf_funit(mtx_tab[glyph_index].bbox[1]),
+            (int) get_ttf_funit(mtx_tab[glyph_index].bbox[2]),
+            (int) get_ttf_funit(mtx_tab[glyph_index].bbox[3]));
 }
 
 void print_afm(char *date, char *fontname)
@@ -759,15 +759,15 @@
     print_str(FullName);
     print_str(FamilyName);
     print_str(Weight);
-    fprintf(outfile, "ItalicAngle %i", (int)(ItalicAngle/0x10000));
-    if (ItalicAngle%0x10000 > 0)
+    fprintf(outfile, "ItalicAngle %i", (int) (ItalicAngle / 0x10000));
+    if (ItalicAngle % 0x10000 > 0)
         fprintf(outfile, ".%i",
                 (int) ((ItalicAngle % 0x10000) * 1000) / 0x10000);
     fputs("\n", outfile);
     fprintf(outfile, "IsFixedPitch %s\n", IsFixedPitch ? "true" : "false");
-    fprintf(outfile, "FontBBox %i %i %i %i\n", 
-            (int)get_ttf_funit(FontBBox1),
-            (int)get_ttf_funit(FontBBox2),
+    fprintf(outfile, "FontBBox %i %i %i %i\n",
+            (int) get_ttf_funit(FontBBox1),
+            (int) get_ttf_funit(FontBBox2),
             (int) get_ttf_funit(FontBBox3), (int) get_ttf_funit(FontBBox4));
     print_dimen(UnderlinePosition);
     print_dimen(UnderlineThickness);
@@ -779,7 +779,7 @@
     print_dimen(Ascender);
     print_dimen(Descender);
     ncharmetrics = nglyphs;
-    if (use_ext_enc == 0) { /* external encoding vector not given */
+    if (use_ext_enc == 0) {     /* external encoding vector not given */
         fprintf(outfile, "StartCharMetrics %u\n", ncharmetrics);
         for (pm = mtx_tab; pm - mtx_tab < nglyphs; pm++) {
             pm->found = 1;
@@ -797,7 +797,7 @@
                     mtx_index[pe - enc_names] = pm - mtx_tab;
                     pm->found = 1;
                 } else
-                    ttf_warn("`unicode %s%.4X' is not mapped to any glyph", 
+                    ttf_warn("`unicode %s%.4X' is not mapped to any glyph",
                              GLYPH_PREFIX_UNICODE, index);
                 continue;
             }
@@ -812,7 +812,7 @@
             }
             for (pm = mtx_tab; pm - mtx_tab < nglyphs; pm++)
                 if (pm->name != NULL && strcmp(*pe, pm->name) == 0)
-                    break; 
+                    break;
             if (pm - mtx_tab < nglyphs) {
                 mtx_index[pe - enc_names] = pm - mtx_tab;
                 pm->found = 1;
@@ -844,7 +844,7 @@
                 fprintf(outfile, " %i\n", get_ttf_funit(qk->value));
             }
     fputs("EndKernPairs\nEndKernData\n", outfile);
-end_kerns:
+  end_kerns:
     fputs("EndFontMetrics\n", outfile);
 }
 
@@ -867,12 +867,12 @@
                      (int) format);
             continue;
         }
-        sprintf(end_enc_name, ".e%i%i", 
-                (int)e->platform_id, (int)e->encoding_id);
+        sprintf(end_enc_name, ".e%i%i",
+                (int) e->platform_id, (int) e->encoding_id);
         if ((file = xfopen(enc_name, FOPEN_W_MODE)) == NULL)
             ttf_fail("cannot open file for writing (%s)\n", enc_name);
         fprintf(file, "%% Encoding table from font file %s\n", fontname);
-        fprintf(file, "%% Platform ID %i", (int)e->platform_id);
+        fprintf(file, "%% Platform ID %i", (int) e->platform_id);
         switch (e->platform_id) {
         case 0:
             fprintf(file, " (Apple Unicode)");
@@ -888,8 +888,8 @@
             break;
         }
         fprintf(file, "\n");
-        fprintf(file, "%% Encoding ID %i", (int)e->encoding_id);
-        if (e->platform_id == 1 &&  e->encoding_id == 0)
+        fprintf(file, "%% Encoding ID %i", (int) e->encoding_id);
+        if (e->platform_id == 1 && e->encoding_id == 0)
             fprintf(file, " (Roman)");
         if (e->platform_id == 3)
             switch (e->encoding_id) {
@@ -901,7 +901,7 @@
                 break;
             }
         fprintf(file, "\n");
-        fprintf(file, "%% Format %i", (int)(format));
+        fprintf(file, "%% Format %i", (int) (format));
         switch (format) {
         case 0:
             fprintf(file, " (byte encoding table)");
@@ -914,7 +914,7 @@
             break;
         }
         fprintf(file, "\n");
-        fprintf(file, "/Encoding%i [\n", (int)(e - cmap_tab + 1));
+        fprintf(file, "/Encoding%i [\n", (int) (e - cmap_tab + 1));
         switch (format) {
         case 0:
             (void) get_ushort();        /* skip length */
@@ -935,10 +935,10 @@
         case 6:
             (void) get_ushort();        /* skip table length */
             (void) get_ushort();        /* skip version number */
-            first_code = get_ushort(); /* first character code */
+            first_code = get_ushort();  /* first character code */
             for (i = 0; i < first_code; ++i)
                 fprintf(file, "/%s\n", notdef);
-            length = get_ushort(); /* number of character codes */
+            length = get_ushort();      /* number of character codes */
             for (i = first_code; i < first_code + length; i++) {
                 k = get_ushort();
                 if (i > 255)
@@ -963,15 +963,15 @@
 {
     cur_file_name = NULL;
     fprintf(stderr,
-        "Usage: ttf2afm [-i|-u|-c|-v] [-e enc] [-o filename] [-m NUM] fontfile\n"
-        "    -i:          force printing glyph names in form 'index123'\n"
-        "    -u:          force printing glyph names in form 'uniABCD'\n"
-        "    -c:          print encoding tables to `basename.e<platformID><encodingID>'\n"
-        "    -v:          print version\n"
-        "    -e enc:      encode the AFM output using encoding vector from `enc'\n"
-        "    -o filename: write output to file `filename' instead of stdout\n"
-        "    -m NUM:      select unicode mapping (default = 1, ie the first)\n"
-        "    fontfile:    the TrueType fontfile\n"
+            "Usage: ttf2afm [-i|-u|-c|-v] [-e enc] [-o filename] [-m NUM] fontfile\n"
+            "    -i:          force printing glyph names in form 'index123'\n"
+            "    -u:          force printing glyph names in form 'uniABCD'\n"
+            "    -c:          print encoding tables to `basename.e<platformID><encodingID>'\n"
+            "    -v:          print version\n"
+            "    -e enc:      encode the AFM output using encoding vector from `enc'\n"
+            "    -o filename: write output to file `filename' instead of stdout\n"
+            "    -m NUM:      select unicode mapping (default = 1, ie the first)\n"
+            "    fontfile:    the TrueType fontfile\n"
             "\nPlease send bug reports or feature requests to <pdftex@tug.org>\n");
     _exit(-1);
 }
@@ -982,7 +982,7 @@
     time_t t = time(&t);
     int c;
     kpse_set_progname(argv[0]);
-    kpse_init_prog("ttf2afm", 0, 0, 0) ;
+    kpse_init_prog("ttf2afm", 0, 0, 0);
     while ((c = getopt(argc, argv, "iucve:o:m:")) != -1)
         switch (c) {
         case 'i':
@@ -1009,7 +1009,7 @@
             select_unicode = atoi(optarg);
             break;
         case 'v':
-            fprintf(stderr, 
+            fprintf(stderr,
                     "ttf2afm version " VERSION "\n"
                     "Copyright (C) 1997-2005 Han The Thanh.\n"
                     "There is NO warranty.  Redistribution of this software is\n"
@@ -1025,7 +1025,7 @@
     if (argc - optind != 1)
         usage();
     sprintf(date, "%s\n", ctime(&t));
-    *(char *)strchr(date, '\n') = 0;
+    *(char *) strchr(date, '\n') = 0;
     cur_file_name = argv[optind];
     if (print_cmap) {
         bname = xstrdup(xbasename(cur_file_name));
--- tetex-src-3.0/texk/web2c/pdftexdir/writepng.c.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/writepng.c	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2004 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: writepng.c,v 1.2 2006/01/06 22:35:43 hahe Exp hahe $
+$Id: writepng.c 217 2007-07-31 16:55:39Z oneiros $
 */
 
 #include "ptexlib.h"
@@ -27,9 +27,9 @@
 {
     double gamma;
     FILE *png_file = xfopen(img_name(img), FOPEN_RBIN_MODE);
-    
-    if ((png_ptr(img) = png_create_read_struct(PNG_LIBPNG_VER_STRING, 
-        NULL, NULL, NULL)) == NULL)
+
+    if ((png_ptr(img) = png_create_read_struct(PNG_LIBPNG_VER_STRING,
+                                               NULL, NULL, NULL)) == NULL)
         pdftex_fail("libpng: png_create_read_struct() failed");
     if ((png_info(img) = png_create_info_struct(png_ptr(img))) == NULL)
         pdftex_fail("libpng: png_create_info_struct() failed");
@@ -37,37 +37,37 @@
         pdftex_fail("libpng: internal error");
     png_init_io(png_ptr(img), png_file);
     png_read_info(png_ptr(img), png_info(img));
-	/* simple transparency support */
-    if (png_get_valid(png_ptr(img), png_info(img),  PNG_INFO_tRNS)) {
-      png_set_tRNS_to_alpha(png_ptr(img));
-	}
+    /* simple transparency support */
+    if (png_get_valid(png_ptr(img), png_info(img), PNG_INFO_tRNS)) {
+        png_set_tRNS_to_alpha(png_ptr(img));
+    }
     /* alpha channel support  */
     if (fixedpdfminorversion < 4
         && png_ptr(img)->color_type | PNG_COLOR_MASK_ALPHA)
-	  png_set_strip_alpha(png_ptr(img));
+        png_set_strip_alpha(png_ptr(img));
     /* 16bit depth support */
-    if  (fixedpdfminorversion < 5)
-      fixedimagehicolor = 0;
+    if (fixedpdfminorversion < 5)
+        fixedimagehicolor = 0;
     if (png_info(img)->bit_depth == 16 && !fixedimagehicolor)
-	  png_set_strip_16(png_ptr(img));
+        png_set_strip_16(png_ptr(img));
     /* gamma support */
-	if (fixedimageapplygamma) {
-	  if(png_get_gAMA(png_ptr(img), png_info(img), &gamma))
-		png_set_gamma(png_ptr(img), (fixedgamma / 1000.0), gamma);
-	  else
+    if (fixedimageapplygamma) {
+        if (png_get_gAMA(png_ptr(img), png_info(img), &gamma))
+            png_set_gamma(png_ptr(img), (fixedgamma / 1000.0), gamma);
+        else
             png_set_gamma(png_ptr(img), (fixedgamma / 1000.0),
                           (1000.0 / fixedimagegamma));
     }
     /* reset structure */
     png_read_update_info(png_ptr(img), png_info(img));
     /* resolution support */
-    img_width(img) =  png_info(img)->width;
-    img_height(img) =  png_info(img)->height;
+    img_width(img) = png_info(img)->width;
+    img_height(img) = png_info(img)->height;
     if (png_info(img)->valid & PNG_INFO_pHYs) {
-	  img_xres(img) = 
+        img_xres(img) =
             round(0.0254 *
                   png_get_x_pixels_per_meter(png_ptr(img), png_info(img)));
-	  img_yres(img) =
+        img_yres(img) =
             round(0.0254 *
                   png_get_y_pixels_per_meter(png_ptr(img), png_info(img)));
     }
@@ -141,7 +141,7 @@
         }
 
 
-void write_png_palette (integer img)
+void write_png_palette(integer img)
 {
     int i, j, k, l;
     png_bytep row, r, *rows;
@@ -149,19 +149,19 @@
     pdfcreateobj(0, 0);
     palette_objnum = objptr;
     if (img_colorspace_ref(img) != 0) {
-	  pdf_printf("%i 0 R\n", (int)img_colorspace_ref(img));
+        pdf_printf("%i 0 R\n", (int) img_colorspace_ref(img));
     } else {
-	  pdf_printf("[/Indexed /DeviceRGB %i %i 0 R]\n",
-	       (int)(png_info(img)->num_palette - 1),
-	       (int)palette_objnum);
-	}
+        pdf_printf("[/Indexed /DeviceRGB %i %i 0 R]\n",
+                   (int) (png_info(img)->num_palette - 1),
+                   (int) palette_objnum);
+    }
     pdfbeginstream();
     if (png_info(img)->interlace_type == PNG_INTERLACE_NONE) {
         row = xtalloc(png_info(img)->rowbytes, png_byte);
-	write_noninterlaced(write_simple_pixel(r));
+        write_noninterlaced(write_simple_pixel(r));
         xfree(row);
     } else {
-        if (png_info(img)->height*png_info(img)->rowbytes >= 10240000L)
+        if (png_info(img)->height * png_info(img)->rowbytes >= 10240000L)
             pdftex_warn
                 ("large interlaced PNG might cause out of memory (use non-interlaced PNG to fix this)");
         rows = xtalloc(png_info(img)->height, png_bytep);
@@ -185,22 +185,22 @@
     }
 }
 
-void write_png_gray (integer img)
+void write_png_gray(integer img)
 {
     int i, j, k, l;
     png_bytep row, r, *rows;
     if (img_colorspace_ref(img) != 0) {
-        pdf_printf("%i 0 R\n", (int)img_colorspace_ref(img));
+        pdf_printf("%i 0 R\n", (int) img_colorspace_ref(img));
     } else {
-	  pdf_puts("/DeviceGray\n");
-	}
+        pdf_puts("/DeviceGray\n");
+    }
     pdfbeginstream();
     if (png_info(img)->interlace_type == PNG_INTERLACE_NONE) {
         row = xtalloc(png_info(img)->rowbytes, png_byte);
-	write_noninterlaced(write_simple_pixel(r));
+        write_noninterlaced(write_simple_pixel(r));
         xfree(row);
     } else {
-        if (png_info(img)->height*png_info(img)->rowbytes >= 10240000L)
+        if (png_info(img)->height * png_info(img)->rowbytes >= 10240000L)
             pdftex_warn
                 ("large interlaced PNG might cause out of memory (use non-interlaced PNG to fix this)");
         rows = xtalloc(png_info(img)->height, png_bytep);
@@ -215,7 +215,7 @@
 
 
 
-void write_png_gray_alpha (integer img)
+void write_png_gray_alpha(integer img)
 {
     int i, j, k, l;
     png_bytep row, r, *rows;
@@ -225,80 +225,80 @@
     integer smask_size = 0;
     int bitdepth;
     if (img_colorspace_ref(img) != 0) {
-        pdf_printf("%i 0 R\n", (int)img_colorspace_ref(img));
+        pdf_printf("%i 0 R\n", (int) img_colorspace_ref(img));
     } else {
-	  pdf_puts("/DeviceGray\n");
-	}
+        pdf_puts("/DeviceGray\n");
+    }
     pdfcreateobj(0, 0);
     smask_objnum = objptr;
     pdf_printf("/SMask %i 0 R\n", (int) smask_objnum);
-    smask_size = (png_info(img)->rowbytes/2)*png_info(img)->height;
+    smask_size = (png_info(img)->rowbytes / 2) * png_info(img)->height;
     smask = xtalloc(smask_size, png_byte);
     pdfbeginstream();
     if (png_info(img)->interlace_type == PNG_INTERLACE_NONE) {
         row = xtalloc(png_info(img)->rowbytes, png_byte);
-	if ((png_info(img)->bit_depth == 16) && fixedimagehicolor) {
-	  write_noninterlaced(write_gray_pixel_16(r));
-	} else {
-	  write_noninterlaced(write_gray_pixel_8(r));
-	}
+        if ((png_info(img)->bit_depth == 16) && fixedimagehicolor) {
+            write_noninterlaced(write_gray_pixel_16(r));
+        } else {
+            write_noninterlaced(write_gray_pixel_8(r));
+        }
         xfree(row);
     } else {
-        if (png_info(img)->height*png_info(img)->rowbytes >= 10240000L)
+        if (png_info(img)->height * png_info(img)->rowbytes >= 10240000L)
             pdftex_warn
                 ("large interlaced PNG might cause out of memory (use non-interlaced PNG to fix this)");
         rows = xtalloc(png_info(img)->height, png_bytep);
         for (i = 0; (unsigned) i < png_info(img)->height; i++)
             rows[i] = xtalloc(png_info(img)->rowbytes, png_byte);
         png_read_image(png_ptr(img), rows);
-	if ((png_info(img)->bit_depth == 16) && fixedimagehicolor) {
-	  write_interlaced(write_gray_pixel_16(row));
-	} else {
-	  write_interlaced(write_gray_pixel_8(row));
-	}
+        if ((png_info(img)->bit_depth == 16) && fixedimagehicolor) {
+            write_interlaced(write_gray_pixel_16(row));
+        } else {
+            write_interlaced(write_gray_pixel_8(row));
+        }
         xfree(rows);
     }
     pdfendstream();
     pdfflush();
     /* now write the Smask object */
     if (smask_objnum > 0) {
-	  bitdepth = (int)png_info(img)->bit_depth;
+        bitdepth = (int) png_info(img)->bit_depth;
         pdfbegindict(smask_objnum, 0);
-      pdf_puts("/Type /XObject\n/Subtype /Image\n");
-      pdf_printf("/Width %i\n/Height %i\n/BitsPerComponent %i\n",
-		 (int)png_info(img)->width,
-		 (int)png_info(img)->height,
-		 (bitdepth == 16 ? 8 : bitdepth));
-      pdf_puts("/ColorSpace /DeviceGray\n");
-      pdfbeginstream();
-      for (i = 0; i <smask_size; i++) {
-		if (i % 8 == 0)
-		  pdfroom(8);
-		pdfbuf[pdfptr++] = smask[i];
-		if (bitdepth == 16)
-		  i++;
-      }
-      xfree(smask);
-      pdfendstream();
+        pdf_puts("/Type /XObject\n/Subtype /Image\n");
+        pdf_printf("/Width %i\n/Height %i\n/BitsPerComponent %i\n",
+                   (int) png_info(img)->width,
+                   (int) png_info(img)->height,
+                   (bitdepth == 16 ? 8 : bitdepth));
+        pdf_puts("/ColorSpace /DeviceGray\n");
+        pdfbeginstream();
+        for (i = 0; i < smask_size; i++) {
+            if (i % 8 == 0)
+                pdfroom(8);
+            pdfbuf[pdfptr++] = smask[i];
+            if (bitdepth == 16)
+                i++;
+        }
+        xfree(smask);
+        pdfendstream();
     }
 }
 
-void write_png_rgb (integer img)
+void write_png_rgb(integer img)
 {
     int i, j, k, l;
     png_bytep row, r, *rows;
     if (img_colorspace_ref(img) != 0) {
-        pdf_printf("%i 0 R\n", (int)img_colorspace_ref(img));
+        pdf_printf("%i 0 R\n", (int) img_colorspace_ref(img));
     } else {
-	  pdf_puts("/DeviceRGB\n");
-	}
+        pdf_puts("/DeviceRGB\n");
+    }
     pdfbeginstream();
     if (png_info(img)->interlace_type == PNG_INTERLACE_NONE) {
         row = xtalloc(png_info(img)->rowbytes, png_byte);
-	write_noninterlaced(write_simple_pixel(r));
+        write_noninterlaced(write_simple_pixel(r));
         xfree(row);
     } else {
-        if (png_info(img)->height*png_info(img)->rowbytes >= 10240000L)
+        if (png_info(img)->height * png_info(img)->rowbytes >= 10240000L)
             pdftex_warn
                 ("large interlaced PNG might cause out of memory (use non-interlaced PNG to fix this)");
         rows = xtalloc(png_info(img)->height, png_bytep);
@@ -311,7 +311,7 @@
     pdfendstream();
 }
 
-void write_png_rgb_alpha (integer img)
+void write_png_rgb_alpha(integer img)
 {
     int i, j, k, l;
     png_bytep row, r, *rows;
@@ -321,61 +321,61 @@
     integer smask_size = 0;
     int bitdepth;
     if (img_colorspace_ref(img) != 0) {
-        pdf_printf("%i 0 R\n", (int)img_colorspace_ref(img));
+        pdf_printf("%i 0 R\n", (int) img_colorspace_ref(img));
     } else {
-	  pdf_puts("/DeviceRGB\n");
-	}
+        pdf_puts("/DeviceRGB\n");
+    }
     pdfcreateobj(0, 0);
     smask_objnum = objptr;
     pdf_printf("/SMask %i 0 R\n", (int) smask_objnum);
-    smask_size = (png_info(img)->rowbytes/2)*png_info(img)->height;
+    smask_size = (png_info(img)->rowbytes / 2) * png_info(img)->height;
     smask = xtalloc(smask_size, png_byte);
     pdfbeginstream();
     if (png_info(img)->interlace_type == PNG_INTERLACE_NONE) {
         row = xtalloc(png_info(img)->rowbytes, png_byte);
-	if ((png_info(img)->bit_depth == 16) && fixedimagehicolor) {
-	  write_noninterlaced(write_rgb_pixel_16(r));
-	} else {
-	  write_noninterlaced(write_rgb_pixel_8(r));
-	}
+        if ((png_info(img)->bit_depth == 16) && fixedimagehicolor) {
+            write_noninterlaced(write_rgb_pixel_16(r));
+        } else {
+            write_noninterlaced(write_rgb_pixel_8(r));
+        }
         xfree(row);
     } else {
-        if (png_info(img)->height*png_info(img)->rowbytes >= 10240000L)
+        if (png_info(img)->height * png_info(img)->rowbytes >= 10240000L)
             pdftex_warn
                 ("large interlaced PNG might cause out of memory (use non-interlaced PNG to fix this)");
         rows = xtalloc(png_info(img)->height, png_bytep);
         for (i = 0; (unsigned) i < png_info(img)->height; i++)
             rows[i] = xtalloc(png_info(img)->rowbytes, png_byte);
         png_read_image(png_ptr(img), rows);
-	if ((png_info(img)->bit_depth == 16) && fixedimagehicolor) {
-	  write_interlaced(write_rgb_pixel_16(row));
-	} else {
-	  write_interlaced(write_rgb_pixel_8(row));
-	}
+        if ((png_info(img)->bit_depth == 16) && fixedimagehicolor) {
+            write_interlaced(write_rgb_pixel_16(row));
+        } else {
+            write_interlaced(write_rgb_pixel_8(row));
+        }
         xfree(rows);
     }
     pdfendstream();
     pdfflush();
     /* now write the Smask object */
     if (smask_objnum > 0) {
-	  bitdepth = (int)png_info(img)->bit_depth;
+        bitdepth = (int) png_info(img)->bit_depth;
         pdfbegindict(smask_objnum, 0);
-      pdf_puts("/Type /XObject\n/Subtype /Image\n");
-      pdf_printf("/Width %i\n/Height %i\n/BitsPerComponent %i\n",
-		 (int)png_info(img)->width,
-		 (int)png_info(img)->height,
-				 (bitdepth == 16 ? 8 : bitdepth));
-      pdf_puts("/ColorSpace /DeviceGray\n");
-      pdfbeginstream();
-      for (i = 0; i <smask_size; i++) {
-		if (i % 8 == 0)
-		  pdfroom(8);
-		pdfbuf[pdfptr++] = smask[i];
-		if (bitdepth == 16)
-		  i++;
-      }
-      xfree(smask);
-      pdfendstream();
+        pdf_puts("/Type /XObject\n/Subtype /Image\n");
+        pdf_printf("/Width %i\n/Height %i\n/BitsPerComponent %i\n",
+                   (int) png_info(img)->width,
+                   (int) png_info(img)->height,
+                   (bitdepth == 16 ? 8 : bitdepth));
+        pdf_puts("/ColorSpace /DeviceGray\n");
+        pdfbeginstream();
+        for (i = 0; i < smask_size; i++) {
+            if (i % 8 == 0)
+                pdfroom(8);
+            pdfbuf[pdfptr++] = smask[i];
+            if (bitdepth == 16)
+                i++;
+        }
+        xfree(smask);
+        pdfendstream();
     }
 }
 
@@ -383,11 +383,11 @@
 /**********************************************************************/
 /*
  *
- * The |copy_png| function is from Hartmut Henkel. The goal is to use 
+ * The |copy_png| function is from Hartmut Henkel. The goal is to use
  * pdf's native FlateDecode support if that is possible.
  *
  * Only a subset of the png files allows this, but when possible it
- * greatly improves inclusion speed. 
+ * greatly improves inclusion speed.
  *
  */
 
@@ -397,7 +397,7 @@
 {
     unsigned char buf[4];
     if (fread(buf, 1, 4, fp) != 4)
-	pdftex_fail("writepng: reading chunk type failed");
+        pdftex_fail("writepng: reading chunk type failed");
     return ((((((int) buf[0] << 8) + buf[1]) << 8) + buf[2]) << 8) + buf[3];
 }
 
@@ -409,176 +409,177 @@
     FILE *fp = (FILE *) png_ptr(img)->io_ptr;
     int i, len, type, streamlength = 0;
     boolean endflag = false;
-    int idat = 0;		/* flag to check continuous IDAT chunks sequence */
+    int idat = 0;               /* flag to check continuous IDAT chunks sequence */
     /* 1st pass to find overall stream /Length */
     if (fseek(fp, 8, SEEK_SET) != 0)
-	  pdftex_fail("writepng: fseek in PNG file failed");
+        pdftex_fail("writepng: fseek in PNG file failed");
     do {
-	  len = spng_getint(fp);
-	  type = spng_getint(fp);
-	  switch (type) {
-	  case SPNG_CHUNK_IEND:
-	    endflag = true;
-	    break;
-	  case SPNG_CHUNK_IDAT:
-	    streamlength += len;
-	  default:
-	    if (fseek(fp, len + 4, SEEK_CUR) != 0)
-		pdftex_fail("writepng: fseek in PNG file failed");
-	  }
+        len = spng_getint(fp);
+        type = spng_getint(fp);
+        switch (type) {
+        case SPNG_CHUNK_IEND:
+            endflag = true;
+            break;
+        case SPNG_CHUNK_IDAT:
+            streamlength += len;
+        default:
+            if (fseek(fp, len + 4, SEEK_CUR) != 0)
+                pdftex_fail("writepng: fseek in PNG file failed");
+        }
     } while (endflag == false);
-    pdf_printf("/Length %d\n", streamlength);
-    pdf_printf("/Filter /FlateDecode\n");
-    pdf_printf("/DecodeParms << ");
-    pdf_printf("/Colors %d ", png_info(img)->color_type == 2 ? 3 : 1);
-    pdf_printf("/Columns %d ", (int) png_info(img)->width);
-    pdf_printf("/BitsPerComponent %i ", (int) png_info(img)->bit_depth);
-    pdf_printf("/Predictor %d ", 10);	/* actual predictor defined on line basis */
-    pdf_printf(">>\n>>\nstream\n");
+    pdf_printf("/Length %d\n"
+               "/Filter/FlateDecode\n"
+               "/DecodeParms<<"
+               "/Colors %d"
+               "/Columns %d"
+               "/BitsPerComponent %i"
+               "/Predictor 10>>\n>>\nstream\n", streamlength,
+               png_info(img)->color_type == 2 ? 3 : 1,
+               (int) png_info(img)->width, (int) png_info(img)->bit_depth);
     /* 2nd pass to copy data */
     endflag = false;
     if (fseek(fp, 8, SEEK_SET) != 0)
-	pdftex_fail("writepng: fseek in PNG file failed");
+        pdftex_fail("writepng: fseek in PNG file failed");
     do {
-	len = spng_getint(fp);
-	type = spng_getint(fp);
-	switch (type) {
-	case SPNG_CHUNK_IDAT:	/* do copy */
-	    if (idat == 2)
-		pdftex_fail("writepng: IDAT chunk sequence broken");
-	    idat = 1;
-	    while (len > 0) {
-		i = (len > pdfbufsize) ? pdfbufsize : len;
-		pdfroom(i);
-		fread(&pdfbuf[pdfptr], 1, i, fp);
-		pdfptr += i;
-		len -= i;
-	    }
-	    if (fseek(fp, 4, SEEK_CUR) != 0)
-		pdftex_fail("writepng: fseek in PNG file failed");
-	    break;
-	case SPNG_CHUNK_IEND:	/* done */
+        len = spng_getint(fp);
+        type = spng_getint(fp);
+        switch (type) {
+        case SPNG_CHUNK_IDAT:  /* do copy */
+            if (idat == 2)
+                pdftex_fail("writepng: IDAT chunk sequence broken");
+            idat = 1;
+            while (len > 0) {
+                i = (len > pdfbufsize) ? pdfbufsize : len;
+                pdfroom(i);
+                fread(&pdfbuf[pdfptr], 1, i, fp);
+                pdfptr += i;
+                len -= i;
+            }
+            if (fseek(fp, 4, SEEK_CUR) != 0)
+                pdftex_fail("writepng: fseek in PNG file failed");
+            break;
+        case SPNG_CHUNK_IEND:  /* done */
             pdfendstream();
-	    endflag = true;
-	    break;
-	default:
-	    if (idat == 1)
-		idat = 2;
-	    if (fseek(fp, len + 4, SEEK_CUR) != 0)
-		pdftex_fail("writepng: fseek in PNG file failed");
-	}
+            endflag = true;
+            break;
+        default:
+            if (idat == 1)
+                idat = 2;
+            if (fseek(fp, len + 4, SEEK_CUR) != 0)
+                pdftex_fail("writepng: fseek in PNG file failed");
+        }
     } while (endflag == false);
 }
 
-void write_png (integer img)
+void write_png(integer img)
 {
 
     double gamma, checked_gamma;
-	int i;
+    int i;
     integer palette_objnum = 0;
-    if  (fixedpdfminorversion < 5)
-      fixedimagehicolor = 0;
+    if (fixedpdfminorversion < 5)
+        fixedimagehicolor = 0;
 
     pdf_puts("/Type /XObject\n/Subtype /Image\n");
     pdf_printf("/Width %i\n/Height %i\n/BitsPerComponent %i\n",
-               (int)png_info(img)->width,
+               (int) png_info(img)->width,
                (int) png_info(img)->height, (int) png_info(img)->bit_depth);
     pdf_puts("/ColorSpace ");
-	checked_gamma = 1.0;
-	if (fixedimageapplygamma) {
-	  if(png_get_gAMA(png_ptr(img), png_info(img), &gamma)) {
-		checked_gamma = (fixedgamma / 1000.0) * gamma;
-	  } else {
-		checked_gamma = (fixedgamma / 1000.0) * (1000.0/ fixedimagegamma );
-	  }
-	}
-    /* the switching between |png_info| and |png_ptr| queries has been trial and error. 
-	 */
+    checked_gamma = 1.0;
+    if (fixedimageapplygamma) {
+        if (png_get_gAMA(png_ptr(img), png_info(img), &gamma)) {
+            checked_gamma = (fixedgamma / 1000.0) * gamma;
+        } else {
+            checked_gamma = (fixedgamma / 1000.0) * (1000.0 / fixedimagegamma);
+        }
+    }
+    /* the switching between |png_info| and |png_ptr| queries has been trial and error.
+     */
     if (fixedpdfminorversion > 1 && png_info(img)->interlace_type == PNG_INTERLACE_NONE && (png_ptr(img)->transformations == 0 || png_ptr(img)->transformations == 0x2000)      /* gamma */
-		&& !(png_ptr(img)->color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
-			 png_ptr(img)->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-		&& (fixedimagehicolor || (png_ptr(img)->bit_depth <= 8))
-		&& (checked_gamma <= 1.01 && checked_gamma > 0.99)
+        &&!(png_ptr(img)->color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
+            png_ptr(img)->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+        && (fixedimagehicolor || (png_ptr(img)->bit_depth <= 8))
+        && (checked_gamma <= 1.01 && checked_gamma > 0.99)
         ) {
-    if (img_colorspace_ref(img) != 0) {
-        pdf_printf("%i 0 R\n", (int)img_colorspace_ref(img));
+        if (img_colorspace_ref(img) != 0) {
+            pdf_printf("%i 0 R\n", (int) img_colorspace_ref(img));
         } else {
-	  switch (png_info(img)->color_type) {
-	  case PNG_COLOR_TYPE_PALETTE:
-		pdfcreateobj(0, 0);
-		palette_objnum = objptr;
-		pdf_printf("[/Indexed /DeviceRGB %i %i 0 R]\n",
-				   (int) (png_info(img)->num_palette - 1),
-				   (int) palette_objnum);
-		break;
-      case PNG_COLOR_TYPE_GRAY:
-		pdf_puts("/DeviceGray\n");
-        break;
-	  default: /* RGB */
-		pdf_puts("/DeviceRGB\n");
-	  };
-	}
-	  tex_printf(" (PNG copy)");
-	  copy_png(img);
-	  if (palette_objnum > 0) {
+            switch (png_info(img)->color_type) {
+            case PNG_COLOR_TYPE_PALETTE:
+                pdfcreateobj(0, 0);
+                palette_objnum = objptr;
+                pdf_printf("[/Indexed /DeviceRGB %i %i 0 R]\n",
+                           (int) (png_info(img)->num_palette - 1),
+                           (int) palette_objnum);
+                break;
+            case PNG_COLOR_TYPE_GRAY:
+                pdf_puts("/DeviceGray\n");
+                break;
+            default:           /* RGB */
+                pdf_puts("/DeviceRGB\n");
+            };
+        }
+        tex_printf(" (PNG copy)");
+        copy_png(img);
+        if (palette_objnum > 0) {
             pdfbegindict(palette_objnum, 0);
-		pdfbeginstream();
-		for (i = 0; i < png_info(img)->num_palette; i++) {
-		  pdfroom(3);
-		  pdfbuf[pdfptr++] = png_info(img)->palette[i].red;
-		  pdfbuf[pdfptr++] = png_info(img)->palette[i].green;
-		  pdfbuf[pdfptr++] = png_info(img)->palette[i].blue;
-		}
-		pdfendstream();
-	  }
-	} else {
-    if (0) {
-	  tex_printf(" PNG copy skipped because: ");
-	  if(fixedimageapplygamma && 
-         (checked_gamma > 1.01 || checked_gamma < 0.99))
-		tex_printf("gamma delta=%lf ", checked_gamma);
-	  if (png_ptr(img)->transformations != PNG_TRANSFORM_IDENTITY)
+            pdfbeginstream();
+            for (i = 0; i < png_info(img)->num_palette; i++) {
+                pdfroom(3);
+                pdfbuf[pdfptr++] = png_info(img)->palette[i].red;
+                pdfbuf[pdfptr++] = png_info(img)->palette[i].green;
+                pdfbuf[pdfptr++] = png_info(img)->palette[i].blue;
+            }
+            pdfendstream();
+        }
+    } else {
+        if (0) {
+            tex_printf(" PNG copy skipped because: ");
+            if (fixedimageapplygamma &&
+                (checked_gamma > 1.01 || checked_gamma < 0.99))
+                tex_printf("gamma delta=%lf ", checked_gamma);
+            if (png_ptr(img)->transformations != PNG_TRANSFORM_IDENTITY)
                 tex_printf("transform=%lu",
                            (long) png_ptr(img)->transformations);
             if ((png_info(img)->color_type != PNG_COLOR_TYPE_GRAY)
                 && (png_info(img)->color_type != PNG_COLOR_TYPE_RGB)
                 && (png_info(img)->color_type != PNG_COLOR_TYPE_PALETTE))
-		tex_printf("colortype ");
- 	  if (fixedpdfminorversion <= 1)
+                tex_printf("colortype ");
+            if (fixedpdfminorversion <= 1)
                 tex_printf("version=%d ", (int) fixedpdfminorversion);
-	  if (png_info(img)->interlace_type != PNG_INTERLACE_NONE)
-		tex_printf("interlaced ");
-	  if (png_info(img)->bit_depth > 8)
-		tex_printf("bitdepth=%d ",png_info(img)->bit_depth);
-	  if (png_get_valid(png_ptr(img), png_info(img),  PNG_INFO_tRNS)) 
-		tex_printf("simple transparancy ");
-	}
-	  switch (png_info(img)->color_type) {
-	  case PNG_COLOR_TYPE_PALETTE:
-		write_png_palette(img);
-		break;
-	  case PNG_COLOR_TYPE_GRAY:
-		write_png_gray(img);
-		break;
-	  case PNG_COLOR_TYPE_GRAY_ALPHA:
-		if (fixedpdfminorversion >=4)
-		  write_png_gray_alpha(img);
-		else
-		  write_png_gray(img);
-		break;
-	  case PNG_COLOR_TYPE_RGB:
-		write_png_rgb(img);
-		break;
-	  case PNG_COLOR_TYPE_RGB_ALPHA:
-		if (fixedpdfminorversion >=4)
-		  write_png_rgb_alpha(img);
-		else
-		  write_png_rgb(img);
-		break;
-	  default:
+            if (png_info(img)->interlace_type != PNG_INTERLACE_NONE)
+                tex_printf("interlaced ");
+            if (png_info(img)->bit_depth > 8)
+                tex_printf("bitdepth=%d ", png_info(img)->bit_depth);
+            if (png_get_valid(png_ptr(img), png_info(img), PNG_INFO_tRNS))
+                tex_printf("simple transparancy ");
+        }
+        switch (png_info(img)->color_type) {
+        case PNG_COLOR_TYPE_PALETTE:
+            write_png_palette(img);
+            break;
+        case PNG_COLOR_TYPE_GRAY:
+            write_png_gray(img);
+            break;
+        case PNG_COLOR_TYPE_GRAY_ALPHA:
+            if (fixedpdfminorversion >= 4)
+                write_png_gray_alpha(img);
+            else
+                write_png_gray(img);
+            break;
+        case PNG_COLOR_TYPE_RGB:
+            write_png_rgb(img);
+            break;
+        case PNG_COLOR_TYPE_RGB_ALPHA:
+            if (fixedpdfminorversion >= 4)
+                write_png_rgb_alpha(img);
+            else
+                write_png_rgb(img);
+            break;
+        default:
             pdftex_fail("unsupported type of color_type <%i>",
                         png_info(img)->color_type);
-	  }
-	}
-	pdfflush(); 
+        }
+    }
+    pdfflush();
 }
--- tetex-src-3.0/texk/web2c/pdftexdir/epdf.h.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/epdf.h	2008-01-06 17:27:02.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2006 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: epdf.h,v 1.6 2005/11/28 23:29:32 hahe Exp $
+$Id: epdf.h 217 2007-07-31 16:55:39Z oneiros $
 */
 
 extern "C" {
@@ -28,19 +28,19 @@
 
 /* the following code is extremly ugly but needed for including web2c/config.h */
 
-#include <kpathsea/c-proto.h>     /* define P?H macros */
+#include <kpathsea/c-proto.h>   /* define P?H macros */
 
-typedef const char *const_string; /* including kpathsea/types.h doesn't work on some systems */
+    typedef const char *const_string;   /* including kpathsea/types.h doesn't work on some systems */
 
-#define KPATHSEA_CONFIG_H         /* avoid including other kpathsea header files */
-                                  /* from web2c/config.h */
+#define KPATHSEA_CONFIG_H       /* avoid including other kpathsea header files */
+    /* from web2c/config.h */
 
-#ifdef CONFIG_H                   /* CONFIG_H has been defined by some xpdf */
-#undef CONFIG_H                   /* header file */
+#ifdef CONFIG_H                 /* CONFIG_H has been defined by some xpdf */
+#  undef CONFIG_H               /* header file */
 #endif
 
-#include <web2c/c-auto.h>         /* define SIZEOF_LONG */
-#include <web2c/config.h>         /* define type integer */
+#include <web2c/c-auto.h>       /* define SIZEOF_LONG */
+#include <web2c/config.h>       /* define type integer */
 
 #include <web2c/pdftexdir/ptexmac.h>
 
@@ -48,15 +48,15 @@
 
 /* #-define pdfbufsize      pdfbufmax */
 
-extern float epdf_width;
-extern float epdf_height;
-extern float epdf_orig_x;
-extern float epdf_orig_y;
-extern integer epdf_selected_page;
-extern integer epdf_num_pages;
-extern integer epdf_page_box;
-extern void *epdf_doc;
-extern void *epdf_xref;
+    extern float epdf_width;
+    extern float epdf_height;
+    extern float epdf_orig_x;
+    extern float epdf_orig_y;
+    extern integer epdf_selected_page;
+    extern integer epdf_num_pages;
+    extern integer epdf_page_box;
+    extern void *epdf_doc;
+    extern void *epdf_xref;
 
     extern integer pdfboxspecmedia;
     extern integer pdfboxspeccrop;
@@ -64,45 +64,46 @@
     extern integer pdfboxspectrim;
     extern integer pdfboxspecart;
 
-extern integer pdfstreamlength;
-extern integer pdfptr;
+    extern integer pdfstreamlength;
+    extern integer pdfptr;
     extern integer poolptr;
-typedef unsigned char eightbits  ;
+    typedef unsigned char eightbits;
     extern eightbits *pdfbuf;
     extern integer pdfbufsize;
     extern integer pdfosmode;
     extern eightbits pdflastbyte;
+    extern integer fixedinclusioncopyfont;
 
-extern char notdef[];
+    extern char notdef[];
 
-extern int is_subsetable(struct fm_entry *);
-extern struct fm_entry * lookup_fontmap(char *);
-extern integer get_fontfile(struct fm_entry *);
-extern integer get_fontname(struct fm_entry *);
-extern integer pdfnewobjnum(void);
+    extern int is_subsetable(struct fm_entry *);
+    extern struct fm_entry *lookup_fontmap(char *);
+    extern integer get_fontfile(struct fm_entry *);
+    extern integer get_fontname(struct fm_entry *);
+    extern integer pdfnewobjnum(void);
     extern integer read_pdf_info(char *, char *, integer, integer, integer,
                                  integer);
     extern void embed_whole_font(struct fd_entry *);
-extern void epdf_check_mem(void);
-extern void epdf_delete(void);
-extern void epdf_free(void);
+    extern void epdf_check_mem(void);
+    extern void epdf_delete(void);
+    extern void epdf_free(void);
     __attribute__ ((format(printf, 1, 2)))
-extern void pdf_printf(const char *fmt,...);
-extern void pdf_puts(const char *);
-extern void pdfbeginstream(void);
-extern void pdfendobj(void);
-extern void pdfendstream(void);
-extern void pdfflush(void);
+    extern void pdf_printf(const char *fmt, ...);
+    extern void pdf_puts(const char *);
+    extern void pdfbeginstream(void);
+    extern void pdfendobj(void);
+    extern void pdfendstream(void);
+    extern void pdfflush(void);
     __attribute__ ((noreturn, format(printf, 1, 2)))
-extern void pdftex_fail(const char *fmt,...);
+    extern void pdftex_fail(const char *fmt, ...);
     __attribute__ ((format(printf, 1, 2)))
-extern void pdftex_warn(const char *fmt,...);
+    extern void pdftex_warn(const char *fmt, ...);
     __attribute__ ((format(printf, 1, 2)))
-extern void tex_printf(const char *, ...);
-extern void write_epdf(void);
+    extern void tex_printf(const char *, ...);
+    extern void write_epdf(void);
     extern void zpdfbegindict(integer, bool);
     extern void zpdfbeginobj(integer, bool);
-extern void zpdfcreateobj(integer, integer);
+    extern void zpdfcreateobj(integer, integer);
     extern void zpdfnewdict(integer, integer, bool);
     extern void zpdfosgetosbuf(integer);
 
@@ -116,13 +117,13 @@
     extern void epdf_write_enc(char **, integer);
 
 /* utils.c */
-extern char *convertStringToPDFString(char *in, int len);
+    extern char *convertStringToPDFString(char *in, int len);
     extern char *stripzeros(char *a);
 
 /* config.c */
-extern integer cfgpar(integer);
+    extern integer cfgpar(integer);
 
 /* avlstuff.c */
-extern void avl_put_obj (integer, integer);
-extern integer avl_find_obj (integer, integer, integer);
+    extern void avl_put_obj(integer, integer);
+    extern integer avl_find_obj(integer, integer, integer);
 }
--- tetex-src-3.0/texk/web2c/pdftexdir/tounicode.c.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/tounicode.c	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 2006 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 2006-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,9 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+$Id: tounicode.c 217 2007-07-31 16:55:39Z oneiros $
 */
 
 #include "ptexlib.h"
--- tetex-src-3.0/texk/web2c/pdftexdir/mapfile.c.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/mapfile.c	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2006 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: mapfile.c,v 1.1 2006/12/14 01:21:33 hahe Exp hahe $
+$Id: mapfile.c 217 2007-07-31 16:55:39Z oneiros $
 */
 
 #include <math.h>
@@ -49,19 +49,19 @@
 
 static const char nontfm[] = "<nontfm>";
 
-#define read_field(r, q, buf) do {                     \
+#define read_field(r, q, buf) do {  \
     q = buf;                        \
     while (*r != ' ' && *r != '<' && *r != '"' && *r != '\0') \
         *q++ = *r++;                \
     *q = '\0';                      \
-    skip (r, ' ');                                     \
+    skip (r, ' ');                  \
 } while (0)
 
-#define set_field(F) do {                              \
-    if (q > buf)                                       \
-        fm->F = xstrdup(buf);                          \
+#define set_field(F) do {           \
+    if (q > buf)                    \
+        fm->F = xstrdup(buf);       \
     if (*r == '\0')                 \
-        goto done;                                     \
+        goto done;                  \
 } while (0)
 
 fm_entry *new_fm_entry(void)
@@ -71,7 +71,7 @@
     fm->tfm_name = NULL;
     fm->sfd_name = NULL;
     fm->ps_name = NULL;
-    fm->fd_flags = 4;
+    fm->fd_flags = FD_FLAGS_NOT_SET_IN_MAPLINE;
     fm->ff_name = NULL;
     fm->encname = NULL;
     fm->type = 0;
@@ -156,14 +156,14 @@
 static void create_avl_trees()
 {
     assert(tfm_tree == NULL);
-        tfm_tree = avl_create(comp_fm_entry_tfm, NULL, &avl_xallocator);
-        assert(tfm_tree != NULL);
+    tfm_tree = avl_create(comp_fm_entry_tfm, NULL, &avl_xallocator);
+    assert(tfm_tree != NULL);
     assert(ps_tree == NULL);
-        ps_tree = avl_create(comp_fm_entry_ps, NULL, &avl_xallocator);
-        assert(ps_tree != NULL);
+    ps_tree = avl_create(comp_fm_entry_ps, NULL, &avl_xallocator);
+    assert(ps_tree != NULL);
     assert(ff_tree == NULL);
-        ff_tree = avl_create(comp_ff_entry, NULL, &avl_xallocator);
-        assert(ff_tree != NULL);
+    ff_tree = avl_create(comp_ff_entry, NULL, &avl_xallocator);
+    assert(ff_tree != NULL);
     assert(encname_tree == NULL);
     encname_tree = avl_create(comp_string_entry, NULL, &avl_xallocator);
     assert(encname_tree != NULL);
@@ -280,21 +280,21 @@
     int a = 0;
     assert(fm != NULL);
 
-            if (is_fontfile(fm) && !is_included(fm)) {
-                if (warn)
-                    pdftex_warn
+    if (is_fontfile(fm) && !is_included(fm)) {
+        if (warn)
+            pdftex_warn
                 ("ambiguous entry for `%s': font file present but not included, "
                  "will be treated as font file not present", fm->tfm_name);
         xfree(fm->ff_name);
         /* do not set variable |a| as this entry will be still accepted */
-            }
+    }
 
     /* if both ps_name and font file are missing, drop this entry */
     if (fm->ps_name == NULL && !is_fontfile(fm)) {
-                if (warn)
-                    pdftex_warn
+        if (warn)
+            pdftex_warn
                 ("invalid entry for `%s': both ps_name and font file missing",
-                         fm->tfm_name);
+                 fm->tfm_name);
         a += 1;
     }
 
@@ -347,9 +347,9 @@
 }
 
 /**********************************************************************/
-/* returns true if s is one of the 14 std. font names; speed-trimmed. */
+/* returns the font number if s is one of the 14 std. font names, -1 otherwise; speed-trimmed. */
 
-boolean check_std_t1font(char *s)
+int check_std_t1font(char *s)
 {
     static const char *std_t1font_names[] = {
         "Courier",              /* 0:7 */
@@ -371,6 +371,7 @@
         { -1, -1, -1, -1, -1, -1, 8, 0, -1, 4, 10, 9, -1, -1, 5, 2, 12, 6, -1,
         3, -1, 7
     };
+    assert(s != NULL);
     const size_t n = strlen(s);
     int k = -1;
     if (n > 21)
@@ -392,11 +393,10 @@
     } else
         k = index[n];
     if (k > -1 && strcmp(std_t1font_names[k], s) == 0)
-        return true;
-    return false;
+        return k;
+    return -1;
 };
 
-
 /**********************************************************************/
 
 static void fm_scan_line()
@@ -429,15 +429,15 @@
     read_field(r, q, buf);
     set_field(tfm_name);
     if (!isdigit(*r)) {         /* 2nd field ps_name may not start with a digit */
-    read_field(r, q, buf);
+        read_field(r, q, buf);
         set_field(ps_name);
     }
     if (isdigit(*r)) {          /* font descriptor /Flags given? */
         for (s = r; isdigit(*s); s++);
         if (*s == ' ' || *s == '"' || *s == '<' || *s == '\0') {        /* not e. g. 8r.enc */
             fm->fd_flags = atoi(r);
-        while (isdigit(*r))
-            r++;
+            while (isdigit(*r))
+                r++;
         }
     }
     while (1) {                 /* loop through "specials", encoding, font file */
@@ -445,7 +445,7 @@
         switch (*r) {
         case '\0':
             goto done;
-        case '"':               /* opening quote */
+        case '"':              /* opening quote */
             r++;
             u = v = 0;
             do {
@@ -493,7 +493,7 @@
                 r += c;
                 break;
             }
-        default:                /* encoding or font file specification */
+        default:               /* encoding or font file specification */
             a = b = 0;
             if (*r == '<') {
                 a = *r++;
@@ -526,11 +526,11 @@
         }
     }
   done:
-    if (fm->ps_name != NULL && check_std_t1font(fm->ps_name))
+    if (fm->ps_name != NULL && (check_std_t1font(fm->ps_name) >= 0))
         set_std_t1font(fm);
     if (is_fontfile(fm)) {
         if (strcasecmp(strend(fm_fontfile(fm)) - 4, ".ttf") == 0)
-        set_truetype(fm);
+            set_truetype(fm);
         else if (strcasecmp(strend(fm_fontfile(fm)) - 4, ".otf") == 0)
             set_opentype(fm);
         else
@@ -557,34 +557,34 @@
 void fm_read_info()
 {
     if (tfm_tree == NULL)
-    create_avl_trees();
+        create_avl_trees();
     if (mitem->line == NULL)    /* nothing to do */
         return;
     mitem->lineno = 1;
     switch (mitem->type) {
-        case MAPFILE:
+    case MAPFILE:
         set_cur_file_name(mitem->line);
-            if (!fm_open()) {
-                pdftex_warn("cannot open font map file");
-            } else {
-                cur_file_name = (char *) nameoffile + 1;
-                tex_printf("{%s", cur_file_name);
-                while (!fm_eof()) {
+        if (!fm_open()) {
+            pdftex_warn("cannot open font map file");
+        } else {
+            cur_file_name = (char *) nameoffile + 1;
+            tex_printf("{%s", cur_file_name);
+            while (!fm_eof()) {
                 fm_scan_line();
                 mitem->lineno++;
-                }
-                fm_close();
-                tex_printf("}");
-                fm_file = NULL;
             }
-            break;
-        case MAPLINE:
-            cur_file_name = NULL;       /* makes pdftex_warn() shorter */
-        fm_scan_line();
-            break;
-        default:
-            assert(0);
+            fm_close();
+            tex_printf("}");
+            fm_file = NULL;
         }
+        break;
+    case MAPLINE:
+        cur_file_name = NULL;   /* makes pdftex_warn() shorter */
+        fm_scan_line();
+        break;
+    default:
+        assert(0);
+    }
     mitem->line = NULL;         /* done with this line */
     cur_file_name = NULL;
     return;
@@ -633,7 +633,7 @@
     ff = check_ff_exist(fm->ff_name, false);
     assert(ff != NULL);
     if (ff->ff_path == NULL)    /* ...there is no font file available */
-    return false;
+        return false;
     return true;                /* all tests passed */
 }
 
@@ -719,7 +719,7 @@
     /* search forward */
     do {
         if (fm_valid_for_font_replacement(fm))
-        return fm;
+            return fm;
         fm = (fm_entry *) avl_t_next(&t);
     } while (fm != NULL && comp_fm_entry_ps(fm, &tmp, NULL) == 0);
 
@@ -739,7 +739,7 @@
  * beginning with [+-=] flush default map file, if it has not yet been
  * read. Leading blanks and blanks immediately following [+-=] are
  * ignored.
-*/
+ */
 
 void process_map_item(char *s, int type)
 {
@@ -748,15 +748,15 @@
     if (*s == ' ')
         s++;                    /* ignore leading blank */
     switch (*s) {
-    case '+':                   /* +mapfile.map, +mapline */
+    case '+':                  /* +mapfile.map, +mapline */
         mode = FM_DUPIGNORE;    /* insert entry, if it is not duplicate */
         s++;
         break;
-    case '=':                   /* =mapfile.map, =mapline */
+    case '=':                  /* =mapfile.map, =mapline */
         mode = FM_REPLACE;      /* try to replace earlier entry */
         s++;
         break;
-    case '-':                   /* -mapfile.map, -mapline */
+    case '-':                  /* -mapfile.map, -mapline */
         mode = FM_DELETE;       /* try to delete entry */
         s++;
         break;
@@ -807,7 +807,7 @@
     mitem->mode = FM_DUPIGNORE;
     mitem->type = MAPFILE;
     mitem->line = xstrdup(map_name);
-    }
+}
 
 /**********************************************************************/
 /*
@@ -891,3 +891,4 @@
 
 /**********************************************************************/
 /* end of mapfile.c */
+// vim: ts=4
--- tetex-src-3.0/texk/web2c/pdftexdir/writefont.c.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/writefont.c	2008-01-06 17:13:15.000000000 +0100
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: writefont.c,v 1.3 2005/12/27 19:04:42 hahe Exp $
+$Id: writefont.c 217 2007-07-31 16:55:39Z oneiros $
 */
 
 #include "ptexlib.h"
@@ -137,9 +137,32 @@
         fd->font_dim[i].set = true;
 }
 
+static void fix_fontmetrics(fd_entry * fd)
+{
+    intparm *p = (intparm *) fd->font_dim;
+    if (!p[FONTBBOX1_CODE].set || !p[FONTBBOX2_CODE].set ||
+        !p[FONTBBOX3_CODE].set || !p[FONTBBOX4_CODE].set) {
+        pdftex_warn("font `%s' doesn't have a BoundingBox", fd->fm->ff_name);
+        return;
+    }
+    if (!p[ASCENT_CODE].set) {
+        p[ASCENT_CODE].val = p[FONTBBOX4_CODE].val;
+        p[ASCENT_CODE].set = true;
+    }
+    if (!p[DESCENT_CODE].set) {
+        p[DESCENT_CODE].val = p[FONTBBOX2_CODE].val;
+        p[DESCENT_CODE].set = true;
+    }
+    if (!p[CAPHEIGHT_CODE].set) {
+        p[CAPHEIGHT_CODE].val = p[FONTBBOX4_CODE].val;
+        p[CAPHEIGHT_CODE].set = true;
+    }
+}
+
 static void write_fontmetrics(fd_entry * fd)
 {
     int i;
+    fix_fontmetrics(fd);
     if (fd->font_dim[FONTBBOX1_CODE].set && fd->font_dim[FONTBBOX2_CODE].set
         && fd->font_dim[FONTBBOX3_CODE].set && fd->font_dim[FONTBBOX4_CODE].set)
         pdf_printf("/%s [%i %i %i %i]\n", font_key[FONTBBOX1_CODE].pdfname,
@@ -158,7 +181,7 @@
 {
     if (fo->fm->ps_name != NULL)
         fo->fd->fontname = xstrdup(fo->fm->ps_name);    /* just fallback */
-        else
+    else
         fo->fd->fontname = xstrdup(fo->fm->tfm_name);
 }
 
@@ -171,7 +194,7 @@
     if (fd->subset_tag != NULL)
         pdf_printf("%s+", fd->subset_tag);
     pdf_printf("%s\n", fd->fontname);
-    }
+}
 
 static void write_fontname_object(fd_entry * fd)
 {
@@ -397,7 +420,7 @@
     pdfbegindict(fd->ff_objnum, 0);     /* font file stream */
     if (is_type1(fd->fm))
         pdf_printf("/Length1 %i\n/Length2 %i\n/Length3 %i\n",
-                   (int)t1_length1, (int)t1_length2, (int)t1_length3);
+                   (int) t1_length1, (int) t1_length2, (int) t1_length3);
     else if (is_truetype(fd->fm))
         pdf_printf("/Length1 %i\n", (int) ttf_length);
     else if (is_opentype(fd->fm))
@@ -413,8 +436,29 @@
 
 static void write_fontdescriptor(fd_entry * fd)
 {
+    static const int std_flags[] = {
+        /* indices for << start with 0, but bits start with 1, so the numbers 
+         * for << are 1 lower than the bits in table 5.20 */
+        /* *INDENT-OFF* */
+        1 + 2 + (1 << 5),                       /* Courier */
+        1 + 2 + (1 << 5)            + (1 << 18),/* Courier-Bold */
+        1 + 2 + (1 << 5) + (1 << 6),            /* Courier-Oblique */
+        1 + 2 + (1 << 5) + (1 << 6) + (1 << 18),/* Courier-BoldOblique */
+                (1 << 5),                       /* Helvetica */
+                (1 << 5)            + (1 << 18),/* Helvetica-Bold */
+                (1 << 5) + (1 << 6),            /* Helvetica-Oblique */
+                (1 << 5) + (1 << 6) + (1 << 18),/* Helvetica-BoldOblique */
+              4,                                /* Symbol */
+            2 + (1 << 5),                       /* Times-Roman */
+            2 + (1 << 5)            + (1 << 18),/* Times-Bold */
+            2 + (1 << 5) + (1 << 6),            /* Times-Italic */
+            2 + (1 << 5) + (1 << 6) + (1 << 18),/* Times-BoldItalic */
+              4                                 /* ZapfDingbats */
+        /* *INDENT-ON* */
+    };
     char *glyph;
     struct avl_traverser t;
+    int fd_flags;
     assert(fd != NULL && fd->fm != NULL);
 
     if (is_fontfile(fd->fm))
@@ -426,10 +470,21 @@
     pdfbegindict(fd->fd_objnum, 1);
     pdf_puts("/Type /FontDescriptor\n");
     write_fontname(fd, "FontName");
-    if (!fd->ff_found && fd->fm->fd_flags == 4)
-        pdf_puts("/Flags 34\n"); /* assumes a roman sans serif font */
-    else
-        pdf_printf("/Flags %i\n", (int) fd->fm->fd_flags);
+    if (fd->fm->fd_flags != FD_FLAGS_NOT_SET_IN_MAPLINE)
+        fd_flags = (int) fd->fm->fd_flags;
+    else if (fd->ff_found)
+        fd_flags = FD_FLAGS_DEFAULT_EMBED;
+    else {
+        fd_flags = is_std_t1font(fd->fm)
+            ? std_flags[check_std_t1font(fd->fm->ps_name)]
+            : FD_FLAGS_DEFAULT_NON_EMBED;
+        pdftex_warn
+            ("No flags specified for non-embedded font `%s' (%s) (I'm using %i): "
+             "fix your map entry.",
+             fd->fm->ps_name != NULL ? fd->fm->ps_name : "No name given",
+             fd->fm->tfm_name, fd_flags);
+    }
+    pdf_printf("/Flags %i\n", fd_flags);
     write_fontmetrics(fd);
     if (fd->ff_found) {
         if (is_subsetted(fd->fm) && is_type1(fd->fm)) {
@@ -464,7 +519,7 @@
     for (fd = (fd_entry *) avl_t_first(&t, fd_tree); fd != NULL;
          fd = (fd_entry *) avl_t_next(&t))
         write_fontdescriptor(fd);
-    }
+}
 
 /**********************************************************************/
 
@@ -484,7 +539,7 @@
             fo->tounicode_objnum =
                 write_tounicode(fo->fd->builtin_glyph_names, fo->fm->tfm_name);
         }
-        }
+    }
 
     pdfbegindict(fo->fo_objnum, 1);
     pdf_puts("/Type /Font\n");
@@ -514,7 +569,7 @@
         pdf_puts("\n");
     }
     pdfenddict();
-    }
+}
 
 void write_fontdictionaries()
 {
@@ -526,7 +581,7 @@
     for (fo = (fo_entry *) avl_t_first(&t, fo_tree); fo != NULL;
          fo = (fo_entry *) avl_t_next(&t))
         write_fontdictionary(fo);
-    }
+}
 
 /**********************************************************************/
 /*
@@ -617,3 +672,4 @@
 }
 
 /**********************************************************************/
+// vim: ts=4
--- tetex-src-3.0/texk/web2c/pdftexdir/writejbig2.h.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/writejbig2.h	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /***********************************************************************
-Copyright (c) 2002-2006 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 2002-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -14,13 +14,13 @@
 for more details.
 
 You should have received a copy of the GNU General Public License along
-with pdfTeX; if not, write to the Free Software Foundation, Inc., 59
-Temple Place, Suite 330, Boston, MA 02111-1307 USA
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
 This is experimental JBIG2 image support to pdfTeX. JBIG2 image decoding
 is part of Adobe PDF-1.4, and requires Acroread 5.0 or later.
 
-$Id: writejbig2.h,v 1.40 2006/05/31 19:18:51 hahe Exp hahe $
+$Id: writejbig2.h 217 2007-07-31 16:55:39Z oneiros $
 ***********************************************************************/
 
 #include <stdlib.h>
--- tetex-src-3.0/texk/web2c/pdftexdir/writettf.h.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/writettf.h	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2006 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,24 +13,24 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: //depot/Build/source.development/TeX/texk/web2c/pdftexdir/writettf.h#1 $
+$Id: writettf.h 217 2007-07-31 16:55:39Z oneiros $
 */
 
-typedef signed char     TTF_CHAR;
-typedef unsigned char   TTF_BYTE;
-typedef signed short    TTF_SHORT;
-typedef unsigned short  TTF_USHORT;
-typedef signed long     TTF_LONG;
-typedef unsigned long   TTF_ULONG;
-typedef unsigned long   TTF_FIXED;
-typedef unsigned short  TTF_FUNIT;
-typedef signed short    TTF_FWORD;
-typedef unsigned short  TTF_UFWORD;
-typedef unsigned short  TTF_F2DOT14;
+typedef signed char TTF_CHAR;
+typedef unsigned char TTF_BYTE;
+typedef signed short TTF_SHORT;
+typedef unsigned short TTF_USHORT;
+typedef signed long TTF_LONG;
+typedef unsigned long TTF_ULONG;
+typedef unsigned long TTF_FIXED;
+typedef unsigned short TTF_FUNIT;
+typedef signed short TTF_FWORD;
+typedef unsigned short TTF_UFWORD;
+typedef unsigned short TTF_F2DOT14;
 
 #define TTF_CHAR_SIZE    1
 #define TTF_BYTE_SIZE    1
@@ -116,7 +116,7 @@
 typedef struct {
     TTF_USHORT platform_id;
     TTF_USHORT encoding_id;
-    TTF_ULONG  offset;
+    TTF_ULONG offset;
     TTF_USHORT format;
 } cmap_entry;
 
--- tetex-src-3.0/texk/web2c/pdftexdir/writejpg.c.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/writejpg.c	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2006 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,88 +13,88 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: //depot/Build/source.development/TeX/texk/web2c/pdftexdir/writejpg.c#10 $
+$Id: writejpg.c 217 2007-07-31 16:55:39Z oneiros $
 */
 
 #include "ptexlib.h"
 #include "image.h"
 
-#define JPG_GRAY  1     /* Gray color space, use /DeviceGray  */
-#define JPG_RGB   3     /* RGB color space, use /DeviceRGB    */
-#define JPG_CMYK  4     /* CMYK color space, use /DeviceCMYK  */
-
-typedef enum {          /* JPEG marker codes                    */
-  M_SOF0  = 0xc0,       /* baseline DCT                         */
-  M_SOF1  = 0xc1,       /* extended sequential DCT              */
-  M_SOF2  = 0xc2,       /* progressive DCT                      */
-  M_SOF3  = 0xc3,       /* lossless (sequential)                */
-
-  M_SOF5  = 0xc5,       /* differential sequential DCT          */
-  M_SOF6  = 0xc6,       /* differential progressive DCT         */
-  M_SOF7  = 0xc7,       /* differential lossless                */
-
-  M_JPG   = 0xc8,       /* JPEG extensions                      */
-  M_SOF9  = 0xc9,       /* extended sequential DCT              */
-  M_SOF10 = 0xca,       /* progressive DCT                      */
-  M_SOF11 = 0xcb,       /* lossless (sequential)                */
-
-  M_SOF13 = 0xcd,       /* differential sequential DCT          */
-  M_SOF14 = 0xce,       /* differential progressive DCT         */
-  M_SOF15 = 0xcf,       /* differential lossless                */
-
-  M_DHT   = 0xc4,       /* define Huffman tables                */
-
-  M_DAC   = 0xcc,       /* define arithmetic conditioning table */
-
-  M_RST0  = 0xd0,       /* restart                              */
-  M_RST1  = 0xd1,       /* restart                              */
-  M_RST2  = 0xd2,       /* restart                              */
-  M_RST3  = 0xd3,       /* restart                              */
-  M_RST4  = 0xd4,       /* restart                              */
-  M_RST5  = 0xd5,       /* restart                              */
-  M_RST6  = 0xd6,       /* restart                              */
-  M_RST7  = 0xd7,       /* restart                              */
-
-  M_SOI   = 0xd8,       /* start of image                       */
-  M_EOI   = 0xd9,       /* end of image                         */
-  M_SOS   = 0xda,       /* start of scan                        */
-  M_DQT   = 0xdb,       /* define quantization tables           */
-  M_DNL   = 0xdc,       /* define number of lines               */
-  M_DRI   = 0xdd,       /* define restart interval              */
-  M_DHP   = 0xde,       /* define hierarchical progression      */
-  M_EXP   = 0xdf,       /* expand reference image(s)            */
-
-  M_APP0  = 0xe0,       /* application marker, used for JFIF    */
-  M_APP1  = 0xe1,       /* application marker                   */
-  M_APP2  = 0xe2,       /* application marker                   */
-  M_APP3  = 0xe3,       /* application marker                   */
-  M_APP4  = 0xe4,       /* application marker                   */
-  M_APP5  = 0xe5,       /* application marker                   */
-  M_APP6  = 0xe6,       /* application marker                   */
-  M_APP7  = 0xe7,       /* application marker                   */
-  M_APP8  = 0xe8,       /* application marker                   */
-  M_APP9  = 0xe9,       /* application marker                   */
-  M_APP10 = 0xea,       /* application marker                   */
-  M_APP11 = 0xeb,       /* application marker                   */
-  M_APP12 = 0xec,       /* application marker                   */
-  M_APP13 = 0xed,       /* application marker                   */
-  M_APP14 = 0xee,       /* application marker, used by Adobe    */
-  M_APP15 = 0xef,       /* application marker                   */
-
-  M_JPG0  = 0xf0,       /* reserved for JPEG extensions         */
-  M_JPG13 = 0xfd,       /* reserved for JPEG extensions         */
-  M_COM   = 0xfe,       /* comment                              */
+#define JPG_GRAY  1             /* Gray color space, use /DeviceGray  */
+#define JPG_RGB   3             /* RGB color space, use /DeviceRGB    */
+#define JPG_CMYK  4             /* CMYK color space, use /DeviceCMYK  */
+
+typedef enum {                  /* JPEG marker codes                    */
+    M_SOF0 = 0xc0,              /* baseline DCT                         */
+    M_SOF1 = 0xc1,              /* extended sequential DCT              */
+    M_SOF2 = 0xc2,              /* progressive DCT                      */
+    M_SOF3 = 0xc3,              /* lossless (sequential)                */
+
+    M_SOF5 = 0xc5,              /* differential sequential DCT          */
+    M_SOF6 = 0xc6,              /* differential progressive DCT         */
+    M_SOF7 = 0xc7,              /* differential lossless                */
+
+    M_JPG = 0xc8,               /* JPEG extensions                      */
+    M_SOF9 = 0xc9,              /* extended sequential DCT              */
+    M_SOF10 = 0xca,             /* progressive DCT                      */
+    M_SOF11 = 0xcb,             /* lossless (sequential)                */
+
+    M_SOF13 = 0xcd,             /* differential sequential DCT          */
+    M_SOF14 = 0xce,             /* differential progressive DCT         */
+    M_SOF15 = 0xcf,             /* differential lossless                */
+
+    M_DHT = 0xc4,               /* define Huffman tables                */
+
+    M_DAC = 0xcc,               /* define arithmetic conditioning table */
+
+    M_RST0 = 0xd0,              /* restart                              */
+    M_RST1 = 0xd1,              /* restart                              */
+    M_RST2 = 0xd2,              /* restart                              */
+    M_RST3 = 0xd3,              /* restart                              */
+    M_RST4 = 0xd4,              /* restart                              */
+    M_RST5 = 0xd5,              /* restart                              */
+    M_RST6 = 0xd6,              /* restart                              */
+    M_RST7 = 0xd7,              /* restart                              */
+
+    M_SOI = 0xd8,               /* start of image                       */
+    M_EOI = 0xd9,               /* end of image                         */
+    M_SOS = 0xda,               /* start of scan                        */
+    M_DQT = 0xdb,               /* define quantization tables           */
+    M_DNL = 0xdc,               /* define number of lines               */
+    M_DRI = 0xdd,               /* define restart interval              */
+    M_DHP = 0xde,               /* define hierarchical progression      */
+    M_EXP = 0xdf,               /* expand reference image(s)            */
+
+    M_APP0 = 0xe0,              /* application marker, used for JFIF    */
+    M_APP1 = 0xe1,              /* application marker                   */
+    M_APP2 = 0xe2,              /* application marker                   */
+    M_APP3 = 0xe3,              /* application marker                   */
+    M_APP4 = 0xe4,              /* application marker                   */
+    M_APP5 = 0xe5,              /* application marker                   */
+    M_APP6 = 0xe6,              /* application marker                   */
+    M_APP7 = 0xe7,              /* application marker                   */
+    M_APP8 = 0xe8,              /* application marker                   */
+    M_APP9 = 0xe9,              /* application marker                   */
+    M_APP10 = 0xea,             /* application marker                   */
+    M_APP11 = 0xeb,             /* application marker                   */
+    M_APP12 = 0xec,             /* application marker                   */
+    M_APP13 = 0xed,             /* application marker                   */
+    M_APP14 = 0xee,             /* application marker, used by Adobe    */
+    M_APP15 = 0xef,             /* application marker                   */
+
+    M_JPG0 = 0xf0,              /* reserved for JPEG extensions         */
+    M_JPG13 = 0xfd,             /* reserved for JPEG extensions         */
+    M_COM = 0xfe,               /* comment                              */
 
-  M_TEM   = 0x01,       /* temporary use                        */
+    M_TEM = 0x01,               /* temporary use                        */
 
-  M_ERROR = 0x100       /* dummy marker, internal use only      */
+    M_ERROR = 0x100             /* dummy marker, internal use only      */
 } JPEG_MARKER;
 
-static JPG_UINT16 read2bytes(FILE *f)
+static JPG_UINT16 read2bytes(FILE * f)
 {
     int c = xgetc(f);
     return (c << 8) + xgetc(f);
@@ -104,45 +104,45 @@
 {
     int i, units = 0;
     unsigned char jpg_id[] = "JFIF";
-    img_xres(img)=img_yres(img)=0;
+    img_xres(img) = img_yres(img) = 0;
     jpg_ptr(img)->file = xfopen(img_name(img), FOPEN_RBIN_MODE);
-    xfseek(jpg_ptr(img)->file,0,SEEK_END,cur_file_name);
-    jpg_ptr(img)->length=xftell(jpg_ptr(img)->file,cur_file_name);
-    xfseek(jpg_ptr(img)->file,0,SEEK_SET,cur_file_name);
-    if(read2bytes(jpg_ptr(img)->file)!=0xFFD8)
+    xfseek(jpg_ptr(img)->file, 0, SEEK_END, cur_file_name);
+    jpg_ptr(img)->length = xftell(jpg_ptr(img)->file, cur_file_name);
+    xfseek(jpg_ptr(img)->file, 0, SEEK_SET, cur_file_name);
+    if (read2bytes(jpg_ptr(img)->file) != 0xFFD8)
         pdftex_fail("reading JPEG image failed (no JPEG header found)");
     /* currently only true JFIF files allow extracting img_xres and img_yres */
     if (read2bytes(jpg_ptr(img)->file) == 0xFFE0) {     /* check for JFIF */
-      (void)read2bytes(jpg_ptr(img)->file);
+        (void) read2bytes(jpg_ptr(img)->file);
         for (i = 0; i < 5; i++) {
             if (xgetc(jpg_ptr(img)->file) != jpg_id[i])
                 break;
         }
         if (i == 5) {           /* it's JFIF */
             read2bytes(jpg_ptr(img)->file);
-      units=xgetc(jpg_ptr(img)->file);
-      img_xres(img)=read2bytes(jpg_ptr(img)->file);
-      img_yres(img)=read2bytes(jpg_ptr(img)->file);
-      switch(units) {
+            units = xgetc(jpg_ptr(img)->file);
+            img_xres(img) = read2bytes(jpg_ptr(img)->file);
+            img_yres(img) = read2bytes(jpg_ptr(img)->file);
+            switch (units) {
             case 1:
                 break;          /* pixels per inch */
             case 2:
                 img_xres(img) *= 2.54;
                 img_yres(img) *= 2.54;
-                  break; /* pixels per cm */
+                break;          /* pixels per cm */
             default:
                 img_xres(img) = img_yres(img) = 0;
                 break;
             }
-      }
+        }
     }
-    xfseek(jpg_ptr(img)->file,0,SEEK_SET,cur_file_name);
-    while(1) {
+    xfseek(jpg_ptr(img)->file, 0, SEEK_SET, cur_file_name);
+    while (1) {
         if (feof(jpg_ptr(img)->file))
             pdftex_fail("reading JPEG image failed (premature file end)");
         if (fgetc(jpg_ptr(img)->file) != 0xFF)
             pdftex_fail("reading JPEG image failed (no marker found)");
-        switch(xgetc(jpg_ptr(img)->file)) {
+        switch (xgetc(jpg_ptr(img)->file)) {
         case M_SOF5:
         case M_SOF6:
         case M_SOF7:
@@ -154,33 +154,33 @@
         case M_SOF15:
             pdftex_fail("unsupported type of compression");
         case M_SOF2:
-         if (fixedpdfminorversion <= 2)
-                 pdftex_fail("cannot use progressive DCT with PDF-1.2");
+            if (fixedpdfminorversion <= 2)
+                pdftex_fail("cannot use progressive DCT with PDF-1.2");
         case M_SOF0:
         case M_SOF1:
         case M_SOF3:
-             (void)read2bytes(jpg_ptr(img)->file);    /* read segment length  */
-             jpg_ptr(img)->bits_per_component = xgetc(jpg_ptr(img)->file);
-             img_height(img)       = read2bytes(jpg_ptr(img)->file);
-             img_width(img)        = read2bytes(jpg_ptr(img)->file);
-             jpg_ptr(img)->color_space  = xgetc(jpg_ptr(img)->file);
-             xfseek(jpg_ptr(img)->file,0,SEEK_SET,cur_file_name); 
-             switch (jpg_ptr(img)->color_space) {
-                 case JPG_GRAY:
-                     img_color(img) = IMAGE_COLOR_B;
-                     break;
-                 case JPG_RGB:
-                     img_color(img) = IMAGE_COLOR_C;
-                     break;
-                 case JPG_CMYK:
-                     img_color(img) = IMAGE_COLOR_C;
-                     break;
-                 default:
-                     pdftex_fail("Unsupported color space %i", 
-                             (int)jpg_ptr(img)->color_space);
-             }
-             return;
-        case M_SOI:             /* ignore markers without parameters */
+            (void) read2bytes(jpg_ptr(img)->file);      /* read segment length  */
+            jpg_ptr(img)->bits_per_component = xgetc(jpg_ptr(img)->file);
+            img_height(img) = read2bytes(jpg_ptr(img)->file);
+            img_width(img) = read2bytes(jpg_ptr(img)->file);
+            jpg_ptr(img)->color_space = xgetc(jpg_ptr(img)->file);
+            xfseek(jpg_ptr(img)->file, 0, SEEK_SET, cur_file_name);
+            switch (jpg_ptr(img)->color_space) {
+            case JPG_GRAY:
+                img_color(img) = IMAGE_COLOR_B;
+                break;
+            case JPG_RGB:
+                img_color(img) = IMAGE_COLOR_C;
+                break;
+            case JPG_CMYK:
+                img_color(img) = IMAGE_COLOR_C;
+                break;
+            default:
+                pdftex_fail("Unsupported color space %i",
+                            (int) jpg_ptr(img)->color_space);
+            }
+            return;
+        case M_SOI:            /* ignore markers without parameters */
         case M_EOI:
         case M_TEM:
         case M_RST0:
@@ -192,7 +192,7 @@
         case M_RST6:
         case M_RST7:
             break;
-        default:                        /* skip variable length markers */
+        default:               /* skip variable length markers */
             xfseek(jpg_ptr(img)->file, read2bytes(jpg_ptr(img)->file) - 2,
                    SEEK_CUR, cur_file_name);
             break;
@@ -208,11 +208,11 @@
     pdf_printf("/Width %i\n/Height %i\n/BitsPerComponent %i\n/Length %i\n",
                (int) img_width(img),
                (int) img_height(img),
-               (int)jpg_ptr(img)->bits_per_component,
-               (int)jpg_ptr(img)->length);
+               (int) jpg_ptr(img)->bits_per_component,
+               (int) jpg_ptr(img)->length);
     pdf_puts("/ColorSpace ");
     if (img_colorspace_ref(img) != 0) {
-        pdf_printf("%i 0 R\n", (int)img_colorspace_ref(img));
+        pdf_printf("%i 0 R\n", (int) img_colorspace_ref(img));
     } else {
         switch (jpg_ptr(img)->color_space) {
         case JPG_GRAY:
@@ -225,8 +225,8 @@
             pdf_puts("/DeviceCMYK\n/Decode [1 0 1 0 1 0 1 0]\n");
             break;
         default:
-            pdftex_fail("Unsupported color space %i", 
-                 (int)jpg_ptr(img)->color_space);
+            pdftex_fail("Unsupported color space %i",
+                        (int) jpg_ptr(img)->color_space);
         }
     }
     pdf_puts("/Filter /DCTDecode\n>>\nstream\n");
--- tetex-src-3.0/texk/web2c/pdftexdir/pdftoepdf.cc.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/pdftoepdf.cc	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright 1996-2006 Han The Thanh, <thanh@pdftex.org>
+Copyright 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: pdftoepdf.cc,v 1.9 2006/09/01 18:06:52 hahe Exp hahe $
+$Id: pdftoepdf.cc 217 2007-07-31 16:55:39Z oneiros $
 */
 
 #include <stdlib.h>
@@ -75,7 +75,7 @@
 // It is no longer necessary to call Object::free explicitely.
 
 class PdfObject {
-public:
+  public:
     PdfObject() {               // nothing
     } ~PdfObject() {
         iObject.free();
@@ -86,11 +86,11 @@
     Object *operator&() {
         return &iObject;
     }
-private: // no copying or assigning
-  PdfObject(const PdfObject &);
-  void operator=(const PdfObject &);
-public:
-  Object iObject;
+  private:                     // no copying or assigning
+    PdfObject(const PdfObject &);
+    void operator=(const PdfObject &);
+  public:
+    Object iObject;
 };
 
 // When copying the Resources of the selected page, all objects are copied
@@ -106,13 +106,13 @@
 };
 
 struct InObj {
-    Ref ref;            // ref in original PDF
-    InObjType type;     // object type
-    InObj *next;        // next entry in list of indirect objects
-    integer num;        // new object number in output PDF
+    Ref ref;                    // ref in original PDF
+    InObjType type;             // object type
+    InObj *next;                // next entry in list of indirect objects
+    integer num;                // new object number in output PDF
     fd_entry *fd;               // pointer to /FontDescriptor object structure
-    integer enc_objnum;   // Encoding for objFont      
-    int written;        // has it been written to output PDF?
+    integer enc_objnum;         // Encoding for objFont
+    int written;                // has it been written to output PDF?
 };
 
 struct UsedEncoding {
@@ -134,8 +134,8 @@
     PDFDoc *doc;
     XRef *xref;
     InObj *inObjList;
-    int occurences;     // number of references to the document; the doc can be
-                        // deleted when this is negative
+    int occurences;             // number of references to the document; the doc can be
+    // deleted when this is negative
     PdfDocument *next;
 };
 
@@ -170,10 +170,10 @@
             p->occurences);
 #endif
     GString *docName = new GString(p->file_name);
-    p->doc = new PDFDoc(docName);  // takes ownership of docName
+    p->doc = new PDFDoc(docName);       // takes ownership of docName
     if (!p->doc->isOk() || !p->doc->okToPrint()) {
         pdftex_fail("xpdf: reading PDF image failed");
-        }
+    }
     p->inObjList = 0;
     p->next = pdfDocuments;
     pdfDocuments = p;
@@ -182,14 +182,14 @@
 
 // Deallocate a PdfDocument with all its resources
 
-static void delete_document(PdfDocument *pdf_doc)
+static void delete_document(PdfDocument * pdf_doc)
 {
     PdfDocument **p = &pdfDocuments;
     while (*p && *p != pdf_doc)
-      p = &((*p)->next);
+        p = &((*p)->next);
     // should not happen:
-    if (!*p) 
-      return;
+    if (!*p)
+        return;
     // unlink from list
     *p = pdf_doc->next;
     // free pdf_doc's resources
@@ -204,21 +204,21 @@
     delete pdf_doc;
 }
 
-// Replacement for 
+// Replacement for
 //      Object *initDict(Dict *dict1){ initObj(objDict); dict = dict1; return this; }
 
-static void initDictFromDict (PdfObject &obj, Dict *dict)
+static void initDictFromDict(PdfObject & obj, Dict * dict)
 {
     obj->initDict(xref);
     for (int i = 0, l = dict->getLength(); i < l; i++) {
         Object obj1;
         obj->dictAdd(copyString(dict->getKey(i)), dict->getValNF(i, &obj1));
-        }
-}    
+    }
+}
 
 // --------------------------------------------------------------------
 
-static int addEncoding(GfxFont *gfont)
+static int addEncoding(GfxFont * gfont)
 {
     UsedEncoding *n;
     n = new UsedEncoding;
@@ -270,7 +270,7 @@
     if (type == objFontDesc)
         n->num = get_fd_objnum(fd);
     else
-    n->num = pdfnewobjnum();
+        n->num = pdfnewobjnum();
     return n->num;
 }
 
@@ -281,14 +281,14 @@
     pdf_puts("/");
     for (; *s != 0; s++) {
         if (isdigit(*s) || isupper(*s) || islower(*s) || *s == '_' ||
-        *s == '.' || *s == '-' )
+            *s == '.' || *s == '-' || *s == '+')
             pdfout(*s);
         else
             pdf_printf("#%.2X", *s & 0xFF);
     }
 }
 
-static void copyDictEntry(Object *obj, int i)
+static void copyDictEntry(Object * obj, int i)
 {
     PdfObject obj1;
     copyName(obj->dictGetKey(i));
@@ -298,7 +298,7 @@
     pdf_puts("\n");
 }
 
-static void copyDict(Object *obj)
+static void copyDict(Object * obj)
 {
     int i, l;
     if (!obj->isDict())
@@ -308,7 +308,7 @@
         copyDictEntry(obj, i);
 }
 
-static void copyFontDict(Object *obj, InObj *r)
+static void copyFontDict(Object * obj, InObj * r)
 {
     int i, l;
     char *key;
@@ -317,14 +317,14 @@
                     obj->getTypeName());
     pdf_puts("<<\n");
     assert(r->type == objFont); // FontDescriptor is in fd_tree
-        for (i = 0, l = obj->dictGetLength(); i < l; ++i) {
-            key = obj->dictGetKey(i);
+    for (i = 0, l = obj->dictGetLength(); i < l; ++i) {
+        key = obj->dictGetKey(i);
         if (strncmp("FontDescriptor", key, strlen("FontDescriptor")) == 0
             || strncmp("BaseFont", key, strlen("BaseFont")) == 0
             || strncmp("Encoding", key, strlen("Encoding")) == 0)
-                continue; // skip original values
-            copyDictEntry(obj, i);
-        }
+            continue;           // skip original values
+        copyDictEntry(obj, i);
+    }
     // write new FontDescriptor, BaseFont, and Encoding
     pdf_printf("/FontDescriptor %d 0 R\n", (int) get_fd_objnum(r->fd));
     pdf_printf("/BaseFont %d 0 R\n", (int) get_fn_objnum(r->fd));
@@ -332,7 +332,7 @@
     pdf_puts(">>");
 }
 
-static void copyStream(Stream *str)
+static void copyStream(Stream * str)
 {
     int c;
     str->reset();
@@ -341,7 +341,7 @@
     pdflastbyte = pdfbuf[pdfptr - 1];
 }
 
-static void copyProcSet(Object *obj)
+static void copyProcSet(Object * obj)
 {
     int i, l;
     PdfObject procset;
@@ -362,7 +362,7 @@
 
 #define REPLACE_TYPE1C true
 
-static void copyFont(char *tag, Object *fontRef)
+static void copyFont(char *tag, Object * fontRef)
 {
     PdfObject fontdict, subtype, basefont, fontdescRef, fontdesc, charset,
         fontfile, ffsubtype;
@@ -381,7 +381,7 @@
     }
     // Only handle included Type1 (and Type1C) fonts; anything else will be copied.
     // Type1C fonts are replaced by Type1 fonts, if REPLACE_TYPE1C is true.
-    if (fontRef->fetch(xref, &fontdict)->isDict()
+    if (!fixedinclusioncopyfont && fontRef->fetch(xref, &fontdict)->isDict()
         && fontdict->dictLookup("Subtype", &subtype)->isName()
         && !strcmp(subtype->getName(), "Type1")
         && fontdict->dictLookup("BaseFont", &basefont)->isName()
@@ -395,25 +395,25 @@
                 && !strcmp(ffsubtype->getName(), "Type1C")))
         && (fontmap = lookup_fontmap(basefont->getName())) != NULL) {
         fd = epdf_create_fontdescriptor(fontmap);
-                if (fontdesc->dictLookup("CharSet", &charset) && 
-                    charset->isString() && is_subsetable(fontmap))
+        if (fontdesc->dictLookup("CharSet", &charset) &&
+            charset->isString() && is_subsetable(fontmap))
             epdf_mark_glyphs(fd, charset->getString()->getCString());
-                else
+        else
             embed_whole_font(fd);
         addFontDesc(fontdescRef->getRef(), fd);
-                copyName(tag);
-                gfont = GfxFont::makeFont(xref, tag, fontRef->getRef(), 
-                                          fontdict->getDict());
+        copyName(tag);
+        gfont = GfxFont::makeFont(xref, tag, fontRef->getRef(),
+                                  fontdict->getDict());
         pdf_printf(" %d 0 R ", addFont(fontRef->getRef(), fd,
-                                               addEncoding(gfont)));
+                                       addEncoding(gfont)));
     } else {
-    copyName(tag);
-    pdf_puts(" ");
-    copyObject(fontRef);
-}
+        copyName(tag);
+        pdf_puts(" ");
+        copyObject(fontRef);
+    }
 }
 
-static void copyFontResources(Object *obj)
+static void copyFontResources(Object * obj)
 {
     PdfObject fontRef;
     int i, l;
@@ -432,7 +432,7 @@
     pdf_puts(">>\n");
 }
 
-static void copyOtherResources(Object *obj, char *key)
+static void copyOtherResources(Object * obj, char *key)
 {
     // copies all other resources (write_epdf handles Fonts and ProcSets),
     // but gives a warning if an object is not a dictionary.
@@ -440,7 +440,7 @@
     if (!obj->isDict())
         //FIXME: Write the message only to the log file
         pdftex_warn("PDF inclusion: invalid other resource which is no dict"
-                    " (key '%s', type <%s>); copying it anyway.", 
+                    " (key '%s', type <%s>); copying it anyway.",
                     key, obj->getTypeName());
     copyName(key);
     pdf_puts(" ");
@@ -469,21 +469,21 @@
     } else {
         char ints[64];
         int bindex = 0, sindex = 0;
-        int ival, fval; 
+        int ival, fval;
         // handle the sign part if n is negative
         if (n < 0) {
             buf[bindex++] = '-';
-            n = -n;    
+            n = -n;
         }
-        n += epsilon; // for rounding
+        n += epsilon;           // for rounding
         // handle the integer part, simply with sprintf
-        ival = (int)floor(n);
+        ival = (int) floor(n);
         n -= ival;
         sprintf(ints, "%d", ival);
         while (ints[sindex] != 0)
             buf[bindex++] = ints[sindex++];
         // handle the fractional part up to 'precision' digits
-        fval = (int)floor(n*fact);
+        fval = (int) floor(n * fact);
         if (fval) {
             // set a dot
             buf[bindex++] = '.';
@@ -502,18 +502,18 @@
         } else
             buf[bindex++] = 0;
     }
-    return (char *)buf;
+    return (char *) buf;
 }
 
-static void copyObject(Object *obj)
+static void copyObject(Object * obj)
 {
     PdfObject obj1;
-    int  i, l, c;
+    int i, l, c;
     Ref ref;
     char *p;
     GString *s;
     if (obj->isBool()) {
-        pdf_printf("%s", obj->getBool() ? "true" : "false");
+        pdf_printf("%s", obj->getBool()? "true" : "false");
     } else if (obj->isInt()) {
         pdf_printf("%i", obj->getInt());
     } else if (obj->isReal()) {
@@ -524,10 +524,10 @@
         s = obj->getString();
         p = s->getCString();
         l = s->getLength();
-        if (strlen(p) == (unsigned int)l) {
+        if (strlen(p) == (unsigned int) l) {
             pdf_puts("(");
             for (; *p != 0; p++) {
-                c = (unsigned char)*p;
+                c = (unsigned char) *p;
                 if (c == '(' || c == ')' || c == '\\')
                     pdf_printf("\\%c", c);
                 else if (c < 0x20 || c > 0x7F)
@@ -562,7 +562,7 @@
         copyDict(obj);
         pdf_puts(">>");
     } else if (obj->isStream()) {
-        initDictFromDict (obj1, obj->streamGetDict());
+        initDictFromDict(obj1, obj->streamGetDict());
         obj->streamGetDict()->incRef();
         pdf_puts("<<\n");
         copyDict(&obj1);
@@ -575,9 +575,9 @@
     } else if (obj->isRef()) {
         ref = obj->getRef();
         if (ref.num == 0) {
-            pdftex_warn
-                ("PDF inclusion: reference to invalid object was replaced by <null>");
-            pdf_puts("null");
+            pdftex_fail
+                ("PDF inclusion: reference to invalid object"
+                 " (is the included pdf broken?)");
         } else
             pdf_printf("%d 0 R", addOther(ref));
     } else {
@@ -592,25 +592,25 @@
     for (r = inObjList; r != 0; r = r->next) {
         if (!r->written) {
             Object obj1;
-        r->written = 1;
-        xref->fetch(r->ref.num, r->ref.gen, &obj1);
+            r->written = 1;
+            xref->fetch(r->ref.num, r->ref.gen, &obj1);
             if (r->type == objFont) {
                 assert(!obj1.isStream());
                 zpdfbeginobj(r->num, 2);        // \pdfobjcompresslevel = 2 is for this
-            copyFontDict(&obj1, r);
+                copyFontDict(&obj1, r);
                 pdf_puts("\n");
                 pdfendobj();
             } else if (r->type != objFontDesc) {        // /FontDescriptor is written via write_fontdescriptor()
                 if (obj1.isStream())
                     zpdfbeginobj(r->num, 0);
-        else
+                else
                     zpdfbeginobj(r->num, 2);    // \pdfobjcompresslevel = 2 is for this
                 copyObject(&obj1);
-        pdf_puts("\n");
-        pdfendobj();
+                pdf_puts("\n");
+                pdfendobj();
             }
-        obj1.free();
-    }
+            obj1.free();
+        }
     }
 }
 
@@ -621,15 +621,16 @@
     int i;
     for (r = encodingList; r != 0; r = r->next) {
         for (i = 0; i < 256; i++) {
-      if (r->font->isCIDFont()) {
-                pdftex_warn
-                    ("PDF inclusion: CID font included, encoding maybe wrong");
-      }
-      if ((s = ((Gfx8BitFont *)r->font)->getCharName(i)) != 0)
-        glyphNames[i] = s;
-      else
-        glyphNames[i] = notdef;
-      }
+            if (r->font->isCIDFont()) {
+                pdftex_fail
+                    ("PDF inclusion: CID fonts are not supported"
+                     " (try to disable font replacement to fix this)");
+            }
+            if ((s = ((Gfx8BitFont *) r->font)->getCharName(i)) != 0)
+                glyphNames[i] = s;
+            else
+                glyphNames[i] = notdef;
+        }
         epdf_write_enc(glyphNames, r->enc_objnum);
     }
     for (r = encodingList; r != 0; r = n) {
@@ -665,7 +666,7 @@
 // It makes no sense to give page_name _and_ page_num.
 // Returns the page number.
 
-integer 
+integer
 read_pdf_info(char *image_name, char *page_name, integer page_num,
               integer pagebox_spec, integer minor_pdf_version_wanted,
               integer pdf_inclusion_errorlevel)
@@ -711,7 +712,7 @@
         page_num = pdf_doc->doc->getCatalog()->findPage(ref.num, ref.gen);
         if (page_num == 0)
             pdftex_fail("PDF inclusion: destination is not a page <%s>",
-                page_name);
+                        page_name);
         delete link;
     } else {
         // get page by number
@@ -725,27 +726,27 @@
     // get the pagebox (media, crop...) to use.
     pagebox = get_pagebox(page, pagebox_spec);
     if (pagebox->x2 > pagebox->x1) {
-    epdf_orig_x = pagebox->x1;
+        epdf_orig_x = pagebox->x1;
         epdf_width = pagebox->x2 - pagebox->x1;
     } else {
         epdf_orig_x = pagebox->x2;
         epdf_width = pagebox->x1 - pagebox->x2;
     }
     if (pagebox->y2 > pagebox->y1) {
-    epdf_orig_y = pagebox->y1;
+        epdf_orig_y = pagebox->y1;
         epdf_height = pagebox->y2 - pagebox->y1;
     } else {
         epdf_orig_y = pagebox->y2;
         epdf_height = pagebox->y1 - pagebox->y2;
     }
-    
+
     rotate = page->getRotate();
     // handle page rotation and adjust dimens as needed
     if (rotate != 0) {
         if (rotate % 90 == 0) {
             // handle only the simple case: multiple of 90s.
             // these are the only values allowed according to the
-            // reference (v1.3, p.78).
+            // reference (v1.3, p. 78).
             // 180 needs no special treatment here
             register float f;
             switch (rotate) {
@@ -759,9 +760,9 @@
                 epdf_height = epdf_width;
                 epdf_width = f;
                 break;
-                }
             }
         }
+    }
     pdf_doc->xref = pdf_doc->doc->getXRef();
     return page_num;
 }
@@ -780,7 +781,7 @@
     char s[256];
     int i, l;
     int rotate;
-    double scale[6] = {0, 0, 0, 0, 0, 0};
+    double scale[6] = { 0, 0, 0, 0, 0, 0 };
     bool writematrix = false;
     PdfDocument *pdf_doc = (PdfDocument *) epdf_doc;
     (pdf_doc->occurences)--;
@@ -800,7 +801,7 @@
     pdf_puts("/FormType 1\n");
 
     // write additional information
-    pdf_printf("/%s.FileName (%s)\n", pdfkeyprefix, 
+    pdf_printf("/%s.FileName (%s)\n", pdfkeyprefix,
                convertStringToPDFString(pdf_doc->file_name,
                                         strlen(pdf_doc->file_name)));
     pdf_printf("/%s.PageNumber %i\n", pdfkeyprefix, (int) epdf_selected_page);
@@ -808,8 +809,8 @@
     if (info.isRef()) {
         // the info dict must be indirect (PDF Ref p. 61)
         pdf_printf("/%s.InfoDict ", pdfkeyprefix);
-        pdf_printf("%d 0 R \n", addOther(info.getRef()));
-        }
+        pdf_printf("%d 0 R\n", addOther(info.getRef()));
+    }
     // get the pagebox (media, crop...) to use.
     pagebox = get_pagebox(page, epdf_page_box);
 
@@ -818,11 +819,11 @@
         if (rotate % 90 == 0) {
             // this handles only the simple case: multiple of 90s but these
             // are the only values allowed according to the reference
-            // (v1.3, p.78).
+            // (v1.3, p. 78).
             // the image is rotated around its center.
             // the /Rotate key is clockwise while the matrix is
             // counterclockwise :-%
-            tex_printf (", page is rotated %d degrees", rotate);
+            tex_printf(", page is rotated %d degrees", rotate);
             switch (rotate) {
             case 90:
                 scale[1] = -1;
@@ -844,36 +845,36 @@
                 scale[5] = pagebox->y1 - pagebox->x1;
                 writematrix = true;
                 break;
-                }
-            if (writematrix) { // The matrix is only written if the image is rotated.
+            }
+            if (writematrix) {  // The matrix is only written if the image is rotated.
                 sprintf(s, "/Matrix [%.8f %.8f %.8f %.8f %.8f %.8f]\n",
-                    scale[0],
+                        scale[0],
                         scale[1], scale[2], scale[3], scale[4], scale[5]);
-                pdf_printf(stripzeros(s));
-                }
+                pdf_puts(stripzeros(s));
             }
         }
+    }
 
     sprintf(s, "/BBox [%.8f %.8f %.8f %.8f]\n",
             pagebox->x1, pagebox->y1, pagebox->x2, pagebox->y2);
-    pdf_printf(stripzeros(s));
+    pdf_puts(stripzeros(s));
 
     // write the page Group if it's there
     if (page->getGroup() != NULL) {
 #if PDFTEX_COPY_PAGEGROUP
-#   if PDFTEX_COPY_PAGEGROUP_NOFAIL
+#  if PDFTEX_COPY_PAGEGROUP_NOFAIL
         // FIXME: This will most likely produce incorrect PDFs :-(
         initDictFromDict(group, page->getGroup());
         if (group->dictGetLength() > 0) {
             pdf_puts("/Group ");
-            copyObject (&group);
+            copyObject(&group);
             pdf_puts("\n");
         }
-#   else
+#  else
         // FIXME: currently we don't know how to handle Page Groups so we abort gracefully :-(
         pdftex_fail
             ("PDF inclusion: Page Group detected which pdfTeX can't handle. Sorry.");
-#   endif
+#  endif
 #else
         // FIXME: currently we don't know how to handle Page Groups so we at least give a warning :-(
         pdftex_warn
@@ -884,24 +885,24 @@
     if (page->getMetadata() != NULL) {
         metadata->initStream(page->getMetadata());
         pdf_puts("/Metadata ");
-        copyObject (&metadata);
+        copyObject(&metadata);
         pdf_puts("\n");
     }
     // write the page PieceInfo if it's there
     if (page->getPieceInfo() != NULL) {
-        initDictFromDict (pieceinfo, page->getPieceInfo());
+        initDictFromDict(pieceinfo, page->getPieceInfo());
         if (pieceinfo->dictGetLength() > 0) {
             pdf_puts("/PieceInfo ");
-            copyObject (&pieceinfo);
+            copyObject(&pieceinfo);
             pdf_puts("\n");
         }
     }
     // write the page SeparationInfo if it's there
     if (page->getSeparationInfo() != NULL) {
-        initDictFromDict (separationInfo, page->getSeparationInfo());
+        initDictFromDict(separationInfo, page->getSeparationInfo());
         if (separationInfo->dictGetLength() > 0) {
             pdf_puts("/SeparationInfo ");
-            copyObject (&separationInfo);
+            copyObject(&separationInfo);
             pdf_puts("\n");
         }
     }
@@ -909,14 +910,14 @@
     if (page->getResourceDict() == NULL) {
         // Resources can be missing (files without them have been spotted
         // in the wild). This violates the PDF Ref., which claims they are
-        // required, but all RIPs accept them.  
+        // required, but all RIPs accept them.
         // We "replace" them with empty /Resources, although in form xobjects
         // /Resources are not required.
         pdftex_warn
             ("PDF inclusion: no /Resources detected. Replacing with empty /Resources.");
         pdf_puts("/Resources <<>>\n");
     } else {
-        initDictFromDict (obj1, page->getResourceDict());
+        initDictFromDict(obj1, page->getResourceDict());
         page->getResourceDict()->incRef();
         if (!obj1->isDict())
             pdftex_fail("PDF inclusion: invalid resources dict type <%s>",
@@ -931,13 +932,13 @@
                 copyProcSet(&obj2);
             else
                 copyOtherResources(&obj2, key);
-            }
+        }
         pdf_puts(">>\n");
     }
     // write the page contents
     page->getContents(&contents);
     if (contents->isStream()) {
-        initDictFromDict (obj1, contents->streamGetDict());
+        initDictFromDict(obj1, contents->streamGetDict());
         contents->streamGetDict()->incRef();
         copyDict(&obj1);
         pdf_puts(">>\nstream\n");
@@ -946,9 +947,9 @@
     } else if (contents->isArray()) {
         pdfbeginstream();
         for (i = 0, l = contents->arrayGetLength(); i < l; ++i) {
-        Object contentsobj;
+            Object contentsobj;
             copyStream((contents->arrayGet(i, &contentsobj))->getStream());
-        contentsobj.free();
+            contentsobj.free();
         }
         pdfendstream();
     } else {                    // the contents are optional, but we need to include an empty stream
@@ -986,11 +987,11 @@
 {
     if (isInit) {
         PdfDocument *p, *n;
-    for (p = pdfDocuments; p; p = n) {
-        n = p->next;
-        delete_document(p);
-    }
-    // see above for globalParams
-    delete globalParams;
+        for (p = pdfDocuments; p; p = n) {
+            n = p->next;
+            delete_document(p);
+        }
+        // see above for globalParams
+        delete globalParams;
     }
 }
--- tetex-src-3.0/texk/web2c/pdftexdir/writezip.c.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/writezip.c	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2002 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: writezip.c,v 1.2 2006/01/14 20:35:43 hahe Exp $
+$Id: writezip.c 217 2007-07-31 16:55:39Z oneiros $
 */
 
 #include "ptexlib.h"
@@ -26,33 +26,49 @@
 
 #define ZIP_BUF_SIZE  32768
 
-#define check_err(f, fn)                                   \
-    if (f != Z_OK)                                         \
-        pdftex_fail("zlib: %s() failed", fn)
+#define check_err(f, fn) \
+    if (f != Z_OK)       \
+        pdftex_fail("zlib: %s() failed (error code %d)", fn, f)
 
-static char zipbuf[ZIP_BUF_SIZE];
-static z_stream c_stream; /* compression stream */
+static char *zipbuf = NULL;
+static z_stream c_stream;       /* compression stream */
 
 void writezip(boolean finish)
 {
     int err;
-    assert(getpdfcompresslevel() > 0);
+    static int level_old = 0;
+    int level = getpdfcompresslevel();
+    assert(level > 0);
     cur_file_name = NULL;
     if (pdfstreamlength == 0) {
-        c_stream.zalloc = (alloc_func)0;
-        c_stream.zfree = (free_func)0;
-        c_stream.opaque = (voidpf)0;
-        check_err(deflateInit(&c_stream, getpdfcompresslevel()), "deflateInit");
-        c_stream.next_out = (Bytef*)zipbuf;
+        if (zipbuf == NULL) {
+            zipbuf = xtalloc(ZIP_BUF_SIZE, char);
+            c_stream.zalloc = (alloc_func) 0;
+            c_stream.zfree = (free_func) 0;
+            c_stream.opaque = (voidpf) 0;
+            check_err(deflateInit(&c_stream, level), "deflateInit");
+        } else {
+            if (level != level_old) {   /* \pdfcompresslevel change in mid document */
+                check_err(deflateEnd(&c_stream), "deflateEnd");
+                c_stream.zalloc = (alloc_func) 0;       /* these 3 lines no need, just to be safe */
+                c_stream.zfree = (free_func) 0;
+                c_stream.opaque = (voidpf) 0;
+                check_err(deflateInit(&c_stream, level), "deflateInit");
+            } else
+                check_err(deflateReset(&c_stream), "deflateReset");
+        }
+        level_old = level;
+        c_stream.next_out = (Bytef *) zipbuf;
         c_stream.avail_out = ZIP_BUF_SIZE;
     }
+    assert(zipbuf != NULL);
     c_stream.next_in = pdfbuf;
     c_stream.avail_in = pdfptr;
-    for(;;) {
+    for (;;) {
         if (c_stream.avail_out == 0) {
             pdfgone += xfwrite(zipbuf, 1, ZIP_BUF_SIZE, pdffile);
             pdflastbyte = zipbuf[ZIP_BUF_SIZE - 1];     /* not needed */
-            c_stream.next_out = (Bytef*)zipbuf;
+            c_stream.next_out = (Bytef *) zipbuf;
             c_stream.avail_out = ZIP_BUF_SIZE;
         }
         err = deflate(&c_stream, finish ? Z_FINISH : Z_NO_FLUSH);
@@ -68,8 +84,15 @@
                 xfwrite(zipbuf, 1, ZIP_BUF_SIZE - c_stream.avail_out, pdffile);
             pdflastbyte = zipbuf[ZIP_BUF_SIZE - c_stream.avail_out - 1];
         }
-        check_err(deflateEnd(&c_stream), "deflateEnd");
         xfflush(pdffile);
     }
     pdfstreamlength = c_stream.total_out;
 }
+
+void zip_free(void)
+{
+    if (zipbuf != NULL) {
+        check_err(deflateEnd(&c_stream), "deflateEnd");
+        free(zipbuf);
+    }
+}
--- tetex-src-3.0/texk/web2c/pdftexdir/writet3.c.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/writet3.c	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2006 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: writet3.c,v 1.10 2005/12/26 14:26:18 hahe Exp hahe $
+$Id: writet3.c 217 2007-07-31 16:55:39Z oneiros $
 */
 
 #include "ptexlib.h"
@@ -28,7 +28,7 @@
 #define T3_BUF_SIZE   1024
 
 typedef char t3_line_entry;
-define_array(t3_line);   
+define_array(t3_line);
 
 FILE *t3_file;
 static boolean t3_image_used;
@@ -52,10 +52,10 @@
     if (t3_eof())                                          \
         pdftex_fail("unexpected end of file");
 
-static void t3_getline(void) 
+static void t3_getline(void)
 {
     int c;
-restart:
+  restart:
     t3_line_ptr = t3_line_array;
     c = t3_getchar();
     while (!t3_eof()) {
@@ -113,8 +113,7 @@
                    "%i %i %i %i %i %i %i %i =", &glyph_index,
                    &width, &height, &depth, &llx, &lly, &urx, &ury) != 8) {
             remove_eol(p, t3_line_array);
-            pdftex_warn("invalid glyph preamble: `%s'", t3_line_array);
-            return;
+            pdftex_fail("invalid glyph preamble: `%s'", t3_line_array);
         }
         if (glyph_index < fontbc[f] || glyph_index > fontec[f])
             return;
@@ -131,16 +130,16 @@
     t3_glyph_num++;
     pdfnewdict(0, 0, 0);
     t3_char_procs[glyph_index] = objptr;
-    if (width == 0) 
-        t3_char_widths[glyph_index] = 
-            (getcharwidth(f, glyph_index)/t3_font_scale) / pdffontsize[f];
+    if (width == 0)
+        t3_char_widths[glyph_index] =
+            (getcharwidth(f, glyph_index) / t3_font_scale) / pdffontsize[f];
     else
         t3_char_widths[glyph_index] = width;
     pdfbeginstream();
     t3_getline();
-    pdf_printf("%i 0 %i %i %i %i d1\nq\n", 
-               (int)t3_char_widths[glyph_index], (int)llx,
-               (int)lly, (int)urx, (int)ury);
+    pdf_printf("%i 0 %i %i %i %i d1\nq\n",
+               (int) t3_char_widths[glyph_index], (int) llx,
+               (int) lly, (int) urx, (int) ury);
     while (!t3_prefix(t3_end_glyph_str)) {
         t3_check_eof();
         if (t3_prefix("BI"))
@@ -154,22 +153,22 @@
 
 static integer get_pk_font_scale(internalfontnumber f)
 {
-    return 
-        dividescaled(pkscalefactor, 
+    return
+        dividescaled(pkscalefactor,
                      dividescaled(pdffontsize[f], onehundredbp,
                                   fixeddecimaldigits + 2), 0);
 }
 
 static integer pk_char_width(internalfontnumber f, scaled w)
 {
-    return 
+    return
         dividescaled(dividescaled(w, pdffontsize[f], 7),
                      get_pk_font_scale(f), 0);
 }
 
 scaled getpkcharwidth(internalfontnumber f, scaled w)
 {
-    return (get_pk_font_scale(f)/100000.0)*
+    return (get_pk_font_scale(f) / 100000.0) *
         (pk_char_width(f, w) / 100.0) * pdffontsize[f];
 }
 
@@ -187,20 +186,19 @@
         kpse_magstep_fix(round
                          (fixedpkresolution *
                           (((float) pdffontsize[f]) / fontdsize[f])),
-             fixedpkresolution, NULL);
+                         fixedpkresolution, NULL);
     cur_file_name = makecstring(fontname[f]);
-    name = kpse_find_pk(cur_file_name, (unsigned)dpi, &font_ret);
+    name = kpse_find_pk(cur_file_name, (unsigned) dpi, &font_ret);
     if (name == NULL ||
         !FILESTRCASEEQ(cur_file_name, font_ret.name) ||
-        !kpse_bitmap_tolerance((float)font_ret.dpi, (float)dpi)) {
-        pdftex_warn("Font %s at %i not found", cur_file_name, (int)dpi);
-        cur_file_name = NULL;
-        return false;
+        !kpse_bitmap_tolerance((float) font_ret.dpi, (float) dpi)) {
+        pdftex_fail("Font %s at %i not found", cur_file_name, (int) dpi);
     }
     t3_file = xfopen(name, FOPEN_RBIN_MODE);
+    /* recorder_record_input(name); */
     t3_image_used = true;
     is_pk_font = true;
-    tex_printf(" <%s", (char *)name);
+    tex_printf(" <%s", (char *) name);
     cd.rastersize = 256;
     cd.raster = xtalloc(cd.rastersize, halfword);
     check_preamble = true;
@@ -208,10 +206,10 @@
         check_preamble = false;
         if (!pdfcharmarked(f, cd.charcode))
             continue;
-        t3_char_widths[cd.charcode] = 
+        t3_char_widths[cd.charcode] =
             pk_char_width(f, getcharwidth(f, cd.charcode));
         if (cd.cwidth < 1 || cd.cheight < 1) {
-            cd.xescape = cd.cwidth = round(t3_char_widths[cd.charcode]/100.0);
+            cd.xescape = cd.cwidth = round(t3_char_widths[cd.charcode] / 100.0);
             cd.cheight = 1;
             cd.xoff = 0;
             cd.yoff = 0;
@@ -228,30 +226,30 @@
         t3_char_procs[cd.charcode] = objptr;
         pdfbeginstream();
         pdfprintreal(t3_char_widths[cd.charcode], 2);
-        pdf_printf(" 0 %i %i %i %i d1\n", 
-                    (int)llx, (int)lly, (int)urx, (int)ury);
+        pdf_printf(" 0 %i %i %i %i d1\n",
+                   (int) llx, (int) lly, (int) urx, (int) ury);
         if (is_null_glyph)
             goto end_stream;
-        pdf_printf("q\n%i 0 0 %i %i %i cm\nBI\n", (int)cd.cwidth,
-                   (int)cd.cheight, (int)llx, (int)lly);
+        pdf_printf("q\n%i 0 0 %i %i %i cm\nBI\n", (int) cd.cwidth,
+                   (int) cd.cheight, (int) llx, (int) lly);
         pdf_printf("/W %i\n/H %i\n", (int) cd.cwidth, (int) cd.cheight);
         pdf_puts("/IM true\n/BPC 1\n/D [1 0]\nID ");
-        cw = (cd.cwidth + 7)/8;
-        rw = (cd.cwidth + 15)/16;
+        cw = (cd.cwidth + 7) / 8;
+        rw = (cd.cwidth + 15) / 16;
         row = cd.raster;
         for (i = 0; i < cd.cheight; i++) {
             for (j = 0; j < rw - 1; j++) {
-                pdfout(*row/256);
-                pdfout(*row%256);
+                pdfout(*row / 256);
+                pdfout(*row % 256);
                 row++;
             }
-            pdfout(*row/256);
-            if (2*rw == cw)
-                pdfout(*row%256);
+            pdfout(*row / 256);
+            if (2 * rw == cw)
+                pdfout(*row % 256);
             row++;
         }
         pdf_puts("\nEI\nQ\n");
-end_stream:
+      end_stream:
         pdfendstream();
     }
     xfree(cd.raster);
@@ -290,14 +288,11 @@
         sscanf(t3_line_array + strlen(t3_font_scale_str) + 1, "%g",
                &t3_font_scale) < 1 || t3_font_scale <= 0
         || t3_font_scale > 1000) {
-        pdftex_warn("missing or invalid font scale");
-        t3_close();
-        cur_file_name = NULL;
-        return;
+        pdftex_fail("missing or invalid font scale");
     }
     while (!t3_eof())
         t3_write_glyph(f);
-write_font_dict:
+  write_font_dict:
     for (i = fontbc[f]; i <= fontec[f]; i++)
         if (pdfcharmarked(f, i))
             break;
@@ -308,7 +303,7 @@
     last_char = i;
     pdfbegindict(objnum, 1);    /* Type 3 font dictionary */
     pdf_puts("/Type /Font\n/Subtype /Type3\n");
-    pdf_printf("/Name /F%i\n", (int)f);
+    pdf_printf("/Name /F%i\n", (int) f);
     if (pdffontattr[f] != getnullstr()) {
         pdfprint(pdffontattr[f]);
         pdf_puts("\n");
@@ -319,20 +314,20 @@
         pdfprintreal(pk_font_scale, 5);
         pdf_puts(" 0 0 ");
         pdfprintreal(pk_font_scale, 5);
-        pdf_puts(" 0 0]\n") ;
+        pdf_puts(" 0 0]\n");
     } else
-        pdf_printf("/FontMatrix [%g 0 0 %g 0 0]\n", 
-                   (double)t3_font_scale, (double)t3_font_scale);
-    pdf_printf("/%s [ %i %i %i %i ]\n", 
+        pdf_printf("/FontMatrix [%g 0 0 %g 0 0]\n",
+                   (double) t3_font_scale, (double) t3_font_scale);
+    pdf_printf("/%s [ %i %i %i %i ]\n",
                font_key[FONTBBOX1_CODE].pdfname,
                (int) t3_b0, (int) t3_b1, (int) t3_b2, (int) t3_b3);
-    pdf_printf("/Resources << /ProcSet [ /PDF %s] >>\n", 
+    pdf_printf("/Resources << /ProcSet [ /PDF %s] >>\n",
                t3_image_used ? "/ImageB " : "");
     pdf_printf("/FirstChar %i\n/LastChar %i\n", first_char, last_char);
     wptr = pdfnewobjnum();
     eptr = pdfnewobjnum();
     cptr = pdfnewobjnum();
-    pdf_printf("/Widths %i 0 R\n/Encoding %i 0 R\n/CharProcs %i 0 R\n", 
+    pdf_printf("/Widths %i 0 R\n/Encoding %i 0 R\n/CharProcs %i 0 R\n",
                (int) wptr, (int) eptr, (int) cptr);
     pdfenddict();
     pdfbeginobj(wptr, 1);       /* chars width array */
@@ -343,7 +338,7 @@
             pdf_puts(" ");
     } else
         for (i = first_char; i <= last_char; i++)
-            pdf_printf("%i ", (int)t3_char_widths[i]);
+            pdf_printf("%i ", (int) t3_char_widths[i]);
     pdf_puts("]\n");
     pdfendobj();
     pdfbegindict(eptr, 1);      /* encoding dictionary */
@@ -374,7 +369,7 @@
     pdfbegindict(cptr, 1);      /* CharProcs dictionary */
     for (i = first_char; i <= last_char; i++)
         if (t3_char_procs[i] != 0)
-            pdf_printf("/a%i %i 0 R\n", (int)i, (int)t3_char_procs[i]);
+            pdf_printf("/a%i %i 0 R\n", (int) i, (int) t3_char_procs[i]);
     pdfenddict();
     t3_close();
     tex_printf(">");
--- tetex-src-3.0/texk/web2c/pdftexdir/pdftex.h.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/pdftex.h	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2006 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: //depot/Build/source.development/TeX/texk/web2c/pdftexdir/pdftex.h#4 $
+$Id: pdftex.h 217 2007-07-31 16:55:39Z oneiros $
 */
 
 /* Additions to texmfmp.h for pdfTeX */
--- tetex-src-3.0/texk/web2c/pdftexdir/macnames.c.pdf1405	2004-06-07 09:51:33.000000000 +0200
+++ tetex-src-3.0/texk/web2c/pdftexdir/macnames.c	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2002 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: //depot/Build/source.development/TeX/texk/web2c/pdftexdir/macnames.c#5 $
+$Id: macnames.c 217 2007-07-31 16:55:39Z oneiros $
 */
 
 const char notdef[] = ".notdef";
@@ -301,12 +301,12 @@
 };
 
 const char *ambiguous_names[] = {
-    "Delta",            /*   increment   */
-    "Omega",            /*   Ohm         */
-    "Pi",               /*   product     */
-    "Sigma",            /*   summation   */
-    "dmacron",          /*   dslash      */
-    "macron",           /*   overscore   */
-    "periodcentered",   /*   middot      */
+    "Delta",                    /*   increment   */
+    "Omega",                    /*   Ohm         */
+    "Pi",                       /*   product     */
+    "Sigma",                    /*   summation   */
+    "dmacron",                  /*   dslash      */
+    "macron",                   /*   overscore   */
+    "periodcentered",           /*   middot      */
     NULL
 };
--- tetex-src-3.0/texk/web2c/pdftexdir/pdftex.web.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/pdftex.web	2008-01-06 17:13:15.000000000 +0100
@@ -1,4 +1,4 @@
-% Copyright (c) 1996-2006 Han Th\^e\llap{\raise 0.5ex\hbox{\'{}}} Th\`anh, <thanh@@pdftex.org>
+% Copyright (c) 1996-2007 Han Th\^e\llap{\raise 0.5ex\hbox{\'{}}} Th\`anh, <thanh@@pdftex.org>
 
 % This file is part of pdfTeX.
 
@@ -12,8 +12,8 @@
 % A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 
 % You should have received a copy of the GNU General Public License along with
-% pdfTeX; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
-% Suite 330, Boston, MA  02111-1307  USA
+% pdfTeX; if not, write to the Free Software Foundation, Inc., 51 Franklin
+% Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
 % e-TeX is copyright (C) 1994,98 by Peter Breitenlohner; all rights are
 % reserved.  Copying of this file is authorized only if (1) you are Peter
@@ -286,8 +286,8 @@
   {printed when \eTeX\ starts}
 @#
 @d pdftex_version==140 { \.{\\pdftexversion} }
-@d pdftex_revision=="3" { \.{\\pdftexrevision} }
-@d pdftex_version_string=='-1.40.3' {current \pdfTeX\ version}
+@d pdftex_revision=="5" { \.{\\pdftexrevision} }
+@d pdftex_version_string=='-1.40.5' {current \pdfTeX\ version}
 @#
 @d pdfeTeX_banner=='This is pdfeTeX, Version 3.141592',pdftex_version_string,eTeX_version_string
    {printed when \pdfeTeX\ starts}
@@ -4781,7 +4781,8 @@
 @d hyph_data=99 {hyphenation data ( \.{\\hyphenation}, \.{\\patterns} )}
 @d set_interaction=100 {define level of interaction ( \.{\\batchmode}, etc.~)}
 @d letterspace_font=101 {letterspace a font ( \.{\\letterspacefont} )}
-@d max_command=101 {the largest command code seen at |big_switch|}
+@d pdf_copy_font=102 {create a new font instance ( \.{\\pdfcopyfont} )}
+@d max_command=102 {the largest command code seen at |big_switch|}
 
 @ The remaining command codes are extra special, since they cannot get through
 \TeX's scanner to the main control routine. They have been given values higher
@@ -4919,7 +4920,7 @@
 |aux|, and |mode_line|, which live in a \PASCAL\ record that is ready to
 be pushed onto |nest| if necessary.
 
-@d ignore_depth==-65536000 {|prev_depth| value that is ignored}
+@d ignore_depth==-65536000 {magic dimension value to mean `ignore me'}
 
 @<Types...@>=
 @!list_state_record=record@!mode_field:-mmode..mmode;@+
@@ -5033,7 +5034,7 @@
 @ @<Show the auxiliary...@>=
 case abs(m) div (max_command+1) of
 0: begin print_nl("prevdepth ");
-  if a.sc<=ignore_depth then print("ignored")
+  if a.sc<=pdf_ignored_dimen then print("ignored")
   else print_scaled(a.sc);
   if nest[p].pg_field<>0 then
     begin print(", prevgraf ");
@@ -5658,7 +5659,8 @@
 @d pdf_append_kern_code      = pdftex_first_integer_code + 23 {append kern before certain characters?}
 @d pdf_gen_tounicode_code    = pdftex_first_integer_code + 24 {generate ToUnicode for fonts?}
 @d pdf_draftmode_code        = pdftex_first_integer_code + 25 {switch on draftmode if positive}
-@d pdf_int_pars=pdftex_first_integer_code + 26 {total number of \pdfTeX's integer parameters}
+@d pdf_inclusion_copy_font_code     = pdftex_first_integer_code + 26 {generate ToUnicode for fonts?}
+@d pdf_int_pars=pdftex_first_integer_code + 27 {total number of \pdfTeX's integer parameters}
 @#
 @d etex_int_base=pdf_int_pars {base for \eTeX's integer parameters}
 @d tracing_assigns_code=etex_int_base {show assignments}
@@ -5763,6 +5765,7 @@
 @d pdf_image_hicolor    == int_par(pdf_image_hicolor_code)
 @d pdf_image_apply_gamma == int_par(pdf_image_apply_gamma_code)
 @d pdf_draftmode        == int_par(pdf_draftmode_code)
+@d pdf_inclusion_copy_font == int_par(pdf_inclusion_copy_font_code)
 @#
 @d tracing_assigns==int_par(tracing_assigns_code)
 @d tracing_groups==int_par(tracing_groups_code)
@@ -5864,6 +5867,7 @@
 pdf_append_kern_code:    print_esc("pdfappendkern");
 pdf_gen_tounicode_code:    print_esc("pdfgentounicode");
 pdf_draftmode_code:        print_esc("pdfdraftmode");
+pdf_inclusion_copy_font_code:    print_esc("pdfinclusioncopyfonts");
 @/@<Cases for |print_param|@>@/
 othercases print("[unknown integer parameter!]")
 endcases;
@@ -6039,6 +6043,8 @@
 @!@:pdf_gen_tounicode_}{\.{\\pdfgentounicode} primitive@>
 primitive("pdfdraftmode",assign_int,int_base+pdf_draftmode_code);@/
 @!@:pdf_draftmode_}{\.{\\pdfdraftmode} primitive@>
+primitive("pdfinclusioncopyfonts",assign_int,int_base+pdf_inclusion_copy_font_code);@/
+@!@:pdf_inclusion_copy_font_}{\.{\\pdfinclusioncopyfonts} primitive@>
 
 @ @<Cases of |print_cmd_chr|...@>=
 assign_int: if chr_code<count_base then print_param(chr_code-int_base)
@@ -6146,8 +6152,9 @@
 @d pdf_last_line_depth_code   = pdftex_first_dimen_code + 8
 @d pdf_each_line_height_code  = pdftex_first_dimen_code + 9
 @d pdf_each_line_depth_code   = pdftex_first_dimen_code + 10
-@d pdf_px_dimen_code       = pdftex_first_dimen_code + 11
-@d pdftex_last_dimen_code  = pdftex_first_dimen_code + 11 {last number defined in this section}
+@d pdf_ignored_dimen_code   = pdftex_first_dimen_code + 11
+@d pdf_px_dimen_code       = pdftex_first_dimen_code + 12
+@d pdftex_last_dimen_code  = pdftex_first_dimen_code + 12 {last number defined in this section}
 @d dimen_pars = pdftex_last_dimen_code + 1 {total number of dimension parameters}
 @d scaled_base=dimen_base+dimen_pars
   {table of 256 user-defined \.{\\dimen} registers}
@@ -6187,6 +6194,7 @@
 @d pdf_last_line_depth   == dimen_par(pdf_last_line_depth_code)
 @d pdf_each_line_height  == dimen_par(pdf_each_line_height_code)
 @d pdf_each_line_depth   == dimen_par(pdf_each_line_depth_code)
+@d pdf_ignored_dimen   == dimen_par(pdf_ignored_dimen_code)
 @d pdf_px_dimen      == dimen_par(pdf_px_dimen_code)
 
 @p procedure print_length_param(@!n:integer);
@@ -6223,6 +6231,7 @@
 pdf_last_line_depth_code: print_esc("pdflastlinedepth");
 pdf_each_line_height_code: print_esc("pdfeachlineheight");
 pdf_each_line_depth_code: print_esc("pdfeachlinedepth");
+pdf_ignored_dimen_code: print_esc("pdfignoreddimen");
 pdf_px_dimen_code:      print_esc("pdfpxdimen");
 othercases print("[unknown dimen parameter!]")
 endcases;
@@ -6295,6 +6304,8 @@
 @!@:pdf_each_line_height_}{\.{\\pdfeachlineheight} primitive@>
 primitive("pdfeachlinedepth",assign_dimen,dimen_base+pdf_each_line_depth_code);@/
 @!@:pdf_each_line_depth_}{\.{\\pdfeachlinedepth} primitive@>
+primitive("pdfignoreddimen",assign_dimen,dimen_base+pdf_ignored_dimen_code);@/
+@!@:pdf_ignored_dimen_}{\.{\\pdfignoreddimen} primitive@>
 primitive("pdfpxdimen",assign_dimen,dimen_base+pdf_px_dimen_code);@/
 @!@:pdf_px_dimen_}{\.{\\pdfpxdimen} primitive@>
 
@@ -6662,6 +6673,8 @@
 @!@:font_}{\.{\\font} primitive@>
 primitive("letterspacefont",letterspace_font,0);@/
 @!@:letterspace_font_}{\.{\\letterspacefont} primitive@>
+primitive("pdfcopyfont",pdf_copy_font,0);@/
+@!@:pdf_copy_font_}{\.{\\pdfcopyfont} primitive@>
 primitive("fontdimen",assign_font_dimen,0);@/
 @!@:font_dimen_}{\.{\\fontdimen} primitive@>
 primitive("halign",halign,0);@/
@@ -6740,6 +6753,7 @@
 cs_name: print_esc("csname");
 def_font: print_esc("font");
 letterspace_font: print_esc("letterspacefont");
+pdf_copy_font: print_esc("pdfcopyfont");
 delim_num: print_esc("delimiter");
 divide: print_esc("divide");
 end_cs_name: print_esc("endcsname");
@@ -8856,8 +8870,9 @@
 else
   cur_cs := prim_lookup(text(cur_cs));
 if cur_cs<>undefined_primitive then begin
-  if cur_cmd>max_command then begin
-    cur_cmd := prim_eq_type(cur_cs);
+  t := prim_eq_type(cur_cs);
+  if t>max_command then begin
+    cur_cmd := t;
     cur_chr := prim_equiv(cur_cs);
     cur_tok := (cur_cmd*@'400)+cur_chr;
     cur_cs  := 0;
@@ -9524,7 +9539,7 @@
 begin m:=cur_chr;
 case cur_cmd of
 def_code: @<Fetch a character code from some table@>;
-toks_register,assign_toks,def_family,set_font,def_font,letterspace_font: @<Fetch a token list or
+toks_register,assign_toks,def_family,set_font,def_font,letterspace_font,pdf_copy_font: @<Fetch a token list or
   font identifier, provided that |level=tok_val|@>;
 assign_int: scanned_result(eqtb[m].int)(int_val);
 assign_dimen: scanned_result(eqtb[m].sc)(dimen_val);
@@ -10333,7 +10348,7 @@
 end
 
 @ The necessary conversion factors can all be specified exactly as
-fractions whose numerator and denominator are 65535 or less.
+fractions whose numerator and denominator add to 32768 or less.
 According to the definitions here, $\rm2660\,dd\approx1000.33297\,mm$;
 this agrees well with the value $\rm1000.333\,mm$ cited by Bosshard
 @^Bosshard, Hans Rudolf@>
@@ -10341,7 +10356,13 @@
 The Didot point has been newly standardized in 1978;
 it's now exactly $\rm 1\,nd=0.375\,mm$.
 Conversion uses the equation $0.375=21681/20320/72.27\cdot25.4$.
-The new Cicero follows the new Didot point; $\rm 1\,nc=12\,nd$.
+The new Cicero follows the new Didot point; $\rm 1\,nc=12\,nd$. 
+These would lead to the ratios $21681/20320$ and $65043/5080$,
+respectively.
+The closest approximations supported by the algorithm would be
+$11183/10481$ and $1370/107$.  In order to maintain the
+relation $\rm 1\,nc=12\,nd$, we pick the ratio $685/642$ for
+$\rm nd$, however.
 
 @d set_conversion_end(#)== denom:=#; end
 @d set_conversion(#)==@+begin num:=#; set_conversion_end
@@ -10361,9 +10382,9 @@
 @.dd@>
 else if scan_keyword("cc") then set_conversion(14856)(1157)
 @.cc@>
-else if scan_keyword("nd") then set_conversion(21681)(20320)
+else if scan_keyword("nd") then set_conversion(685)(642)
 @.nd@>
-else if scan_keyword("nc") then set_conversion(65043)(5080)
+else if scan_keyword("nc") then set_conversion(1370)(107)
 @.nc@>
 else if scan_keyword("sp") then goto done
 @.sp@>
@@ -10756,7 +10777,7 @@
     if cur_val = null_font then
         pdf_error("font", "invalid font identifier");
     if c <> pdf_font_size_code then begin
-        pdf_check_vf(cur_val);
+        pdf_check_vf_cur_val;
         if not font_used[cur_val] then
             pdf_init_font_cur_val;
     end;
@@ -13176,7 +13197,7 @@
 var f:internal_font_number;
 @!m:halfword;
 begin @<Get the next non-blank non-call...@>;
-if (cur_cmd=def_font) or (cur_cmd=letterspace_font) then f:=cur_font
+if (cur_cmd=def_font) or (cur_cmd=letterspace_font) or (cur_cmd=pdf_copy_font) then f:=cur_font
 else if cur_cmd=set_font then f:=cur_chr
 else if cur_cmd=def_family then
   begin m:=cur_chr; scan_four_bit_int; f:=equiv(m+cur_val);
@@ -15149,6 +15170,7 @@
         fixed_image_apply_gamma := fix_int(pdf_image_apply_gamma, 0, 1);
         fixed_pdf_objcompresslevel := fix_int(pdf_objcompresslevel, 0, 3);
         fixed_pdf_draftmode     := fix_int(pdf_draftmode, 0, 1);
+        fixed_inclusion_copy_font      := fix_int(pdf_inclusion_copy_font, 0, 1);
         if (fixed_pdf_minor_version >= 5) and (fixed_pdf_objcompresslevel > 0) then
             pdf_os_enable := true
         else begin
@@ -15304,6 +15326,7 @@
     print(": "); print(p);
     if append_nl then
         print_ln;
+  if history=spotless then history:=warning_issued;
 end;
 
 procedure pdf_os_get_os_buf(s: integer); {check that |s| bytes more
@@ -15625,6 +15648,7 @@
 @!fixed_pk_resolution: integer;
 @!fixed_decimal_digits: integer;
 @!fixed_gen_tounicode: integer;
+@!fixed_inclusion_copy_font: integer;
 @!pk_scale_factor: integer;
 @!pdf_output_option: integer;
 @!pdf_output_value: integer;
@@ -15989,7 +16013,7 @@
 @* \[32d] The cross-reference table.
 
 The cross-reference table |obj_tab| is an array of |obj_tab_size| of
-|tab_entry|. Each entry contains five integer fields and represents an object
+|obj_entry|. Each entry contains five integer fields and represents an object
 in PDF file whose object number is the index of this entry in |obj_tab|.
 Objects in |obj_tab| maybe linked into list; objects in such a linked list have
 the same type.
@@ -16007,10 +16031,9 @@
 object in |obj_tab| if this object is linked in a list.
 
 The third field holds the byte offset of the object in the output PDF file,
-or its byte offset within an object stream.
-Objects that have been not written yet have this field set to zero. However
-sometimes we have to use this field to store some info before the object is
-written out.
+or its byte offset within an object stream. As long as the object is not
+written, this field is used for flags about the write status of the object;
+then it has a negative value.
 
 The fourth field holds the object number of the object stream, into which
 the object is included.
@@ -16021,10 +16044,14 @@
 
 @d obj_info(#) == obj_tab[#].int0 {information representing identifier of this object}
 @d obj_link(#) == obj_tab[#].int1 {link to the next entry in linked list}
-@d obj_offset(#) == obj_tab[#].int2 {byte offset for this object in PDF output file, or object stream number for this object}
+@d obj_offset(#) == obj_tab[#].int2 {negative (flags), or byte offset for this object in PDF output file, or object stream number for this object}
 @d obj_os_idx(#) == obj_tab[#].int3 {index of this object in object stream}
 @d obj_aux(#) == obj_tab[#].int4 {auxiliary pointer}
-@d is_obj_written(#) == (obj_offset(#) <> 0)
+
+@d set_obj_fresh(#) == obj_offset(#) := -2
+@d set_obj_scheduled(#) == if obj_offset(#) = -2 then obj_offset(#) := -1
+@d is_obj_scheduled(#) == (obj_offset(#) > -2)
+@d is_obj_written(#) == (obj_offset(#) > -1)
 
 @# {types of objects}
 @d obj_type_others              == 0 {objects which are not linked in any list}
@@ -16055,7 +16082,7 @@
 @d pdf_right(#)            == mem[# + 3].sc
 @d pdf_bottom(#)           == mem[# + 4].sc
 
-@# {dimesion of destinations/threads/annotations (in whatsit node)}
+@# {dimension of destinations/threads/annotations (in whatsit node)}
 @d pdf_width(#)            == mem[# + 1].sc
 @d pdf_height(#)           == mem[# + 2].sc
 @d pdf_depth(#)            == mem[# + 3].sc
@@ -16089,7 +16116,7 @@
 @d pdf_setmatrix_node_size == 2
 @d pdf_setmatrix_data(#)   == link(#+1) {data}
 
-@# {data structure for \.{\\pdsave}}
+@# {data structure for \.{\\pdfsave}}
 @d pdf_save_node_size      == 2
 
 @# {data structure for \.{\\pdfrestore}}
@@ -16328,7 +16355,7 @@
     incr(sys_obj_ptr);
     obj_ptr := sys_obj_ptr;
     obj_info(obj_ptr) := i;
-    obj_offset(obj_ptr) := 0;
+    set_obj_fresh(obj_ptr);
     obj_aux(obj_ptr) := 0;
     avl_put_obj(obj_ptr, t);
     if t = obj_type_page then begin
@@ -16712,28 +16739,15 @@
 @d virtual_font_type = 1 {virtual font}
 @d real_font_type = 2 {real font}
 @d subst_font_type = 3 {substituted font}
-@d pdf_check_vf(#) == begin
-    tmp_f := #;
-    do_vf;
-    if pdf_font_type[#] = virtual_font_type then
-        pdf_error("font", "command cannot be used with virtual font");
-end
-
-@d pdf_check_new_font(#) ==
-    if pdf_font_type[#] = new_font_type then begin
-        tmp_f := #;
-        do_vf;
-    end
 
 @<Declare procedures that need to be declared forward for \pdfTeX@>=
-procedure do_vf; forward;
+procedure pdf_check_vf_cur_val; forward;
 procedure pdf_init_font_cur_val; forward;
 procedure scan_pdf_ext_toks; forward;
 
 @ @<Glob...@>=
 @!pdf_font_type: ^eight_bits; {the type of font}
 @!pdf_font_attr: ^str_number; {pointer to additional attributes}
-@!tmp_f: internal_font_number; {temporary register to pass parameter to some subroutines}
 
 @ Here come some subroutines to deal with expanded fonts for HZ-algorithm.
 
@@ -16747,6 +16761,8 @@
     f := font(lig_char(#));
 end
 
+@d non_existent_path == "///..."
+
 @p
 procedure set_tag_code(f: internal_font_number; c: eight_bits; i: integer);
 var fixedi:integer;
@@ -17020,7 +17036,10 @@
 begin
     if fs <> 0 then begin
         for k := font_base + 1 to font_ptr do
-            if str_eq_str(font_name[k], s) and (font_size[k] = fs) then begin
+            if (font_area[k] <> non_existent_path) and 
+               str_eq_str(font_name[k], s) and 
+               (font_size[k] = fs) then 
+            begin
                 flush_str(s);
                 tfm_lookup := k;
                 return;
@@ -17028,7 +17047,9 @@
     end
     else begin
         for k := font_base + 1 to font_ptr do
-            if str_eq_str(font_name[k], s) then begin
+            if (font_area[k] <> non_existent_path) and 
+               str_eq_str(font_name[k], s) then
+            begin
                 flush_str(s);
                 tfm_lookup := k;
                 return;
@@ -17056,45 +17077,6 @@
     load_expand_font := k;
 end;
 
-function auto_expand_vf(f: internal_font_number): boolean;
-{check for a virtual auto-expanded font}
-var save_f, bf, lf: internal_font_number;
-    e, k: integer;
-begin
-    auto_expand_vf := false;
-    if (not pdf_font_auto_expand[f]) or (pdf_font_blink[f] = null_font) then
-        return; {not an auto-expanded font}
-    bf := pdf_font_blink[f];
-    if pdf_font_type[bf] = new_font_type then {we must process the base font first}
-    begin
-        save_f := tmp_f;
-        tmp_f := bf;
-        do_vf;
-        tmp_f := save_f;
-    end;
-
-    if pdf_font_type[bf] <> virtual_font_type then
-        return; {not a virtual font}
-
-    e := pdf_font_expand_ratio[f];
-    for k := 0 to vf_local_font_num[bf] - 1 do begin
-        lf := vf_default_font[bf] + k;
-        allocvffnts;
-        {copy vf local font numbers:}
-        vf_e_fnts[vf_nf] := vf_e_fnts[lf];
-        {definition of local vf fonts are expanded from base fonts:}
-        vf_i_fnts[vf_nf] := auto_expand_font(vf_i_fnts[lf], e);
-        copy_expand_params(vf_i_fnts[vf_nf], vf_i_fnts[lf], e);
-        incr(vf_nf);
-    end;
-    vf_packet_base[f] := vf_packet_base[bf];
-    vf_local_font_num[f] := vf_local_font_num[bf];
-    vf_default_font[f] := vf_nf - vf_local_font_num[f];
-
-    pdf_font_type[f] := virtual_font_type;
-    auto_expand_vf := true;
-end;
-
 function fix_expand_value(f: internal_font_number; e: integer): integer;
 {return the multiple of |pdf_font_step[f]| that is nearest to |e|}
 var step: integer;
@@ -17160,15 +17142,15 @@
 end;
 
 procedure set_expand_params(f: internal_font_number; auto_expand: boolean;
-                            font_stretch, font_shrink, font_step, expand_ratio: integer);
+                            stretch_limit, shrink_limit, font_step, expand_ratio: integer);
 {expand a font with given parameters}
 begin
     pdf_font_step[f] := font_step;
     pdf_font_auto_expand[f] := auto_expand;
-    if font_stretch > 0 then
-        pdf_font_stretch[f] := get_expand_font(f, font_stretch);
-    if font_shrink > 0 then
-        pdf_font_shrink[f] := get_expand_font(f, -font_shrink);
+    if stretch_limit > 0 then
+        pdf_font_stretch[f] := get_expand_font(f, stretch_limit);
+    if shrink_limit > 0 then
+        pdf_font_shrink[f] := get_expand_font(f, -shrink_limit);
     if expand_ratio <> 0 then
         pdf_font_expand_ratio[f] := expand_ratio;
 end;
@@ -17182,7 +17164,7 @@
         lf := vf_i_fnts[vf_default_font[f] + k];
         set_expand_params(lf, pdf_font_auto_expand[f],
                           pdf_font_expand_ratio[pdf_font_stretch[f]],
-                          pdf_font_expand_ratio[pdf_font_shrink[f]],
+                          -pdf_font_expand_ratio[pdf_font_shrink[f]],
                           pdf_font_step[f], pdf_font_expand_ratio[f]);
         if pdf_font_type[lf] = virtual_font_type then
             vf_expand_local_fonts(lf);
@@ -17190,7 +17172,7 @@
 end;
 
 procedure read_expand_font; {read font expansion spec and load expanded font}
-var font_shrink, font_stretch, font_step: integer;
+var shrink_limit, stretch_limit, font_step: integer;
     f: internal_font_number;
     auto_expand: boolean;
 begin
@@ -17200,23 +17182,23 @@
     if f = null_font then
         pdf_error("font expansion", "invalid font identifier");
     if pdf_font_blink[f] <> null_font then
-        pdf_error("font expansion", "\pdffontexpand cannot be used this way (the base font has been expanded or letter-spaced)");
+        pdf_error("font expansion", "\pdffontexpand cannot be used this way (the base font has been expanded)");
     scan_optional_equals;
     scan_int;
-    font_stretch := fix_int(cur_val, 0, 1000);
+    stretch_limit := fix_int(cur_val, 0, 1000);
     scan_int;
-    font_shrink := fix_int(cur_val, 0, 500);
+    shrink_limit := fix_int(cur_val, 0, 500);
     scan_int;
     font_step := fix_int(cur_val, 0, 100);
     if font_step = 0 then
         pdf_error("font expansion", "invalid step");
-    font_stretch := font_stretch - font_stretch mod font_step;
-    if font_stretch < 0 then
-        font_stretch := 0;
-    font_shrink := font_shrink - font_shrink mod font_step;
-    if font_shrink < 0 then
-        font_shrink := 0;
-    if (font_stretch = 0) and (font_shrink = 0) then
+    stretch_limit := stretch_limit - stretch_limit mod font_step;
+    if stretch_limit < 0 then
+        stretch_limit := 0;
+    shrink_limit := shrink_limit - shrink_limit mod font_step;
+    if shrink_limit < 0 then
+        shrink_limit := 0;
+    if (stretch_limit = 0) and (shrink_limit = 0) then
         pdf_error("font expansion", "invalid limit(s)");
     auto_expand := false;
     if scan_keyword("autoexpand") then begin
@@ -17230,37 +17212,60 @@
     if (pdf_font_step[f] <> 0) then
     {this font has been expanded, ensure the expansion parameters are identical}
     begin
-        if (pdf_font_step[f] <> font_step) or
-           ((pdf_font_stretch[f] = null_font) and (font_stretch <> 0)) or
-           ((pdf_font_stretch[f] <> null_font) and
-            (pdf_font_expand_ratio[pdf_font_stretch[f]] <> font_stretch)) or
-           ((pdf_font_shrink[f] = null_font) and (font_shrink <> 0)) or
+        if pdf_font_step[f] <> font_step then
+            pdf_error("font expansion", "font has been expanded with different expansion step");
+            
+        if ((pdf_font_stretch[f] = null_font) and (stretch_limit <> 0)) or
+            ((pdf_font_stretch[f] <> null_font) and
+            (pdf_font_expand_ratio[pdf_font_stretch[f]] <> stretch_limit)) then
+            pdf_error("font expansion", "font has been expanded with different stretch limit");
+             
+        if ((pdf_font_shrink[f] = null_font) and (shrink_limit <> 0)) or
            ((pdf_font_shrink[f] <> null_font) and
-            (pdf_font_expand_ratio[pdf_font_shrink[f]] <> -font_shrink)) or
-           (pdf_font_auto_expand[f] <> auto_expand)
-        then
-            pdf_error("font expansion", "font has been expanded with different parameters");
+            (-pdf_font_expand_ratio[pdf_font_shrink[f]] <> shrink_limit)) then
+            pdf_error("font expansion", "font has been expanded with different shrink limit");
+
+        if pdf_font_auto_expand[f] <> auto_expand then
+            pdf_error("font expansion", "font has been expanded with different auto expansion value");
     end
     else begin
-        if pdf_font_type[f] <> new_font_type then
+        if (pdf_font_type[f] <> new_font_type) and (pdf_font_type[f] <> virtual_font_type) then
             pdf_warning("font expansion", "font should be expanded before its first use",
                         true, true);
-        set_expand_params(f, auto_expand, font_stretch, font_shrink, font_step, 0);
+        set_expand_params(f, auto_expand, stretch_limit, shrink_limit, font_step, 0);
         if pdf_font_type[f] = virtual_font_type then
             vf_expand_local_fonts(f);
     end;
 end;
 
+@ We implement robust letter spacing using virtual font.
+
+@d vf_replace_z ==
+begin
+    vf_alpha:=16;
+    while vf_z>=@'40000000 do begin
+        vf_z:=vf_z div 2;
+        vf_alpha:=vf_alpha+vf_alpha;
+    end;
+    vf_beta:=256 div vf_alpha;
+    vf_alpha:=vf_alpha*vf_z;
+end
+
+@p
 function letter_space_font(u: pointer; f: internal_font_number; e: integer): internal_font_number;
 var k: internal_font_number;
-    w, r, fs: scaled;
+    w, r: scaled;
     s: str_number;
     i, nw: integer;
     old_setting:0..max_selector;
+    vf_z: integer;
+    vf_alpha: integer;
+    vf_beta: 1..16;
 begin
     {read a new font and expand the character widths}
     k := read_font_info(u, font_name[f], "", font_size[f]);
-    set_no_ligatures(k); {disable ligatures for letter-spaced fonts}
+    if scan_keyword("nolig") then
+        set_no_ligatures(k); {disable ligatures for letter-spaced fonts}
     nw := height_base[k] - width_base[k];
     for i := 0 to nw - 1 do
         font_info[width_base[k] + i].sc :=
@@ -17288,8 +17293,7 @@
     vf_default_font[k] := vf_nf - 1;
     pdf_font_type[k] := virtual_font_type;
 
-    fs := font_size[f];
-    vf_z := fs;
+    vf_z := font_size[f];
     vf_replace_z;
     w := round_xn_over_d(quad(f), e, 2000);
     if w > 0 then
@@ -17363,6 +17367,106 @@
     equiv(u):=f; eqtb[font_id_base+f]:=eqtb[u]; font_id_text(f):=t;
 end;
 
+function is_letterspaced_font(f: internal_font_number): boolean;
+label done;
+var i, j: pool_pointer;
+begin
+    is_letterspaced_font := false;
+    if pdf_font_type[f] <> virtual_font_type then
+        return;
+    i := str_start[font_name[f] + 1] - 1;
+    j := str_start[font_name[f]];
+    if (str_pool[i - 1] <> 'l') or (str_pool[i] <> 's') then
+        return;
+    i := i - 2;
+    while i >= j do begin
+        if (str_pool[i] < '0') or (str_pool[i] > '9') then
+            goto done;
+        i := i - 1;
+    end;
+done:
+    if i < j then
+        return;
+    if (str_pool[i] <> '+') and (str_pool[i] <> '-') then
+        return;
+    is_letterspaced_font := true;
+end;
+
+function copy_font_info(f: internal_font_number): internal_font_number;
+{create a copy of |f| in the font mem}
+var lf, bc, ec, i: halfword;
+    k: internal_font_number;
+begin
+    if (pdf_font_expand_ratio[f] <> 0) or (pdf_font_step[f] <> 0) then
+        pdf_error("\pdfcopyfont", "cannot copy an expanded font");
+    if is_letterspaced_font(f) then
+        pdf_error("\pdfcopyfont", "cannot copy a letterspaced font");
+
+    k := font_ptr + 1;
+    incr(font_ptr);
+    if (font_ptr >= font_max) then
+        overflow("maximum internal font number (font_max)", font_max);
+    font_name[k] := font_name[f];
+    font_area[k] := non_existent_path; {to avoid interferences with |new_font()| and |tfm_lookup()|}
+    hyphen_char[k] := hyphen_char[f];
+    skew_char[k] := skew_char[f];
+    font_bchar[k] := font_bchar[f];
+    font_false_bchar[k] := font_false_bchar[f];
+    font_bc[k] := font_bc[f];
+    font_ec[k] := font_ec[f];
+    font_size[k] := font_size[f];
+    font_dsize[k] := font_dsize[f];
+    font_params[k] := font_params[f];
+    font_glue[k] := font_glue[f];
+    bchar_label[k] := bchar_label[f];
+
+    {set base addresses}
+    bc := font_bc[f];
+    ec := font_ec[f];
+    char_base[k] := fmem_ptr - bc;
+    width_base[k] := char_base[k] + ec + 1;
+
+    height_base[k] := width_base[k] + (height_base[f] - width_base[f]);
+    depth_base[k] := height_base[k] + (depth_base[f] - height_base[f]);
+    italic_base[k] := depth_base[k] + (italic_base[f] - depth_base[f]);
+    lig_kern_base[k] := italic_base[k] + (lig_kern_base[f] - italic_base[f]);
+    kern_base[k] := lig_kern_base[k] + (kern_base[f] - lig_kern_base[f]);
+    exten_base[k] := kern_base[k] + (exten_base[f] - kern_base[f]);
+    param_base[k] := exten_base[k] + (param_base[f] - exten_base[f]);
+
+    {allocate memory for the new font |k| and copy data from |f|}
+    lf := (param_base[f] - char_base[f]) + font_params[f] + 1;
+    if (fmem_ptr + lf >= font_mem_size) then
+        overflow("number of words of font memory (font_mem_size)", font_mem_size);
+    for i := 0 to lf - 1 do
+        font_info[char_base[k] + bc + i] := font_info[char_base[f] + bc + i];
+    fmem_ptr := fmem_ptr + lf;
+
+    copy_font_info := k;
+end;
+
+procedure make_font_copy(a: small_number);
+{make a font copy for further use with font expansion}
+var u:pointer; {user's font identifier}
+@!t:str_number; {name for the frozen font identifier}
+@!old_setting:0..max_selector; {holds |selector| setting}
+@!f, k:internal_font_number;
+begin
+    get_r_token; u:=cur_cs;
+    if u>=hash_base then t:=text(u)
+    else if u>=single_base then
+      if u=null_cs then t:="FONT"@+else t:=u-single_base
+    else  begin old_setting:=selector; selector:=new_string;
+      print("FONT"); print(u-active_base); selector:=old_setting;
+    @.FONTx@>
+      str_room(1); t:=make_string;
+      end;
+    define(u,set_font,null_font); scan_optional_equals; scan_font_ident;
+    k := cur_val;
+    f := copy_font_info(k);
+    equiv(u):=f; eqtb[font_id_base+f]:=eqtb[u]; font_id_text(f):=t;
+end;
+
 @ We need to hold information about used characters in each font for partial
 downloading.
 
@@ -17386,50 +17490,24 @@
 pdf_resname_prefix := 0;
 last_tokens_string := 0;
 
-
 @ Here we implement reading information from \.{VF} file.
 
 @d vf_max_packet_length = 10000 {max length of character packet in \.{VF} file}
-
 @#
-@d vf_error = 61 {label to go to when an error occur}
 @d do_char = 70 {label to go to typesetting a character of virtual font}
 @#
 @d long_char = 242 {\.{VF} command for general character packet}
 @d vf_id = 202 {identifies \.{VF} files}
 @d put1=133 {typeset a character}
-
-@#
-@d vf_byte == getc(vf_file) {get a byte from\.{VF} file}
-@d vf_packet(#) == vf_packet_start[vf_packet_base[#] + vf_packet_end
-@d vf_packet_end(#) == #]
-
-@#
-@d bad_vf(#) == begin vf_err_str := #; goto vf_error; end {go out \.{VF}
-processing with an error message}
 @d four_cases(#) == #,#+1,#+2,#+3
-
 @#
 @d tmp_b0 == tmp_w.qqqq.b0
 @d tmp_b1 == tmp_w.qqqq.b1
 @d tmp_b2 == tmp_w.qqqq.b2
 @d tmp_b3 == tmp_w.qqqq.b3
 @d tmp_int == tmp_w.int
-
 @#
-@d scaled3u == {convert |tmp_b1..tmp_b3| to an unsigned scaled dimension}
-(((((tmp_b3*vf_z)div@'400)+(tmp_b2*vf_z))div@'400)+(tmp_b1*vf_z))div vf_beta
-@d scaled4(#) == {convert |tmp_b0..tmp_b3| to a scaled dimension}
-  #:=scaled3u;
-  if tmp_b0>0 then if tmp_b0=255 then # := # - vf_alpha
-@d scaled3(#) == {convert |tmp_b1..tmp_b3| to a scaled dimension}
-  #:=scaled3u; @+ if tmp_b1>127 then # := # - vf_alpha
-@d scaled2 == {convert |tmp_b2..tmp_b3| to a scaled dimension}
-  if tmp_b2>127 then tmp_b1:=255 else tmp_b1:=0;
-  scaled3
-@d scaled1 == {convert |tmp_b3| to a scaled dimension}
-  if tmp_b3>127 then tmp_b1:=255 else tmp_b1:=0;
-  tmp_b2:=tmp_b1; scaled3
+@d bad_vf(#) == vf_error(font_name[f], #) {quit with an error message telling the vf filename}
 
 @<Glob...@>=
 @!vf_packet_base: ^integer; {base addresses of character packets from virtual fonts}
@@ -17441,34 +17519,46 @@
 @!vf_e_fnts: ^integer; {external font numbers}
 @!vf_i_fnts: ^internal_font_number; {corresponding internal font numbers}
 @!tmp_w: memory_word; {accumulator}
-@!vf_z: integer; {multiplier}
-@!vf_alpha: integer; {correction for negative values}
-@!vf_beta: 1..16; {divisor}
 
 @ @<Set init...@>=
 vf_nf := 0;
 
 @ The |do_vf| procedure attempts to read the \.{VF} file for a font, and sets
 |pdf_font_type| to |real_font_type| if the \.{VF} file could not be found
-or loaded, otherwise sets |pdf_font_type| to |virtual_font_type|.  At this
-time, |tmp_f| is the internal font number of the current \.{TFM} font.  To
+or loaded, otherwise sets |pdf_font_type| to |virtual_font_type|. To
 process font definitions in virtual font we call |vf_def_font|.
 
-@p procedure vf_replace_z;
+@p
+procedure vf_error(filename, msg: str_number);
+var old_setting:0..max_selector; {holds print |selector|}
+    s: str_number;
 begin
-    vf_alpha:=16;
-    while vf_z>=@'40000000 do begin
-        vf_z:=vf_z div 2;
-        vf_alpha:=vf_alpha+vf_alpha;
-    end;
-    vf_beta:=256 div vf_alpha;
-    vf_alpha:=vf_alpha*vf_z;
+    str_room(length(filename) + 3);
+    old_setting:=selector; selector:=new_string;
+    print(filename);
+    print(".vf");
+    s := make_string;
+    selector:=old_setting;
+    pdf_error(s, msg);
+end;
+
+function vf_byte: eight_bits; {read a byte from |vf_file|}
+var i: integer;
+begin
+    i := getc(vf_file);
+    if i < 0 then
+        pdf_error("vf", "unexpected EOF or error");
+    vf_byte := i;
 end;
 
 function vf_read(k: integer): integer; {read |k| bytes as an integer from \.{VF} file}
 var i: integer;
 begin
-    i := 0;
+    pdfassert((k > 0) and (k <= 4));
+    i := vf_byte;
+    if (k = 4) and (i > 127) then
+        i := i - 256;
+    decr(k);
     while k > 0 do begin
         i := i*256 + vf_byte;
         decr(k);
@@ -17496,15 +17586,13 @@
     cs: four_quarters;
 begin
     cs.b0 := vf_byte; cs.b1 := vf_byte; cs.b2 := vf_byte; cs.b3 := vf_byte;
-    tmp_b0 := vf_byte; tmp_b1 := vf_byte; tmp_b2 := vf_byte; tmp_b3 := vf_byte;
-    scaled4(fs);
+    fs := sqxfw(vf_read(4), font_size[f]);
     ds := vf_read(4) div @'20;
     tmp_b0 := vf_byte;
     tmp_b1 := vf_byte;
     while tmp_b0 > 0 do begin
         decr(tmp_b0);
-        if vf_byte > 0 then
-            do_nothing; {skip the font path}
+        call_func(vf_byte); {skip the font path}
     end;
     str_room(tmp_b1);
     while tmp_b1 > 0 do begin
@@ -17528,23 +17616,19 @@
     if (pdf_font_step[f] <> 0) then
         set_expand_params(k, pdf_font_auto_expand[f],
                           pdf_font_expand_ratio[pdf_font_stretch[f]],
-                          pdf_font_expand_ratio[pdf_font_shrink[f]],
+                          -pdf_font_expand_ratio[pdf_font_shrink[f]],
                           pdf_font_step[f], pdf_font_expand_ratio[f]);
     vf_def_font := k;
 end;
 
-procedure do_vf; {process \.{VF} file with font internal number |f|}
-label vf_error;
+procedure do_vf(f: internal_font_number); {process \.{VF} file with font internal number |f|}
 var cmd, k, n: integer;
-    cc, cmd_length: integer;
+    cc, cmd_length, packet_length: integer;
     tfm_width: scaled;
-    vf_err_str, s: str_number;
+    s: str_number;
     stack_level: vf_stack_index;
     save_vf_nf: internal_font_number;
-    f: internal_font_number;
-
 begin
-    f := tmp_f;
     pdf_font_type[f] := real_font_type;
     if auto_expand_vf(f) then
         return; {auto-expanded virtual font}
@@ -17560,16 +17644,6 @@
         bad_vf("POST command expected");
     b_close(vf_file);
     pdf_font_type[f] := virtual_font_type;
-    return;
-vf_error:
-    print_nl("Error in processing VF font (");
-    print(font_name[f]);
-    print(".vf): ");
-    print(vf_err_str);
-    print(", virtual font will be ignored");
-    print_ln;
-    b_close(vf_file);
-    update_terminal;
 end;
 
 @ @<Open |vf_file|, return if not found@>=
@@ -17584,7 +17658,7 @@
     bad_vf("wrong id byte");
 cmd_length := vf_byte;
 for k := 1 to cmd_length do
-    tmp_int := vf_byte;
+    call_func(vf_byte); {skip the comment}
 tmp_b0 := vf_byte; tmp_b1 := vf_byte; tmp_b2 := vf_byte; tmp_b3 := vf_byte;
 if ((tmp_b0 <> 0) or (tmp_b1 <> 0) or (tmp_b2 <> 0) or (tmp_b3 <> 0)) and
    ((font_check[f].b0 <> 0) or (font_check[f].b1 <> 0) or
@@ -17600,9 +17674,7 @@
     print(font_name[f]);
     print(".vf ignored");
 end;
-update_terminal;
-vf_z := font_size[f];
-vf_replace_z
+update_terminal
 
 @ @<Process the font definitions@>=
 cmd := vf_byte;
@@ -17622,38 +17694,36 @@
 
 @ @<Build a character packet@>=
 if cmd = long_char then begin
-    vf_packet_length := vf_read(4);
+    packet_length := vf_read(4);
     cc := vf_read(4);
     if not is_valid_char(cc) then
         bad_vf("invalid character code");
-    tmp_b0 := vf_byte; tmp_b1 := vf_byte; tmp_b2 := vf_byte; tmp_b3 := vf_byte;
-    scaled4(tfm_width);
+    tfm_width := sqxfw(vf_read(4), font_size[f]);
 end
 else begin
-    vf_packet_length := cmd;
+    packet_length := cmd;
     cc := vf_byte;
     if not is_valid_char(cc) then
         bad_vf("invalid character code");
-    tmp_b1 := vf_byte; tmp_b2 := vf_byte; tmp_b3 := vf_byte;
-    scaled3(tfm_width);
+    tfm_width := sqxfw(vf_read(3), font_size[f]);
 end;
-if vf_packet_length < 0 then
+if packet_length < 0 then
     bad_vf("negative packet length");
-if vf_packet_length > vf_max_packet_length then
+if packet_length > vf_max_packet_length then
     bad_vf("packet length too long");
-if (tfm_width <> char_width(f)(char_info(f)(cc))) then begin
+if abs(tfm_width - char_width(f)(char_info(f)(cc))) > 1 then begin
     print_nl("character width mismatch in font ");
     print(font_name[f]);
     print(".vf ignored");
 end;
-str_room(vf_packet_length);
-while vf_packet_length > 0 do begin
+str_room(packet_length);
+while packet_length > 0 do begin
     cmd := vf_byte;
-    decr(vf_packet_length);
+    decr(packet_length);
     @<Cases of \.{DVI} commands that can appear in character packet@>;
     if cmd <> nop then
         append_char(cmd);
-    vf_packet_length := vf_packet_length - cmd_length;
+    packet_length := packet_length - cmd_length;
     while cmd_length > 0 do begin
         decr(cmd_length);
         append_char(vf_byte);
@@ -17661,7 +17731,7 @@
 end;
 if stack_level <> 0 then
     bad_vf("more PUSHs than POPs in character packet");
-if vf_packet_length <> 0 then
+if packet_length <> 0 then
     bad_vf("invalid packet length or DVI command in packet");
 @<Store the packet being built@>;
 cmd := vf_byte
@@ -17678,7 +17748,7 @@
         ((fnt1 <= cmd) and (cmd <= fnt1 + 3)) then begin
     if cmd >= fnt1 then begin
         k := vf_read(cmd - fnt1 + 1);
-        vf_packet_length := vf_packet_length - (cmd - fnt1 + 1);
+        packet_length := packet_length - (cmd - fnt1 + 1);
     end
     else
         k := cmd - fnt_num_0;
@@ -17711,7 +17781,7 @@
 four_cases(z1):     cmd_length := cmd - z1 + 1;
 four_cases(xxx1):  begin
     cmd_length := vf_read(cmd - xxx1 + 1);
-    vf_packet_length := vf_packet_length - (cmd - xxx1 + 1);
+    packet_length := packet_length - (cmd - xxx1 + 1);
     if cmd_length > vf_max_packet_length then
         bad_vf("packet length too long");
     if cmd_length < 0 then
@@ -17739,6 +17809,49 @@
     bad_vf("improver DVI command");
 endcases
 
+@ @p
+procedure pdf_check_vf_cur_val;
+var f: internal_font_number;
+begin
+    f := cur_val;
+    do_vf(f);
+    if pdf_font_type[f] = virtual_font_type then
+        pdf_error("font", "command cannot be used with virtual font");
+end;
+
+function auto_expand_vf(f: internal_font_number): boolean;
+{check for a virtual auto-expanded font}
+var bf, lf: internal_font_number;
+    e, k: integer;
+begin
+    auto_expand_vf := false;
+    if (not pdf_font_auto_expand[f]) or (pdf_font_blink[f] = null_font) then
+        return; {not an auto-expanded font}
+    bf := pdf_font_blink[f];
+    if pdf_font_type[bf] = new_font_type then {we must process the base font first}
+        do_vf(bf);
+    if pdf_font_type[bf] <> virtual_font_type then
+        return; {not a virtual font}
+
+    e := pdf_font_expand_ratio[f];
+    for k := 0 to vf_local_font_num[bf] - 1 do begin
+        lf := vf_default_font[bf] + k;
+        allocvffnts;
+        {copy vf local font numbers:}
+        vf_e_fnts[vf_nf] := vf_e_fnts[lf];
+        {definition of local vf fonts are expanded from base fonts:}
+        vf_i_fnts[vf_nf] := auto_expand_font(vf_i_fnts[lf], e);
+        copy_expand_params(vf_i_fnts[vf_nf], vf_i_fnts[lf], e);
+        incr(vf_nf);
+    end;
+    vf_packet_base[f] := vf_packet_base[bf];
+    vf_local_font_num[f] := vf_local_font_num[bf];
+    vf_default_font[f] := vf_nf - vf_local_font_num[f];
+
+    pdf_font_type[f] := virtual_font_type;
+    auto_expand_vf := true;
+end;
+
 @ The |do_vf_packet| procedure is called in order to interpret the
 character packet for a virtual character. Such a packet may contain the
 instruction to typeset a character from the same or an other virtual
@@ -17771,7 +17884,11 @@
 character packet}
 var i: integer;
 begin
-    i := 0;
+    pdfassert((k > 0) and (k <= 4));
+    i := packet_byte;
+    if (k = 4) and (i > 127) then
+        i := i - 256;
+    decr(k);
     while k > 0 do begin
         i := i*256 + packet_byte;
         decr(k);
@@ -17779,43 +17896,27 @@
     packet_read := i;
 end;
 
-function packet_scaled(k: integer): integer; {get |k| bytes from packet as a
+function packet_scaled(k: integer; fs: scaled): scaled; {get |k| bytes from packet as a
 scaled}
-var s: scaled;
+var fw: integer;
 begin
+    fw := packet_read(k);
     case k of
-    1: begin
-        tmp_b3 := packet_byte;
-        scaled1(s);
-    end;
-    2: begin
-        tmp_b2 := packet_byte;
-        tmp_b3 := packet_byte;
-        scaled2(s);
-    end;
-    3: begin
-        tmp_b1 := packet_byte;
-        tmp_b2 := packet_byte;
-        tmp_b3 := packet_byte;
-        scaled3(s);
-    end;
-    4: begin
-        tmp_b0 := packet_byte;
-        tmp_b1 := packet_byte;
-        tmp_b2 := packet_byte;
-        tmp_b3 := packet_byte;
-        scaled4(s);
-    end;
-    othercases pdf_error("vf", "invalid number size");
+    1:  if fw > 127 then
+            fw := fw - 256;
+    2:  if fw > @"8000 then
+            fw := fw - @"10000;
+    3:  if fw > @"800000 then
+            fw := fw - @"1000000;
     endcases;
-    packet_scaled := s;
+    packet_scaled := sqxfw(fw, fs);
 end;
 
-procedure do_vf_packet(f: internal_font_number; c: eight_bits); {typeset the \.{DVI} commands in the
-character packet for character |c| in current font |f|}
+procedure do_vf_packet(vf_f: internal_font_number; c: eight_bits); {typeset the
+\.{DVI} commands in the character packet for character |c| in current font |f|}
 label do_char, continue;
-var save_vf, k, n: internal_font_number;
-    save_h, save_v: scaled;
+var f, k, n: internal_font_number;
+    save_cur_h, save_cur_v: scaled;
     cmd: integer;
     char_move: boolean;
     w, x, y, z: scaled;
@@ -17824,32 +17925,28 @@
     incr(vf_cur_s);
     if vf_cur_s > vf_max_recursion then
         overflow("max level recursion of virtual fonts", vf_max_recursion);
-    push_packet_state;
-    start_packet(f, c);
-    vf_z := font_size[f];
-    vf_replace_z;
-    save_vf := f;
-    f := vf_i_fnts[vf_default_font[save_vf]];
-    save_v := cur_v;
-    save_h := cur_h;
+    save_cur_v := cur_v;
+    save_cur_h := cur_h;
+    push_packet_state;      {save pointer and length of the current packet}
+    start_packet(vf_f, c);  {set pointer and length of the new packet}
+    f := vf_i_fnts[vf_default_font[vf_f]];
     w := 0; x := 0; y := 0; z := 0;
     while vf_packet_length > 0 do begin
         cmd := packet_byte;
         @<Do typesetting the \.{DVI} commands in virtual character packet@>;
 continue:
     end;
-    cur_h := save_h;
-    cur_v := save_v;
-    pop_packet_state;
-    vf_z := font_size[f];
-    vf_replace_z;
+    pop_packet_state; {restore pointer and length of the previous packet}
+    cur_v := save_cur_v;
+    cur_h := save_cur_h;
     decr(vf_cur_s);
 end;
 
 @ The following code typesets a character to PDF output.
 
-@d output_one_char(#)==begin
-    pdf_check_new_font(f);
+@d output_one_char(#) == begin
+    if pdf_font_type[f] = new_font_type then
+        do_vf(f);
     if pdf_font_type[f] = virtual_font_type then
         do_vf_packet(f, #)
     else begin
@@ -17859,7 +17956,6 @@
     end;
 end
 
-
 @<Do typesetting the \.{DVI} commands in virtual character packet@>=
 if (cmd >= set_char_0) and (cmd <= set_char_0 + 127)  then begin
     if not is_valid_char(cmd) then begin
@@ -17876,13 +17972,13 @@
     else
         k := cmd - fnt_num_0;
     n := 0;
-    while (n < vf_local_font_num[save_vf]) and
-          (vf_e_fnts[vf_default_font[save_vf] + n] <> k) do
+    while (n < vf_local_font_num[vf_f]) and
+          (vf_e_fnts[vf_default_font[vf_f] + n] <> k) do
         incr(n);
-    if (n = vf_local_font_num[save_vf]) then
+    if (n = vf_local_font_num[vf_f]) then
         pdf_error("vf", "local font not found")
     else
-        f := vf_i_fnts[vf_default_font[save_vf] + n];
+        f := vf_i_fnts[vf_default_font[vf_f] + n];
 end
 else case cmd of
 push: begin
@@ -17920,8 +18016,8 @@
     goto do_char;
 end;
 set_rule, put_rule: begin
-    rule_ht := packet_scaled(4);
-    rule_wd := packet_scaled(4);
+    rule_ht := packet_scaled(4, font_size[vf_f]);
+    rule_wd := packet_scaled(4, font_size[vf_f]);
     if (rule_wd > 0) and (rule_ht > 0) then begin
         pdf_set_rule(cur_h, cur_v, rule_wd, rule_ht);
         if cmd = set_rule then
@@ -17929,27 +18025,27 @@
     end;
 end;
 four_cases(right1):
-    cur_h := cur_h + packet_scaled(cmd - right1 + 1);
+    cur_h := cur_h + packet_scaled(cmd - right1 + 1, font_size[vf_f]);
 w0, four_cases(w1): begin
     if cmd > w0 then
-        w := packet_scaled(cmd - w0);
+        w := packet_scaled(cmd - w0, font_size[vf_f]);
     cur_h := cur_h + w;
 end;
 x0, four_cases(x1): begin
     if cmd > x0 then
-        x := packet_scaled(cmd - x0);
+        x := packet_scaled(cmd - x0, font_size[vf_f]);
     cur_h := cur_h + x;
 end;
 four_cases(down1):
-    cur_v := cur_v + packet_scaled(cmd - down1 + 1);
+    cur_v := cur_v + packet_scaled(cmd - down1 + 1, font_size[vf_f]);
 y0, four_cases(y1): begin
     if cmd > y0 then
-        y := packet_scaled(cmd - y0);
+        y := packet_scaled(cmd - y0, font_size[vf_f]);
     cur_v := cur_v + y;
 end;
 z0, four_cases(z1): begin
     if cmd > z0 then
-        z := packet_scaled(cmd - z0);
+        z := packet_scaled(cmd - z0, font_size[vf_f]);
     cur_v := cur_v + z;
 end;
 four_cases(xxx1):  begin
@@ -18536,7 +18632,7 @@
 else begin
     @<Calculate page dimensions and margins@>;
     pdf_last_page := get_obj(obj_type_page, total_pages + 1, 0);
-    obj_aux(pdf_last_page) := 1; {mark that this page has beed created}
+    obj_aux(pdf_last_page) := 1; {mark that this page has been created}
     pdf_new_dict(obj_type_others, 0, 0);
     pdf_last_stream := obj_ptr;
     cur_h := cur_h_offset;
@@ -18928,14 +19024,13 @@
         i := obj_annot_ptr(info(k));
         pdf_begin_dict(info(k), 1);
         pdf_print_ln("/Type /Annot");
+        if pdf_action_type(pdf_link_action(i)) <> pdf_action_user then
+            pdf_print_ln("/Subtype /Link");
         if pdf_link_attr(i) <> null then
             pdf_print_toks_ln(pdf_link_attr(i));
         pdf_rectangle(pdf_left(i), pdf_top(i), pdf_right(i), pdf_bottom(i));
-        if pdf_action_type(pdf_link_action(i)) <> pdf_action_user
-        then begin
-            pdf_print_ln("/Subtype /Link");
+        if pdf_action_type(pdf_link_action(i)) <> pdf_action_user then
             pdf_print("/A ");
-        end;
         write_action(pdf_link_action(i));
         pdf_end_dict;
         k := link(k);
@@ -19350,7 +19445,9 @@
            print_font_identifier(i);
            print(" and ");
            print_font_identifier(k);
-           print(" has conflicting attributes"); print_ln; print_ln;
+           print(" have conflicting attributes; I will ignore the attributes assigned to ");
+           print_font_identifier(i);
+           print_ln; print_ln;
         end;
     end;
 fixed_gen_tounicode := pdf_gen_tounicode;
@@ -19645,7 +19742,7 @@
 @ @<Output the |obj_tab|@>=
 l := 0;
 for k := 1 to sys_obj_ptr do
-    if obj_offset(k) = 0 then begin
+    if not is_obj_written(k) then begin
         obj_link(l) := k;
         l := k;
     end;
@@ -19656,7 +19753,7 @@
 pdf_print_fw_int(obj_link(0), 10);
 pdf_print_ln(" 65535 f ");
 for k := 1 to obj_ptr do begin
-    if obj_offset(k) = 0 then begin
+    if not is_obj_written(k) then begin
         pdf_print_fw_int(obj_link(k), 10);
         pdf_print_ln(" 00000 f ");
     end
@@ -19678,7 +19775,7 @@
     xref_offset_width := 1;
 l := 0;
 for k := 1 to sys_obj_ptr do
-    if obj_offset(k) = 0 then begin
+    if not is_obj_written(k) then begin
         obj_link(l) := k;
         l := k;
     end;
@@ -19701,7 +19798,7 @@
 pdf_print_nl;
 pdf_begin_stream;
 for k := 0 to sys_obj_ptr do begin
-    if obj_offset(k) = 0 then begin {a free object}
+    if not is_obj_written(k) then begin {a free object}
         pdf_out(0);
         pdf_out_bytes(obj_link(k), xref_offset_width);
         pdf_out(255);
@@ -19842,8 +19939,8 @@
 @ @<Glob...@>=
 @!pdf_font_blink: ^internal_font_number; {link to base font (used for expanded fonts only)}
 @!pdf_font_elink: ^internal_font_number; {link to expanded fonts (used for base fonts only)}
-@!pdf_font_stretch: ^integer; {limit of stretching}
-@!pdf_font_shrink: ^integer; {limit of shrinking}
+@!pdf_font_stretch: ^integer; {link to font expanded by stretch limi}
+@!pdf_font_shrink: ^integer; {link to font expanded by shrink limit}
 @!pdf_font_step: ^integer;  {amount of one step of expansion}
 @!pdf_font_expand_ratio: ^integer; {expansion ratio of a particular font}
 @!pdf_font_auto_expand: ^boolean; {this font is auto-expanded?}
@@ -19921,8 +20018,8 @@
     k := pdf_font_shrink[f];
     if k <> null_font then begin
         if max_shrink_ratio < 0 then
-            max_shrink_ratio := pdf_font_expand_ratio[k]
-        else if max_shrink_ratio <> pdf_font_expand_ratio[k] then
+            max_shrink_ratio := -pdf_font_expand_ratio[k]
+        else if max_shrink_ratio <> -pdf_font_expand_ratio[k] then
             pdf_error("font expansion", "using fonts with different limit of expansion in one paragraph is not allowed");
     end;
     check_expand_pars := true;
@@ -20002,12 +20099,17 @@
         return;
     l := prev_char_p;
     r := link(p);
-    if type(l) = ligature_node then
-        l := lig_char(l);
-    if type(r) = ligature_node then
-        r := lig_char(r);
-    if not (is_char_node(l) and is_char_node(r) and
-            (font(l) = font(r)) and
+    if not is_char_node(l) then
+        if type(l) = ligature_node then
+            l := lig_char(l)
+        else
+            return;
+    if not is_char_node(r) then
+        if type(r) = ligature_node then
+            r := lig_char(r)
+        else
+            return;
+    if not ((font(l) = font(r)) and 
             (pdf_font_stretch[font(l)] <> null_font))
     then
         return;
@@ -20026,12 +20128,17 @@
         return;
     l := prev_char_p;
     r := link(p);
-    if type(l) = ligature_node then
-        l := lig_char(l);
-    if type(r) = ligature_node then
-        r := lig_char(r);
-    if not (is_char_node(l) and is_char_node(r) and
-            (font(l) = font(r)) and
+    if not is_char_node(l) then
+        if type(l) = ligature_node then
+            l := lig_char(l)
+        else
+            return;
+    if not is_char_node(r) then
+        if type(r) = ligature_node then
+            r := lig_char(r)
+        else
+            return;
+    if not ((font(l) = font(r)) and 
             (pdf_font_shrink[font(l)] <> null_font))
     then
         return;
@@ -20073,13 +20180,13 @@
     if ef = 0 then
         return;
     if (pdf_font_stretch[f] <> null_font) and (ex_ratio > 0) then
-        k := expand_font(f, divide_scaled(ex_ratio*
-                                pdf_font_expand_ratio[pdf_font_stretch[f]]*ef,
-                                1000000, 0))
+        k := expand_font(f, ext_xn_over_d(ex_ratio*ef,
+                                          pdf_font_expand_ratio[pdf_font_stretch[f]],
+                                          1000000))
     else if (pdf_font_shrink[f] <> null_font) and (ex_ratio < 0) then
-        k := expand_font(f, -divide_scaled(ex_ratio*
-                                pdf_font_expand_ratio[pdf_font_shrink[f]]*ef,
-                                1000000, 0))
+        k := expand_font(f, ext_xn_over_d(ex_ratio*ef,
+                                          -pdf_font_expand_ratio[pdf_font_shrink[f]],
+                                          1000000))
     else
         k := f;
     if k <> f then begin
@@ -20228,30 +20335,32 @@
     x := x + width(p);
     end;
   kern_node: begin
-    if (m = cal_expand_ratio) and (subtype(p) = normal) then begin
-        k := kern_stretch(p);
-        if k <> 0 then begin
-            subtype(p) := substituted;
-            font_stretch := font_stretch + k;
-        end;
-        k := kern_shrink(p);
-        if k <> 0 then begin
-            subtype(p) := substituted;
-            font_shrink := font_shrink + k;
+    if subtype(p) = normal then begin
+        if m = cal_expand_ratio then begin
+            font_stretch := font_stretch + kern_stretch(p);
+            font_shrink := font_shrink + kern_shrink(p);
+        end
+        else if m = subst_ex_font then begin
+            if font_expand_ratio > 0 then
+                k := kern_stretch(p)
+            else if font_expand_ratio < 0 then
+                k := kern_shrink(p)
+            else
+                pdfassert(0);
+            if k <> 0 then begin
+                if is_char_node(link(p)) then
+                    width(p) := get_kern(font(prev_char_p),
+                                         character(prev_char_p),
+                                         character(link(p)))
+                else if type(link(p)) = ligature_node then
+                    width(p) := get_kern(font(prev_char_p),
+                                         character(prev_char_p),
+                                         character(lig_char(link(p))));
+            end;
         end;
-      end
-    else if (m = subst_ex_font) and (subtype(p) = substituted) then begin
-        if type(link(p)) = ligature_node then
-            width(p) := get_kern(font(prev_char_p),
-                                 character(prev_char_p),
-                                 character(lig_char(link(p))))
-        else
-            width(p) := get_kern(font(prev_char_p),
-                                 character(prev_char_p),
-                                 character(link(p)))
-      end;
-    x := x + width(p);
     end;
+    x := x + width(p);
+  end;
   math_node: begin x:=x+width(p);
     if TeXXeT_en then @<Adjust \(t)the LR stack for the |hpack| routine@>;
     end;
@@ -20659,7 +20768,7 @@
 @p procedure append_to_vlist(@!b:pointer);
 var d:scaled; {deficiency of space between baselines}
 @!p:pointer; {a new glue specification}
-begin if prev_depth>ignore_depth then
+begin if prev_depth>pdf_ignored_dimen then
   begin d:=width(baseline_skip)-prev_depth-height(b);
   if d<line_skip_limit then p:=new_param_glue(line_skip_code)
   else  begin p:=new_skip_param(baseline_skip_code);
@@ -22905,7 +23014,7 @@
 procedure init_span(@!p:pointer);
 begin push_nest;
 if mode=-hmode then space_factor:=1000
-else  begin prev_depth:=ignore_depth; normal_paragraph;
+else  begin prev_depth:=pdf_ignored_dimen; normal_paragraph;
   end;
 cur_span:=p;
 end;
@@ -25221,14 +25330,21 @@
   link(r):=q; q:=r;
   end
 
+@ @<Initialize table entries...@>=
+pdf_ignored_dimen := ignore_depth;
+pdf_each_line_height := pdf_ignored_dimen;
+pdf_each_line_depth := pdf_ignored_dimen;
+pdf_first_line_height := pdf_ignored_dimen;
+pdf_last_line_depth := pdf_ignored_dimen;
+
 @ @<Append the new box to the current vertical list...@>=
-if pdf_each_line_height <> 0 then
+if pdf_each_line_height <> pdf_ignored_dimen then
     height(just_box) := pdf_each_line_height;
-if pdf_each_line_depth <> 0 then
+if pdf_each_line_depth <> pdf_ignored_dimen then
     depth(just_box) := pdf_each_line_depth;
-if (pdf_first_line_height <> 0) and (cur_line = prev_graf + 1) then
+if (pdf_first_line_height <> pdf_ignored_dimen) and (cur_line = prev_graf + 1) then
     height(just_box) := pdf_first_line_height;
-if (pdf_last_line_depth <> 0) and (cur_line + 1 = best_line) then
+if (pdf_last_line_depth <> pdf_ignored_dimen) and (cur_line + 1 = best_line) then
     depth(just_box) := pdf_last_line_depth;
 if pre_adjust_head <> pre_adjust_tail then
     append_list(pre_adjust_head)(pre_adjust_tail);
@@ -27838,7 +27954,7 @@
 @ @<Fire up the user's output routine and |return|@>=
 begin output_active:=true;
 incr(dead_cycles);
-push_nest; mode:=-vmode; prev_depth:=ignore_depth; mode_line:=-line;
+push_nest; mode:=-vmode; prev_depth:=pdf_ignored_dimen; mode_line:=-line;
 begin_token_list(output_routine,output_text);
 new_save_level(output_group); normal_paragraph;
 scan_left_brace;
@@ -28474,11 +28590,11 @@
 required; thus, there is no need for a special action procedure.
 
 Note that baselineskip calculations are disabled after a rule in vertical
-mode, by setting |prev_depth:=ignore_depth|.
+mode, by setting |prev_depth:=pdf_ignored_dimen|.
 
 @<Cases of |main_control| that build...@>=
 vmode+hrule,hmode+vrule,mmode+vrule: begin tail_append(scan_rule_spec);
-  if abs(mode)=vmode then prev_depth:=ignore_depth
+  if abs(mode)=vmode then prev_depth:=pdf_ignored_dimen
   else if abs(mode)=hmode then space_factor:=1000;
   end;
 
@@ -29003,7 +29119,7 @@
   end;
 push_nest; mode:=-k;
 if k=vmode then
-  begin prev_depth:=ignore_depth;
+  begin prev_depth:=pdf_ignored_dimen;
   if every_vbox<>null then begin_token_list(every_vbox,every_vbox_text);
   end
 else  begin space_factor:=1000;
@@ -29204,7 +29320,7 @@
     saved(1) := 0;
 save_ptr := save_ptr + 2;
 new_save_level(insert_group); scan_left_brace; normal_paragraph;
-push_nest; mode:=-vmode; prev_depth:=ignore_depth;
+push_nest; mode:=-vmode; prev_depth:=pdf_ignored_dimen;
 end;
 
 @ @<Cases of |handle...@>=
@@ -30138,7 +30254,7 @@
 
 @ @<Cases of |main_control| that build...@>=
 mmode+vcenter: begin scan_spec(vcenter_group,false); normal_paragraph;
-  push_nest; mode:=-vmode; prev_depth:=ignore_depth;
+  push_nest; mode:=-vmode; prev_depth:=pdf_ignored_dimen;
   if every_vbox<>null then begin_token_list(every_vbox,every_vbox_text);
   end;
 
@@ -30764,6 +30880,7 @@
 any_mode(set_font),
 any_mode(def_font),
 any_mode(letterspace_font),
+any_mode(pdf_copy_font),
 any_mode(register),
 any_mode(advance),
 any_mode(multiply),
@@ -31506,6 +31623,7 @@
 @<Assignments@>=
 def_font: new_font(a);
 letterspace_font: new_letterspaced_font(a);
+pdf_copy_font: make_font_copy(a);
 
 @ @<Declare subprocedures for |prefixed_command|@>=
 procedure new_font(@!a:small_number);
@@ -31947,6 +32065,7 @@
 @<Dump the table of equivalents@>;
 @<Dump the font information@>;
 @<Dump the hyphenation tables@>;
+@<Dump pdftex data@>;
 @<Dump a couple more things and the closing check word@>;
 @<Close the format file@>;
 end;
@@ -31976,7 +32095,9 @@
 @<Undump the table of equivalents@>;
 @<Undump the font information@>;
 @<Undump the hyphenation tables@>;
+@<Undump pdftex data@>;
 @<Undump a couple more things and the closing check word@>;
+prev_depth := pdf_ignored_dimen;
 load_fmt_file:=true; return; {it worked!}
 bad_fmt: wake_up_terminal;
   wterm_ln('(Fatal format file error; I''m stymied)');
@@ -32367,6 +32488,78 @@
   end;
 @!init trie_not_ready:=false @+tini
 
+@ Store some of the pdftex data structures in the format. The idea here is
+to ensure that any data structures referenced from pdftex-specific whatsit
+nodes are retained. For the sake of simplicity and speed, all the filled parts
+of |pdf_mem| and |obj_tab| are retained, in the present implementation. We also
+retain three of the linked lists that start from |head_tab|, so that it is
+possible to, say, load an image in the \.{INITEX} run and then reference it in a
+\.{VIRTEX} run that uses the dumped format.
+
+@<Dump pdftex data@>=
+begin
+dumpimagemeta; {the image information array }
+dump_int(pdf_mem_size);
+dump_int(pdf_mem_ptr);
+for k:=1 to pdf_mem_ptr-1 do begin 
+  dump_int(pdf_mem[k]);
+  end;
+print_ln; print_int(pdf_mem_ptr-1); print(" words of pdfTeX memory");
+dump_int(obj_tab_size);
+dump_int(obj_ptr);
+dump_int(sys_obj_ptr);
+for k:=1 to sys_obj_ptr do begin
+  dump_int(obj_tab[k].int0);
+  dump_int(obj_tab[k].int1);
+  dump_int(obj_tab[k].int3);
+  dump_int(obj_tab[k].int4);
+  end;
+print_ln; print_int(sys_obj_ptr); print(" indirect objects");
+dump_int(pdf_obj_count);
+dump_int(pdf_xform_count);
+dump_int(pdf_ximage_count);
+dump_int(head_tab[obj_type_obj]);
+dump_int(head_tab[obj_type_xform]);
+dump_int(head_tab[obj_type_ximage]);
+dump_int(pdf_last_obj);
+dump_int(pdf_last_xform);
+dump_int(pdf_last_ximage);
+end
+
+@ And restoring the pdftex data structures from the format. The
+two function arguments to |undumpimagemeta| have been restored
+already in an earlier module.
+
+@<Undump pdftex data@>=
+begin
+undumpimagemeta(pdf_minor_version,pdf_inclusion_errorlevel);  {the image information array }
+undump_int(pdf_mem_size); 
+pdf_mem := xrealloc_array(pdf_mem, integer, pdf_mem_size);
+undump_int(pdf_mem_ptr);
+for k:=1 to pdf_mem_ptr-1 do begin
+  undump_int(pdf_mem[k]);
+  end;
+undump_int(obj_tab_size);
+undump_int(obj_ptr);
+undump_int(sys_obj_ptr);
+for k:=1 to sys_obj_ptr do begin
+  undump_int(obj_tab[k].int0);
+  undump_int(obj_tab[k].int1);
+  obj_tab[k].int2 := -1; 
+  undump_int(obj_tab[k].int3);
+  undump_int(obj_tab[k].int4);
+  end;
+undump_int(pdf_obj_count);
+undump_int(pdf_xform_count);
+undump_int(pdf_ximage_count);
+undump_int(head_tab[obj_type_obj]);
+undump_int(head_tab[obj_type_xform]);
+undump_int(head_tab[obj_type_ximage]);
+undump_int(pdf_last_obj);
+undump_int(pdf_last_xform);
+undump_int(pdf_last_ximage);
+end
+
 @ We have already printed a lot of statistics, so we set |tracing_stats:=0|
 to prevent them from appearing again.
 
@@ -34276,7 +34469,7 @@
     f := cur_val;
     if f = null_font then
         pdf_error("font", "invalid font identifier");
-    pdf_check_vf(f);
+    pdf_check_vf_cur_val;
     if not font_used[f] then
         pdf_init_font(f);
     scan_pdf_ext_toks;
@@ -35283,13 +35476,16 @@
         pdf_error("ext4", "annotations cannot be inside an XForm");
     if doing_leaders then
         return;
+    if is_obj_scheduled(pdf_annot_objnum(p)) then
+        pdf_annot_objnum(p) := pdf_new_objnum;
     set_rect_dimens(p, parent_box, x, y,
                     pdf_width(p), pdf_height(p), pdf_depth(p), 0);
     obj_annot_ptr(pdf_annot_objnum(p)) := p;
     pdf_append_list(pdf_annot_objnum(p))(pdf_annot_list);
+    set_obj_scheduled(pdf_annot_objnum(p));
 end;
 
-@ To implement nesting link annotations, we need a stack to hold copy of
+@ To implement nested link annotations, we need a stack to hold copy of
 |pdf_start_link_node|'s that are being written out, together with their box
 nesting level.
 
@@ -35338,6 +35534,8 @@
     if not is_shipping_page then
         pdf_error("ext4", "link annotations cannot be inside an XForm");
     pdfassert(type(parent_box) = hlist_node);
+    if is_obj_scheduled(pdf_link_objnum(p)) then
+        pdf_link_objnum(p) := pdf_new_objnum;
     push_link_level(p);
     set_rect_dimens(p, parent_box, x, y,
                     pdf_width(p), pdf_height(p), pdf_depth(p),
@@ -35345,6 +35543,7 @@
     obj_annot_ptr(pdf_link_objnum(p)) := p; {the reference for the pdf annot object
                                              must be set here}
     pdf_append_list(pdf_link_objnum(p))(pdf_link_list);
+    set_obj_scheduled(pdf_link_objnum(p));
 end;
 
 procedure end_link;
--- tetex-src-3.0/texk/web2c/pdftexdir/avlstuff.c.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/avlstuff.c	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 2004-2005 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 2004-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by Free
@@ -12,10 +12,10 @@
 for more details.
 
 You should have received a copy of the GNU General Public License along
-with this file; if not, write to the Free Software Foundation, Inc.,
-59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: avlstuff.c,v 1.12 2005/07/11 20:27:39 hahe Exp hahe $
+$Id: avlstuff.c 217 2007-07-31 16:55:39Z oneiros $
 
 */
 
@@ -79,24 +79,24 @@
 
     a = ((const oentry *) pa)->int0;
     b = ((const oentry *) pb)->int0;
-    if (a < 0 && b < 0) {        /* string comparison */
+    if (a < 0 && b < 0) {       /* string comparison */
         as = strstart[-a];
-        ae = strstart[-a + 1];        /* start of next string in pool */
+        ae = strstart[-a + 1];  /* start of next string in pool */
         bs = strstart[-b];
         be = strstart[-b + 1];
         al = ae - as;
         bl = be - bs;
-        if (al < bl)                /* compare first by string length */
+        if (al < bl)            /* compare first by string length */
             return -1;
         if (al > bl)
             return 1;
-            for (; as < ae; as++, bs++) {
-                if (strpool[as] < strpool[bs])
-                    return -1;
-                if (strpool[as] > strpool[bs])
-                    return 1;
-            }
-    } else {                        /* integer comparison */
+        for (; as < ae; as++, bs++) {
+            if (strpool[as] < strpool[bs])
+                return -1;
+            if (strpool[as] > strpool[bs])
+                return 1;
+        }
+    } else {                    /* integer comparison */
         if (a < b)
             return -1;
         if (a > b)
--- tetex-src-3.0/texk/web2c/pdftexdir/pdftex.defines.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/pdftex.defines	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 {
-Copyright (c) 1996-2006 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: //depot/Build/source.development/TeX/texk/web2c/pdftexdir/pdftex.defines#15 $
+$Id: pdftex.defines 217 2007-07-31 16:55:39Z oneiros $
 }
 
 { pdftex.defines: additions for pdfTeX }
@@ -98,6 +98,7 @@
 @define function packetbyte;
 @define procedure startpacket();
 @define procedure storepacket();
+@define function sqxfw();
 
 { functions from writefont.c }
 @define procedure dopdffont();
@@ -121,6 +122,9 @@
 @define procedure updateimageprocset();
 @define procedure writeimage();
 
+@define procedure dumpimagemeta;
+@define procedure undumpimagemeta();
+
 { functions from writet3.c }
 @define function getpkcharwidth();
 
@@ -134,5 +138,8 @@
 { functions from tounicode.c }
 @define procedure deftounicode();
 
+{ functions from pdftex.web (thanks Taco for the trick) }
+@define function autoexpandvf();
+
 { end of pdftex.defines }
 { vim: set syntax=web : }
--- tetex-src-3.0/texk/web2c/pdftexdir/writeimg.c.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/writeimg.c	2008-01-06 17:13:15.000000000 +0100
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: //depot/Build/source.development/TeX/texk/web2c/pdftexdir/writeimg.c#17 $
+$Id: writeimg.c 217 2007-07-31 16:55:39Z oneiros $
 */
 
 #include "ptexlib.h"
@@ -28,7 +28,7 @@
 #define bp2int(p)    round(p*(onehundredbp/100.0))
 
 /* define image_ptr, image_array & image_limit */
-define_array(image);   
+define_array(image);
 
 float epdf_width;
 float epdf_height;
@@ -221,7 +221,7 @@
     FILE *file = NULL;
     char header[MAX_HEADER];
 
-    if (img_type(img) != IMAGE_TYPE_NONE) /* nothing to do */
+    if (img_type(img) != IMAGE_TYPE_NONE)       /* nothing to do */
         return;
 
     /* read the header */
@@ -234,13 +234,13 @@
     xfclose(file, img_name(img));
 
     /* tests */
-    if (strncmp(header, HEADER_JPG, sizeof(HEADER_JPG)-1) == 0)
+    if (strncmp(header, HEADER_JPG, sizeof(HEADER_JPG) - 1) == 0)
         img_type(img) = IMAGE_TYPE_JPG;
-    else if (strncmp(header, HEADER_PNG, sizeof(HEADER_PNG)-1) == 0)
+    else if (strncmp(header, HEADER_PNG, sizeof(HEADER_PNG) - 1) == 0)
         img_type(img) = IMAGE_TYPE_PNG;
     else if (strncmp(header, HEADER_JBIG2, sizeof(HEADER_JBIG2) - 1) == 0)
         img_type(img) = IMAGE_TYPE_JBIG2;
-    else if (strncmp(header, HEADER_PDF, sizeof(HEADER_PDF)-1) == 0)
+    else if (strncmp(header, HEADER_PDF, sizeof(HEADER_PDF) - 1) == 0)
         img_type(img) = IMAGE_TYPE_PDF;
 }
 
@@ -248,7 +248,7 @@
 {
     char *image_suffix;
 
-    if (img_type(img) != IMAGE_TYPE_NONE) /* nothing to do */
+    if (img_type(img) != IMAGE_TYPE_NONE)       /* nothing to do */
         return;
     /* tests */
     if ((image_suffix = strrchr(cur_file_name, '.')) == 0)
@@ -273,16 +273,17 @@
     integer img = new_image_entry();
     img_colorspace_ref(img) = colorspace;
 
-    /* need to allocate new string as makecstring's buffer is 
+    /* need to allocate new string as makecstring's buffer is
        already used by cur_file_name */
     if (page_name != 0)
-      dest = xstrdup(makecstring(page_name));
+        dest = xstrdup(makecstring(page_name));
     cur_file_name = makecfilename(s);
     img_name(img) = kpse_find_file(cur_file_name, kpse_tex_format, true);
     if (img_name(img) == NULL)
         pdftex_fail("cannot find image file");
     /* kpse_find_file perhaps changed the file name */
     cur_file_name = img_name(img);
+    /* recorder_record_input(cur_file_name); */
     /* type checks */
     checktypebyheader(img);
     checktypebyextension(img);
@@ -314,7 +315,7 @@
         if (pdfversion < 4) {
             pdftex_fail
                 ("JBIG2 images only possible with at least PDF 1.4; you are generating PDF 1.%i",
-                 (int)pdfversion);
+                 (int) pdfversion);
         }
         jbig2_ptr(img) = xtalloc(1, JBIG2_IMAGE_INFO);
         img_type(img) = IMAGE_TYPE_JBIG2;
@@ -358,6 +359,8 @@
 
 void deleteimage(integer img)
 {
+    if (iniversion)
+        return;                 // The image may be \dump{}ed to a format
     switch (img_type(img)) {
     case IMAGE_TYPE_PDF:
         epdf_doc = pdf_ptr(img)->doc;
@@ -379,7 +382,166 @@
     return;
 }
 
-void img_free() 
+void img_free()
 {
     xfree(image_array);
 }
+
+
+/* To allow the use of \pdfrefximage inside saved boxes in -ini mode,
+ * the information in the array has to be (un)dumped with the format.
+ * The next two routines take care of that.
+ *
+ * Most of the work involved in setting up the images is simply
+ * executed again. This solves the many possible errors resulting from
+ * the split in two separate runs.
+
+ * There was only one problem remaining: The pdfversion and
+ * pdfinclusionerrorlevel can have changed inbetween the call to
+ * readimage() and dump time. That is why they are passed as arguments
+ * to undumpimagemeta once more.
+ */
+
+/* some of the dumped values are really type int, not integer,
+ * but since the macro falls back to generic_dump anyway, that
+ * does not matter. 
+ */
+
+#define dumpsizet   generic_dump
+#define dumpinteger generic_dump
+
+#define undumpsizet   generic_undump
+#define undumpinteger generic_undump
+
+/* (un)dumping a string means dumping the allocation size, followed
+ * by the bytes. The trailing \0 is dumped as well, because that 
+ * makes the code simpler.
+ */
+
+#define dumpcharptr(a)				\
+  do {						\
+    integer x;					\
+    if (a!=NULL) {				\
+      x = strlen(a)+1;				\
+      dumpinteger(x);  dumpthings(*a, x);	\
+    } else {					\
+      x = 0; dumpinteger(x);			\
+    }						\
+  } while (0)
+
+#define undumpcharptr(s)			\
+  do {						\
+    integer x;					\
+    char *a;					\
+    undumpinteger (x);				\
+    if (x>0) {					\
+      a = malloc(x);				\
+      undumpthings(*a,x);			\
+      s = a ;					\
+    } else { s = NULL; }			\
+  } while (0)
+
+
+
+void dumpimagemeta()
+{
+    int cur_image, img;
+
+    dumpsizet(image_limit);
+    cur_image = (image_ptr - image_array);
+    dumpinteger(cur_image);
+
+    for (img = 0; img < cur_image; img++) {
+
+        dumpcharptr(img_name(img));
+        dumpinteger(img_type(img));
+        dumpinteger(img_color(img));
+        dumpinteger(img_width(img));
+        dumpinteger(img_height(img));
+        dumpinteger(img_xres(img));
+        dumpinteger(img_yres(img));
+        dumpinteger(img_pages(img));
+        dumpinteger(img_colorspace_ref(img));
+
+        /* the image_struct is not dumped at all, except for a few
+           variables that are needed to restore the contents */
+
+        if (img_type(img) == IMAGE_TYPE_PDF) {
+            dumpinteger(pdf_ptr(img)->page_box);
+            dumpinteger(pdf_ptr(img)->selected_page);
+        } else if (img_type(img) == IMAGE_TYPE_JBIG2) {
+            dumpinteger(jbig2_ptr(img)->selected_page);
+        }
+
+    }
+}
+
+void undumpimagemeta(integer pdfversion, integer pdfinclusionerrorlevel)
+{
+    int cur_image, img;
+
+    undumpsizet(image_limit);
+
+    image_array = xtalloc(image_limit, image_entry);
+    undumpinteger(cur_image);
+    image_ptr = image_array + cur_image;
+
+    for (img = 0; img < cur_image; img++) {
+        undumpcharptr(img_name(img));
+        undumpinteger(img_type(img));
+        undumpinteger(img_color(img));
+        undumpinteger(img_width(img));
+        undumpinteger(img_height(img));
+        undumpinteger(img_xres(img));
+        undumpinteger(img_yres(img));
+        undumpinteger(img_pages(img));
+        undumpinteger(img_colorspace_ref(img));
+
+        /* if img_name(img)==NULL -- which it shouldn't be -- the next line
+           will trigger an assertion failure. */
+        if (kpse_find_file(img_name(img), kpse_tex_format, true) == NULL)
+            pdftex_fail("cannot find image file %s", img_name(img));
+
+        switch (img_type(img)) {
+        case IMAGE_TYPE_PDF:
+            pdf_ptr(img) = xtalloc(1, pdf_image_struct);
+
+            undumpinteger(pdf_ptr(img)->page_box);
+            undumpinteger(pdf_ptr(img)->selected_page);
+
+            read_pdf_info(img_name(img), NULL, pdf_ptr(img)->selected_page,
+                          pdf_ptr(img)->page_box, pdfversion,
+                          pdfinclusionerrorlevel);
+
+            img_width(img) = bp2int(epdf_width);
+            img_height(img) = bp2int(epdf_height);
+            img_pages(img) = epdf_num_pages;
+            pdf_ptr(img)->orig_x = bp2int(epdf_orig_x);
+            pdf_ptr(img)->orig_y = bp2int(epdf_orig_y);
+            pdf_ptr(img)->doc = epdf_doc;
+            break;
+        case IMAGE_TYPE_PNG:
+            img_pages(img) = 1;
+            read_png_info(img);
+            break;
+        case IMAGE_TYPE_JPG:
+            jpg_ptr(img) = xtalloc(1, JPG_IMAGE_INFO);
+            img_pages(img) = 1;
+            read_jpg_info(img);
+            break;
+        case IMAGE_TYPE_JBIG2:
+            if (pdfversion < 4) {
+                pdftex_fail
+                    ("JBIG2 images only possible with at least PDF 1.4; you are generating PDF 1.%i",
+                     (int) pdfversion);
+            }
+            jbig2_ptr(img) = xtalloc(1, JBIG2_IMAGE_INFO);
+            img_type(img) = IMAGE_TYPE_JBIG2;
+            undumpinteger(jbig2_ptr(img)->selected_page);
+            read_jbig2_info(img);
+            break;
+        default:
+            pdftex_fail("unknown type of image");
+        }
+    }
+}
--- tetex-src-3.0/texk/web2c/pdftexdir/README.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/README	2007-07-31 19:04:10.000000000 +0200
@@ -1,16 +1,16 @@
 pdfTeX
 ======
 
-README for version 3.14159-1.40.3
+README for version 3.14159-1.40.5
 =================================
 
-This directory contains the version 1.40.3 of pdfTeX, an extended version
+This directory contains the version 1.40.5 of pdfTeX, an extended version
 of eTeX that can create PDF directly from TeX source files and enhance the
 result of TeX typesetting with the help of PDF. When PDF output is not
 selected, pdfTeX produces normal DVI output, otherwise it produces PDF
 output that looks identical to the DVI output. An important aspect of this
 project is to investigate alternative justification algorithms, optionally
-making use of multiple master fonts. 
+making use of multiple master fonts.
 
 pdfTeX is based on the original eTeX sources and Web2c, and has been
 successfully compiled on Unix, Win32 and DOS systems. It is still under
@@ -18,11 +18,11 @@
 
 See the file NEWS for changes to the program.
 
-Documentation about pdfTeX can be found at http://www.pdftex.org 
+Documentation about pdfTeX can be found at http://www.pdftex.org
 
 There is also a mailing list on pdfTeX; go to
 http://tug.org/mailman/listinfo/pdftex for more information about it. Its
-searchable archive can be found at http://tug.org/pipermail/pdftex/ 
+searchable archive can be found at http://tug.org/pipermail/pdftex/
 Please read http://www.catb.org/~esr/faqs/smart-questions.html before
 asking any questions on the pdfTeX mailing list.
 
@@ -46,8 +46,8 @@
 details.
 
 You should have received a copy of the GNU General Public License along
-with pdfTeX; if not, write to the Free Software Foundation, Inc., 59 Temple
-Place, Suite 330, Boston, MA  02111-1307  USA
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
 pdfTeX uses code from TeX; for these parts the original copyright by Don
 Knuth applies. See the source files for details.
@@ -69,10 +69,11 @@
 ============
 
 Peter Breitenlohner, Ricardo Sanchez Carmenes, Otfried Cheong, Thomas
-Esser, Hans Hagen, Hartmut Henkel, Taco Hoekwater, Pawel Jackowski, Tom
-Kacvinsky, Akira Kakuto, Reinhard Kotucha, Derek B. Noonburg, Heiko
-Oberdiek, Jiri Osoba, Fabrice Popineau, Sebastian Rahtz, Tomas Rokicki,
-Martin Schrder, Petr Sojka, Ralf Utermann, Olaf Weber, Jiri Zlatuska.
+Esser, Hans Hagen, Hartmut Henkel, Taco Hoekwater, Pawel Jackowski, Pavel
+Janik, Tom Kacvinsky, Akira Kakuto, Reinhard Kotucha, Derek B. Noonburg,
+Heiko Oberdiek, Jiri Osoba, Fabrice Popineau, Sebastian Rahtz, Bernd
+Raichle, Tomas Rokicki, Martin Schrder, Petr Sojka, Ralf Utermann, Olaf
+Weber, Jiri Zlatuska.
 
 pdfTeX is built on top of TeX, written by Donald Knuth cum suis (Liang and
 so), and eTeX, written by Peter Breitenlohner cum suis; part of the
@@ -83,5 +84,5 @@
 
 Please send bug reports, offers of help, etc. to martin@pdftex.org
 
-$Id: //depot/Build/source.development/TeX/texk/web2c/pdftexdir/README#30 $
+$Id: README 217 2007-07-31 16:55:39Z oneiros $
 // vim: tw=75
--- tetex-src-3.0/texk/web2c/pdftexdir/pdftexextra.in.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/pdftexextra.in	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2004 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: pdftexextra.in,v 1.4 2004/08/26 18:19:57 olaf Exp $
+$Id: pdftexextra.in 217 2007-07-31 16:55:39Z oneiros $
 */
 
 /* pdftexextra.in: banner etc. for pdfTeX.
--- tetex-src-3.0/texk/web2c/pdftexdir/writettf.c.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/writettf.c	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2006 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: //depot/Build/source.development/TeX/texk/web2c/pdftexdir/writettf.c#16 $
+$Id: writettf.c 217 2007-07-31 16:55:39Z oneiros $
 */
 
 #include "ptexlib.h"
@@ -44,15 +44,15 @@
     TTF_LONG newoffset;
     TTF_UFWORD advWidth;
     TTF_FWORD lsb;
-    char *name;              /* name of glyph */
-    TTF_SHORT newindex;      /* new index of glyph in output file */
-    TTF_USHORT name_index;   /* index of name as read from font file */
+    char *name;                 /* name of glyph */
+    TTF_SHORT newindex;         /* new index of glyph in output file */
+    TTF_USHORT name_index;      /* index of name as read from font file */
 } glyph_entry;
 
 typedef struct {
-    char *name;             /* name of glyph */
+    char *name;                 /* name of glyph */
     long code;                  /* charcode in case of subfonts */
-    short newindex;         /* new index of glyph in output file */
+    short newindex;             /* new index of glyph in output file */
 
 } ttfenc_entry;
 
@@ -179,7 +179,7 @@
 static TTF_ULONG ttf_getchksm(void)
 {
     while (tab_length % 4 != 0)
-        ttf_putchar(ttf_addchksm(0)); /* ttf_addchksm updates tab_length */
+        ttf_putchar(ttf_addchksm(0));   /* ttf_addchksm updates tab_length */
     return checksum;
 }
 
@@ -213,9 +213,9 @@
 static long ttf_funit(long n)
 {
     if (n < 0)
-        return -((-n/upem)*1000 + ((-n%upem)*1000)/upem);
+        return -((-n / upem) * 1000 + ((-n % upem) * 1000) / upem);
     else
-        return (n/upem)*1000 + ((n%upem)*1000)/upem;
+        return (n / upem) * 1000 + ((n % upem) * 1000) / upem;
 }
 
 static void ttf_ncopy(int n)
@@ -302,14 +302,16 @@
             e = ttfenc_tab + *q;
             e->code = charcodes[*q];
             if (e->code == -1)
-                pdftex_warn("character %i is not mapped to any charcode", *q);
+                pdftex_warn
+                    ("character %i in subfont %s is not mapped to any charcode",
+                     *q, fd_cur->fm->tfm_name);
             else {
                 assert(e->code < 0x10000);
                 sprintf(buf, "/c%4.4X", (int) e->code);
                 aa = avl_probe(fd_cur->gl_tree, xstrdup(buf));
                 assert(aa != NULL);
             }
-    }
+        }
         make_subset_tag(fd_cur);
     } else
         assert(0);
@@ -348,8 +350,8 @@
     char *p;
     name_record_num = get_ushort();
     name_tab = xtalloc(name_record_num, name_record);
-    name_buf_size = tab->length - 
-         (3*TTF_USHORT_SIZE + name_record_num*6*TTF_USHORT_SIZE);
+    name_buf_size = tab->length -
+        (3 * TTF_USHORT_SIZE + name_record_num * 6 * TTF_USHORT_SIZE);
     name_buf = xtalloc(name_buf_size, char);
     ttf_skip(TTF_USHORT_SIZE);
     for (i = 0; i < name_record_num; i++) {
@@ -361,10 +363,10 @@
         name_tab[i].offset = get_ushort();
     }
     for (p = name_buf; p - name_buf < name_buf_size; p++)
-         *p = get_char();
+        *p = get_char();
     /* look for PS font name */
     for (i = 0; i < name_record_num; i++) {
-        if (name_tab[i].platform_id == 1 && 
+        if (name_tab[i].platform_id == 1 &&
             name_tab[i].encoding_id == 0 && name_tab[i].name_id == 6) {
             xfree(fd_cur->fontname);
             fd_cur->fontname =
@@ -376,8 +378,8 @@
     }
     if (!fd_cur->font_dim[FONTNAME_CODE].set) {
         for (i = 0; i < name_record_num; i++) {
-            if (name_tab[i].platform_id == 3 && 
-                (name_tab[i].encoding_id == 0 || 
+            if (name_tab[i].platform_id == 3 &&
+                (name_tab[i].encoding_id == 0 ||
                  name_tab[i].encoding_id == 1) && name_tab[i].name_id == 6) {
                 for (j = 0, p = fd_cur->fontname; j < name_tab[i].length;
                      j += 2)
@@ -399,11 +401,11 @@
         glyph->newindex = -1;
         glyph->newoffset = 0;
         glyph->name_index = 0;
-        glyph->name = (char*) notdef;
+        glyph->name = (char *) notdef;
     }
     glyph_index = xtalloc(glyphs_count, long);
-    glyph_index[0] = 0; /* index of ".notdef" glyph */
-    glyph_index[1] = 1; /* index of ".null" glyph */
+    glyph_index[0] = 0;         /* index of ".notdef" glyph */
+    glyph_index[1] = 1;         /* index of ".null" glyph */
 }
 
 static void ttf_read_head(void)
@@ -420,7 +422,7 @@
     fd_cur->font_dim[FONTBBOX2_CODE].set = true;
     fd_cur->font_dim[FONTBBOX3_CODE].set = true;
     fd_cur->font_dim[FONTBBOX4_CODE].set = true;
-    ttf_skip(2*TTF_USHORT_SIZE + TTF_SHORT_SIZE);
+    ttf_skip(2 * TTF_USHORT_SIZE + TTF_SHORT_SIZE);
     loca_format = get_short();
 }
 
@@ -442,7 +444,7 @@
         return;
     ttf_seek_tab("PCLT", TTF_FIXED_SIZE + TTF_ULONG_SIZE + TTF_USHORT_SIZE);
     fd_cur->font_dim[XHEIGHT_CODE].val = ttf_funit(get_ushort());
-    ttf_skip(2*TTF_USHORT_SIZE);
+    ttf_skip(2 * TTF_USHORT_SIZE);
     fd_cur->font_dim[CAPHEIGHT_CODE].val = ttf_funit(get_ushort());
     fd_cur->font_dim[XHEIGHT_CODE].set = true;
     fd_cur->font_dim[CAPHEIGHT_CODE].set = true;
@@ -459,7 +461,7 @@
     }
     if (nhmtxs < glyphs_count) {
         last_advWidth = glyph[-1].advWidth;
-        for (;glyph - glyph_tab <  glyphs_count; glyph++) {
+        for (; glyph - glyph_tab < glyphs_count; glyph++) {
             glyph->advWidth = last_advWidth;
             glyph->lsb = get_ufword();
         }
@@ -479,7 +481,7 @@
     post_format = get_fixed();
     italic_angle = get_fixed();
     int_part = italic_angle >> 16;
-    if (int_part > 0x7FFF) { /* a negative number */
+    if (int_part > 0x7FFF) {    /* a negative number */
         int_part = 0x10000 - int_part;
         sign = -1;
     }
@@ -488,17 +490,17 @@
         sign * (int_part + frac_part * 1.0 / 0x10000);
     fd_cur->font_dim[ITALIC_ANGLE_CODE].set = true;
     if (glyph_tab == NULL)
-        return; /* being called from writeotf() */
-    ttf_skip(2*TTF_FWORD_SIZE + 5*TTF_ULONG_SIZE);
+        return;                 /* being called from writeotf() */
+    ttf_skip(2 * TTF_FWORD_SIZE + 5 * TTF_ULONG_SIZE);
     switch (post_format) {
     case 0x10000:
         for (glyph = glyph_tab; glyph - glyph_tab < NMACGLYPHS; glyph++) {
-            glyph->name = (char*)mac_glyph_names[glyph - glyph_tab];
+            glyph->name = (char *) mac_glyph_names[glyph - glyph_tab];
             glyph->name_index = glyph - glyph_tab;
         }
         break;
     case 0x20000:
-        nnames = get_ushort(); /* some fonts have this value different from nglyphs */
+        nnames = get_ushort();  /* some fonts have this value different from nglyphs */
         for (glyph = glyph_tab; glyph - glyph_tab < nnames; glyph++)
             glyph->name_index = get_ushort();
         length = tab->length - (xftell(INFILE, cur_file_name) - tab->offset);
@@ -510,7 +512,7 @@
         }
         for (glyph = glyph_tab; glyph - glyph_tab < nnames; glyph++) {
             if (glyph->name_index < NMACGLYPHS)
-                glyph->name = (char*)mac_glyph_names[glyph->name_index];
+                glyph->name = (char *) mac_glyph_names[glyph->name_index];
             else {
                 p = glyph_name_buf;
                 k = glyph->name_index - NMACGLYPHS;
@@ -547,9 +549,9 @@
 {
     int i;
     dirtab_entry *tab;
-    ttf_skip(TTF_FIXED_SIZE); /* ignore the sfnt number */
+    ttf_skip(TTF_FIXED_SIZE);   /* ignore the sfnt number */
     dir_tab = xtalloc(ntabs = get_ushort(), dirtab_entry);
-    ttf_skip(3*TTF_USHORT_SIZE);
+    ttf_skip(3 * TTF_USHORT_SIZE);
     for (tab = dir_tab; tab - dir_tab < ntabs; tab++) {
         for (i = 0; i < 4; i++)
             tab->tag[i] = get_char();
@@ -583,9 +585,9 @@
         return p;
 
     /* not found, have to read it */
-    ttf_seek_tab("cmap", TTF_USHORT_SIZE); /* skip the table vesrion number (=0) */
+    ttf_seek_tab("cmap", TTF_USHORT_SIZE);      /* skip the table vesrion number (=0) */
     ncmapsubtabs = get_ushort();
-    cmap_offset = xftell(INFILE, cur_file_name) - 2*TTF_USHORT_SIZE;
+    cmap_offset = xftell(INFILE, cur_file_name) - 2 * TTF_USHORT_SIZE;
     cmap_tab = xtalloc(ncmapsubtabs, cmap_entry);
     for (i = 0; i < ncmapsubtabs; ++i) {
         tmp_pid = get_ushort();
@@ -593,14 +595,14 @@
         tmp_offset = get_ulong();
         if (tmp_pid == pid && tmp_eid == eid) {
             ttf_seek_off(cmap_offset + tmp_offset);
-        format = get_ushort();
+            format = get_ushort();
             if (format == 4)
                 goto read_cmap_format_4;
             else {
                 if (warn)
                     pdftex_warn("cmap format %i unsupported", format);
                 return NULL;
-        }
+            }
         }
     }
     if (warn)
@@ -618,57 +620,57 @@
         p->table[i] = -1;       /* unassigned yet */
 
     /* read the subtable */
-        length = get_ushort(); /* length of subtable */
+    length = get_ushort();      /* length of subtable */
     (void) get_ushort();        /* skip the version number */
-        segCount = get_ushort()/2;
+    segCount = get_ushort() / 2;
     (void) get_ushort();        /* skip searchRange */
     (void) get_ushort();        /* skip entrySelector */
     (void) get_ushort();        /* skip rangeShift */
-        seg_tab = xtalloc(segCount, seg_entry);
-        for (s = seg_tab; s - seg_tab < segCount; s++)
-            s->endCode = get_ushort();
+    seg_tab = xtalloc(segCount, seg_entry);
+    for (s = seg_tab; s - seg_tab < segCount; s++)
+        s->endCode = get_ushort();
     (void) get_ushort();        /* skip reversedPad */
-        for (s = seg_tab; s - seg_tab < segCount; s++)
-            s->startCode = get_ushort();
-        for (s = seg_tab; s - seg_tab < segCount; s++)
-            s->idDelta = get_ushort();
-        for (s = seg_tab; s - seg_tab < segCount; s++)
-            s->idRangeOffset = get_ushort();
-        length -= 8*TTF_USHORT_SIZE + 4*segCount*TTF_USHORT_SIZE;
-        n = length/TTF_USHORT_SIZE; /* number of glyphID's */
-        glyphId = xtalloc(n, TTF_USHORT);
-        for (i = 0; i < n; i++)
-            glyphId[i] = get_ushort();
-        for (s = seg_tab; s - seg_tab < segCount; s++) {
-            for (i = s->startCode; i <= s->endCode; i++) {
-                if (i == 0xFFFF)
-                    break;
-                if (s->idRangeOffset != 0xFFFF) {
-                    if (s->idRangeOffset == 0)
-                        index = (s->idDelta + i) & 0xFFFF;
-                    else {
-                        k = (i - s->startCode) + s->idRangeOffset/2 + 
-                            (s - seg_tab) - segCount ;
-                        assert(k >= 0 && k < n);
-                        index = glyphId[k];
-                        if (index != 0)
-                            index = (index + s->idDelta) & 0xFFFF;
-                    }
-                    if (index >= glyphs_count)
+    for (s = seg_tab; s - seg_tab < segCount; s++)
+        s->startCode = get_ushort();
+    for (s = seg_tab; s - seg_tab < segCount; s++)
+        s->idDelta = get_ushort();
+    for (s = seg_tab; s - seg_tab < segCount; s++)
+        s->idRangeOffset = get_ushort();
+    length -= 8 * TTF_USHORT_SIZE + 4 * segCount * TTF_USHORT_SIZE;
+    n = length / TTF_USHORT_SIZE;       /* number of glyphID's */
+    glyphId = xtalloc(n, TTF_USHORT);
+    for (i = 0; i < n; i++)
+        glyphId[i] = get_ushort();
+    for (s = seg_tab; s - seg_tab < segCount; s++) {
+        for (i = s->startCode; i <= s->endCode; i++) {
+            if (i == 0xFFFF)
+                break;
+            if (s->idRangeOffset != 0xFFFF) {
+                if (s->idRangeOffset == 0)
+                    index = (s->idDelta + i) & 0xFFFF;
+                else {
+                    k = (i - s->startCode) + s->idRangeOffset / 2 +
+                        (s - seg_tab) - segCount;
+                    assert(k >= 0 && k < n);
+                    index = glyphId[k];
+                    if (index != 0)
+                        index = (index + s->idDelta) & 0xFFFF;
+                }
+                if (index >= glyphs_count)
                     pdftex_fail("cmap: glyph index %li out of range [0..%i)",
-                                    index, glyphs_count);
+                                index, glyphs_count);
                 if (p->table[i] != -1)
                     pdftex_warn
                         ("cmap: multiple glyphs are mapped to unicode %.4lX, "
                          "only %i will be used (glyph %li being ignored)", i,
                          p->table[i], index);
-                    else
+                else
                     p->table[i] = index;
-                }
             }
         }
-        xfree(seg_tab);
-        xfree(glyphId);
+    }
+    xfree(seg_tab);
+    xfree(glyphId);
     aa = avl_probe(ttf_cmap_tree, p);
     assert(aa != NULL);
     return p;
@@ -695,7 +697,7 @@
     ttf_read_name();
 }
 
-static void ttf_reset_chksm(dirtab_entry *tab)
+static void ttf_reset_chksm(dirtab_entry * tab)
 {
     checksum = 0;
     tab_length = 0;
@@ -706,7 +708,7 @@
 }
 
 
-static void ttf_set_chksm(dirtab_entry *tab)
+static void ttf_set_chksm(dirtab_entry * tab)
 {
     tab->length = ttf_offset() - tab->offset;
     tab->checksum = ttf_getchksm();
@@ -738,8 +740,8 @@
             if (e->name != notdef)
                 pdftex_warn
                     ("glyph `%s' has been mapped to `%s' in `ttf_byte_encoding' cmap table",
-                            e->name, notdef);
-            put_byte(0); /* notdef */
+                     e->name, notdef);
+            put_byte(0);        /* notdef */
         }
 }
 
@@ -786,14 +788,14 @@
 
 static void ttf_select_cmap(void)
 {
-    assert(sizeof(new_cmap_tab) <= NEW_CMAP_SIZE*sizeof(cmap_entry));
-    new_cmap_tab[0].platform_id  = 1; /* Macintosh */
-    new_cmap_tab[0].encoding_id  = 0; /* Symbol; ignore code page */
-    new_cmap_tab[0].format = new_glyphs_count < 256 ? 0  /* byte encoding */
-                                                : 6; /* trimmed table mapping */
-    new_cmap_tab[1].platform_id  = 3; /* Microsoft */
-    new_cmap_tab[1].encoding_id  = 0; /* Symbol; ignore code page */
-    new_cmap_tab[1].format       = 4; /* segment mapping to delta */
+    assert(sizeof(new_cmap_tab) <= NEW_CMAP_SIZE * sizeof(cmap_entry));
+    new_cmap_tab[0].platform_id = 1;    /* Macintosh */
+    new_cmap_tab[0].encoding_id = 0;    /* Symbol; ignore code page */
+    new_cmap_tab[0].format = new_glyphs_count < 256 ? 0 /* byte encoding */
+        : 6;                    /* trimmed table mapping */
+    new_cmap_tab[1].platform_id = 3;    /* Microsoft */
+    new_cmap_tab[1].encoding_id = 0;    /* Symbol; ignore code page */
+    new_cmap_tab[1].format = 4; /* segment mapping to delta */
 }
 
 static void ttf_write_cmap(void)
@@ -805,18 +807,18 @@
     ttf_reset_chksm(tab);
     (void) put_ushort(0);       /* table version number (0) */
     (void) put_ushort(NEW_CMAP_SIZE);   /* number of encoding tables */
-    offset = 2*TTF_USHORT_SIZE + NEW_CMAP_SIZE*CMAP_ENTRY_LENGTH;
+    offset = 2 * TTF_USHORT_SIZE + NEW_CMAP_SIZE * CMAP_ENTRY_LENGTH;
     for (ce = new_cmap_tab; ce - new_cmap_tab < NEW_CMAP_SIZE; ce++) {
         ce->offset = offset;
         switch (ce->format) {
-        case 0: 
-            offset +=  BYTE_ENCODING_LENGTH;
+        case 0:
+            offset += BYTE_ENCODING_LENGTH;
             break;
-        case 4: 
-            offset +=  SEG_MAP_DELTA_LENGTH;
+        case 4:
+            offset += SEG_MAP_DELTA_LENGTH;
             break;
-        case 6: 
-            offset +=  TRIMMED_TABLE_MAP_LENGTH;
+        case 6:
+            offset += TRIMMED_TABLE_MAP_LENGTH;
             break;
         default:
             pdftex_fail("invalid format (it should not have happened)");
@@ -827,13 +829,13 @@
     }
     for (ce = new_cmap_tab; ce - new_cmap_tab < NEW_CMAP_SIZE; ce++) {
         switch (ce->format) {
-        case 0: 
+        case 0:
             ttf_byte_encoding();
             break;
-        case 4: 
+        case 4:
             ttf_seg_map_delta();
             break;
-        case 6: 
+        case 6:
             ttf_trimmed_table_map();
             break;
         }
@@ -874,7 +876,7 @@
     if (is_subsetted(fd_cur->fm)) {
         l = 0;
         for (i = 0; i < name_record_num; i++)
-            l += name_tab[i].length + 14; /* maximum lengh of new stogare area */
+            l += name_tab[i].length + 14;       /* maximum lengh of new stogare area */
         new_name_buf = xtalloc(l, char);
         /* additional space for subset tags */
         p = new_name_buf;
@@ -913,7 +915,7 @@
         (void) put_ushort(name_tab[i].new_offset);
     }
     for (p = new_name_buf; p - new_name_buf < new_name_buf_size; p++)
-         put_char(*p);
+        put_char(*p);
     ttf_set_chksm(tab);
     if (new_name_buf != name_buf)
         xfree(new_name_buf);
@@ -932,7 +934,7 @@
             if (tab == NULL)
                 continue;
             for (k = 0; k < 4; k++)
-               put_char(tab->tag[k]);
+                put_char(tab->tag[k]);
             put_ulong(tab->checksum);
             put_ulong(tab->offset);
             put_ulong(tab->length);
@@ -940,7 +942,7 @@
     } else {
         for (tab = dir_tab; tab - dir_tab < ntabs; tab++) {
             for (k = 0; k < 4; k++)
-               put_char(tab->tag[k]);
+                put_char(tab->tag[k]);
             put_ulong(tab->checksum);
             put_ulong(tab->offset);
             put_ulong(tab->length);
@@ -959,7 +961,7 @@
     }
     if (i % 4 != 0) {
         pdftex_warn("font length is not a multiple of 4 (%li)", i);
-        checksum <<= 8*(4 - i % 4);
+        checksum <<= 8 * (4 - i % 4);
     }
     k = 0xB1B0AFBA - checksum;
     ttf_seek_outbuf(checkSumAdjustment_offset);
@@ -981,7 +983,7 @@
         if (glyph_tab[*id].offset != glyph_tab[*id + 1].offset) {
             ttf_seek_off(glyf_offset + glyph_tab[*id].offset);
             k = copy_short();
-            ttf_ncopy(4*TTF_FWORD_SIZE);
+            ttf_ncopy(4 * TTF_FWORD_SIZE);
             if (k < 0) {
                 do {
                     flags = copy_ushort();
@@ -989,28 +991,28 @@
                     if (glyph_tab[idx].newindex < 0) {
                         glyph_tab[idx].newindex = new_glyphs_count;
                         glyph_index[new_glyphs_count++] = idx;
-                        /* 
-                            N.B.: Here we change `new_glyphs_count',
-                            which appears in the condition of the `for' loop
-                        */
+                        /*
+                           N.B.: Here we change `new_glyphs_count',
+                           which appears in the condition of the `for' loop
+                         */
                     }
                     (void) put_ushort(glyph_tab[idx].newindex);
                     if (flags & ARG_1_AND_2_ARE_WORDS)
-                        ttf_ncopy(2*TTF_SHORT_SIZE);
+                        ttf_ncopy(2 * TTF_SHORT_SIZE);
                     else
                         ttf_ncopy(TTF_USHORT_SIZE);
                     if (flags & WE_HAVE_A_SCALE)
                         ttf_ncopy(TTF_F2DOT14_SIZE);
                     else if (flags & WE_HAVE_AN_X_AND_Y_SCALE)
-                        ttf_ncopy(2*TTF_F2DOT14_SIZE);
+                        ttf_ncopy(2 * TTF_F2DOT14_SIZE);
                     else if (flags & WE_HAVE_A_TWO_BY_TWO)
-                        ttf_ncopy(4*TTF_F2DOT14_SIZE);
+                        ttf_ncopy(4 * TTF_F2DOT14_SIZE);
                 } while (flags & MORE_COMPONENTS);
                 if (flags & WE_HAVE_INSTRUCTIONS)
                     ttf_ncopy(copy_ushort());
             } else
-                ttf_ncopy(glyph_tab[*id + 1].offset - glyph_tab[*id].offset - 
-                    TTF_USHORT_SIZE - 4*TTF_FWORD_SIZE);
+                ttf_ncopy(glyph_tab[*id + 1].offset - glyph_tab[*id].offset -
+                          TTF_USHORT_SIZE - 4 * TTF_FWORD_SIZE);
         }
     }
     last_glyf_offset = ttf_offset() - new_glyf_offset;
@@ -1026,14 +1028,14 @@
     ttf_cmap_entry *cmap = NULL;
     boolean cmap_not_found = false;
 
-    /* 
+    /*
      * reindexing glyphs: we append index of used glyphs to `glyph_index'
      * while going through `ttfenc_tab'. After appending a new entry to
      * `glyph_index' we set field `newindex' of corresponding entries in both
      * `glyph_tab' and `ttfenc_tab' to the newly created index
      */
     for (e = ttfenc_tab; e - ttfenc_tab < 256; e++) {
-        e->newindex = 0; /* index of ".notdef" glyph */
+        e->newindex = 0;        /* index of ".notdef" glyph */
 
         /* handle case of subfonts first */
         if (is_subfont(fd_cur->fm)) {
@@ -1066,7 +1068,7 @@
         if (e->name == notdef)
             continue;
         /* scan form `index123' */
-        if (sscanf(e->name,  GLYPH_PREFIX_INDEX "%i", &index) == 1) {
+        if (sscanf(e->name, GLYPH_PREFIX_INDEX "%i", &index) == 1) {
             if (index >= glyphs_count) {
                 pdftex_warn("`%s' out of valid range [0..%i)",
                             e->name, glyphs_count);
@@ -1102,7 +1104,7 @@
                 glyph = glyph_tab + t[index];
                 goto append_new_glyph;
             } else {
-                pdftex_warn("`unicode %s%.4X' is not mapped to any glyph", 
+                pdftex_warn("`unicode %s%.4X' is not mapped to any glyph",
                             GLYPH_PREFIX_UNICODE, index);
                 continue;
             }
@@ -1115,7 +1117,7 @@
             pdftex_warn("glyph `%s' not found", e->name);
             continue;
         }
-append_new_glyph:
+      append_new_glyph:
         assert(glyph > glyph_tab && glyph - glyph_tab < glyphs_count);
         if (glyph->newindex < 0) {
             glyph_index[new_glyphs_count] = glyph - glyph_tab;
@@ -1125,26 +1127,26 @@
         e->newindex = glyph->newindex;
     }
 }
- 
+
 static void ttf_write_head()
 {
     dirtab_entry *tab;
     tab = ttf_seek_tab("head", 0);
     ttf_reset_chksm(tab);
-    ttf_ncopy(2*TTF_FIXED_SIZE);
+    ttf_ncopy(2 * TTF_FIXED_SIZE);
     checkSumAdjustment_offset = ttf_offset();
     put_ulong(0);
-    ttf_skip(TTF_ULONG_SIZE); /* skip checkSumAdjustment */
-    ttf_ncopy(TTF_ULONG_SIZE + 2*TTF_USHORT_SIZE + 16 + 
-        4*TTF_FWORD_SIZE + 2*TTF_USHORT_SIZE + TTF_SHORT_SIZE);
+    ttf_skip(TTF_ULONG_SIZE);   /* skip checkSumAdjustment */
+    ttf_ncopy(TTF_ULONG_SIZE + 2 * TTF_USHORT_SIZE + 16 +
+              4 * TTF_FWORD_SIZE + 2 * TTF_USHORT_SIZE + TTF_SHORT_SIZE);
     if (is_subsetted(fd_cur->fm)) {
         (void) put_short(loca_format);
         (void) put_short(0);
     } else
-        ttf_ncopy(2*TTF_SHORT_SIZE);
+        ttf_ncopy(2 * TTF_SHORT_SIZE);
     ttf_set_chksm(tab);
 }
- 
+
 static void ttf_write_hhea(void)
 {
     dirtab_entry *tab;
@@ -1200,7 +1202,7 @@
     ttf_reset_chksm(tab);
     put_fixed(0x00010000);
     (void) put_ushort(new_glyphs_count);
-    ttf_ncopy(13*TTF_USHORT_SIZE);
+    ttf_ncopy(13 * TTF_USHORT_SIZE);
     ttf_set_chksm(tab);
 }
 
@@ -1213,19 +1215,19 @@
     if (version > 3)
         pdftex_fail("unknown version of OS/2 table (%.4X)", version);
     (void) put_ushort(0x0001);  /* fix version to 1 */
-    ttf_ncopy(2*TTF_USHORT_SIZE + 13*TTF_SHORT_SIZE + 10*TTF_BYTE_SIZE);
-    ttf_skip(4*TTF_ULONG_SIZE); /* ulUnicodeRange 1--4 */
-    put_ulong(0x00000003); /* Basic Latin + Latin-1 Supplement (0x0000--0x00FF) */
-    put_ulong(0x10000000); /* Private Use (0xE000--0xF8FF) */
+    ttf_ncopy(2 * TTF_USHORT_SIZE + 13 * TTF_SHORT_SIZE + 10 * TTF_BYTE_SIZE);
+    ttf_skip(4 * TTF_ULONG_SIZE);       /* ulUnicodeRange 1--4 */
+    put_ulong(0x00000003);      /* Basic Latin + Latin-1 Supplement (0x0000--0x00FF) */
+    put_ulong(0x10000000);      /* Private Use (0xE000--0xF8FF) */
     put_ulong(0x00000000);
     put_ulong(0x00000000);
-    ttf_ncopy(4*TTF_CHAR_SIZE + TTF_USHORT_SIZE); /* achVendID + fsSelection */
-    ttf_skip(2*TTF_USHORT_SIZE);
+    ttf_ncopy(4 * TTF_CHAR_SIZE + TTF_USHORT_SIZE);     /* achVendID + fsSelection */
+    ttf_skip(2 * TTF_USHORT_SIZE);
     (void) put_ushort(0x0000);  /* usFirstCharIndex */
     (void) put_ushort(0xF0FF);  /* usLastCharIndex */
-    ttf_ncopy(5*TTF_USHORT_SIZE);
-    /* for version 0 the OS/2 table ends here, the rest is for version 1 */ 
-    put_ulong(0x80000000); /* Symbol Character Set---don't use any code page */
+    ttf_ncopy(5 * TTF_USHORT_SIZE);
+    /* for version 0 the OS/2 table ends here, the rest is for version 1 */
+    put_ulong(0x80000000);      /* Symbol Character Set---don't use any code page */
     put_ulong(0x00000000);
     ttf_set_chksm(tab);
 }
@@ -1249,10 +1251,10 @@
     ttf_reset_chksm(tab);
     if (!fd_cur->write_ttf_glyph_names || post_format == 0x00030000) {
         put_fixed(0x00030000);
-        ttf_ncopy(TTF_FIXED_SIZE + 2*TTF_FWORD_SIZE + 5*TTF_ULONG_SIZE);
+        ttf_ncopy(TTF_FIXED_SIZE + 2 * TTF_FWORD_SIZE + 5 * TTF_ULONG_SIZE);
     } else {
         put_fixed(0x00020000);
-        ttf_ncopy(TTF_FIXED_SIZE + 2*TTF_FWORD_SIZE + 5*TTF_ULONG_SIZE);
+        ttf_ncopy(TTF_FIXED_SIZE + 2 * TTF_FWORD_SIZE + 5 * TTF_ULONG_SIZE);
         (void) put_ushort(new_glyphs_count);
         k = 0;
         for (id = glyph_index; id - glyph_index < new_glyphs_count; id++) {
@@ -1279,12 +1281,12 @@
 {
     int i, k;
     for (i = 1, k = 0; i <= n; i <<= 1, k++);
-    put_fixed(0x00010000); /* font version */
+    put_fixed(0x00010000);      /* font version */
     (void) put_ushort(n);       /* number of tables */
     (void) put_ushort(i << 3);  /* search range */
     (void) put_ushort(k - 1);   /* entry selector */
     (void) put_ushort((n << 4) - (i << 3));     /* range shift */
-    ttf_seek_outbuf(TABDIR_OFF + n*4*TTF_ULONG_SIZE);
+    ttf_seek_outbuf(TABDIR_OFF + n * 4 * TTF_ULONG_SIZE);
 }
 
 static void ttf_subset_font(void)
@@ -1335,14 +1337,12 @@
     set_cur_file_name(fd_cur->fm->ff_name);
     if (is_subsetted(fd_cur->fm) && (fd_cur->fe == NULL)
         && !is_subfont(fd_cur->fm)) {
-        pdftex_warn("Subset TrueType must be a reencoded or a subfont");
-        cur_file_name = NULL;
-        return;
+        pdftex_fail("Subset TrueType must be a reencoded or a subfont");
     }
     if (!ttf_open()) {
         pdftex_fail("cannot open TrueType font file for reading");
     }
-    cur_file_name = (char*)nameoffile + 1;
+    cur_file_name = (char *) nameoffile + 1;
     if (is_subsetted(fd_cur->fm))
         tex_printf("<%s", cur_file_name);
     else
@@ -1358,14 +1358,14 @@
     name_buf = NULL;
     ttf_read_font();
 
-        pdfsaveoffset = pdfoffset();
-        pdfflush();
+    pdfsaveoffset = pdfoffset();
+    pdfflush();
     if (is_subsetted(fd_cur->fm)) {
-            ttf_copy_encoding();
-            ttf_subset_font();
+        ttf_copy_encoding();
+        ttf_subset_font();
     } else
-            ttf_copy_font();
-        ttf_length = ttf_offset();
+        ttf_copy_font();
+    ttf_length = ttf_offset();
 
     xfree(dir_tab);
     xfree(glyph_tab);
@@ -1397,7 +1397,7 @@
     if (!open_input(&ttf_file, kpse_opentype_format, FOPEN_RBIN_MODE)) {
         pdftex_fail("cannot open OpenType font file for reading");
     }
-    cur_file_name = (char*)nameoffile + 1;
+    cur_file_name = (char *) nameoffile + 1;
     tex_printf("<<%s", cur_file_name);
     fd_cur->ff_found = true;
     dir_tab = NULL;
--- tetex-src-3.0/texk/web2c/pdftexdir/pkin.c.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/pkin.c	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2002 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: //depot/Build/source.development/TeX/texk/web2c/pdftexdir/pkin.c#4 $
+$Id: pkin.c 217 2007-07-31 16:55:39Z oneiros $
 */
 
 /*
@@ -26,10 +26,10 @@
  * DESCRIPTION
  * This implementation of readchar() uses parts of the program dvips
  * written by Tomas Rokicki--the inventor of the pkformat--(loadfont.c,
- * download.c and unpack.c). Dvips in turn is derived from pktype. 
- * Pktype(TeX) is described in debt in ``The PKtype processor'', 
+ * download.c and unpack.c). Dvips in turn is derived from pktype.
+ * Pktype(TeX) is described in debt in ``The PKtype processor'',
  * which is available as pktype.weave as part of the METAFONTware.
- * What was needed to implement readchar() is rearranged in pkfile.c to 
+ * What was needed to implement readchar() is rearranged in pkfile.c to
  * get more modularity in the style of MODULA2.
  * BUGFIXES
  *      May 1997: Eric Delaunay <delaunay@lix.polytechnique.fr> reports a
@@ -60,47 +60,47 @@
 
 static shalfword pkbyte(void)
 {
-   register shalfword i ;
+    register shalfword i;
 
-   if ((i=xgetc(pkfile))==EOF)
-      pdftex_fail("unexpected eof in pk file") ;
-   return(i) ;
+    if ((i = xgetc(pkfile)) == EOF)
+        pdftex_fail("unexpected eof in pk file");
+    return (i);
 }
 
 static integer pkduo(void)
 {
-    register integer i ;
+    register integer i;
 
-    i = pkbyte() ;
+    i = pkbyte();
     if (i > 127)
-        i -= 256 ;
-    i = i * 256 + pkbyte() ;
-    return(i) ;
+        i -= 256;
+    i = i * 256 + pkbyte();
+    return (i);
 }
 
 static integer pktrio(void)
 {
-   register integer i ;
+    register integer i;
 
-   i = pkbyte() ;
-   if (i > 127)
-      i -= 256 ;
-   i = i * 256 + pkbyte() ;
-   i = i * 256 + pkbyte() ;
-   return(i) ;
+    i = pkbyte();
+    if (i > 127)
+        i -= 256;
+    i = i * 256 + pkbyte();
+    i = i * 256 + pkbyte();
+    return (i);
 }
 
 static integer pkquad(void)
 {
-   register integer i ;
+    register integer i;
 
-   i = pkbyte() ;
-   if (i > 127)
-      i -= 256 ;
-   i = i * 256 + pkbyte() ;
-   i = i * 256 + pkbyte() ;
-   i = i * 256 + pkbyte() ;
-   return(i) ;
+    i = pkbyte();
+    if (i > 127)
+        i -= 256;
+    i = i * 256 + pkbyte();
+    i = i * 256 + pkbyte();
+    i = i * 256 + pkbyte();
+    return (i);
 }
 
 /*
@@ -112,61 +112,61 @@
  *   packed data structure.
  */
 
-static halfword inputbyte, flagbyte ; 
-static halfword bitweight ; 
-static halfword dynf ;
-static halfword repeatcount ;
+static halfword inputbyte, flagbyte;
+static halfword bitweight;
+static halfword dynf;
+static halfword repeatcount;
 
 static shalfword getnyb(void)
 {
     halfword temp;
     if (bitweight == 0) {
         bitweight = 16;
-      inputbyte = pkbyte();
-      temp = inputbyte >> 4 ;
+        inputbyte = pkbyte();
+        temp = inputbyte >> 4;
     } else {
-      bitweight = 0 ;
-      temp = inputbyte & 15 ;
+        bitweight = 0;
+        temp = inputbyte & 15;
     }
-    return(temp);
-} 
+    return (temp);
+}
 
 static boolean getbit(void)
 {
-    bitweight >>= 1 ; 
+    bitweight >>= 1;
     if (bitweight == 0) {
         inputbyte = pkbyte();
-      bitweight = 128 ;
-    } 
-    return(inputbyte & bitweight) ;
+        bitweight = 128;
+    }
+    return (inputbyte & bitweight);
 }
 
-static halfword (*realfunc)(void) ;
-long pk_remainder ;
-static halfword handlehuge(halfword i, halfword  k);
+static halfword(*realfunc) (void);
+long pk_remainder;
+static halfword handlehuge(halfword i, halfword k);
 
 static halfword pkpackednum(void)
 {
-register halfword i, j ; 
-    i = getnyb () ; 
+    register halfword i, j;
+    i = getnyb();
     if (i == 0) {
         do {
             j = getnyb();
-        i++ ; 
-        } while ( ! ( j != 0 ) ) ; 
-      if ( i > 3 ) {
+            i++;
+        } while (!(j != 0));
+        if (i > 3) {
 /*
  *   Damn, we got a huge count!  We *fake* it by giving an artificially
  *   large repeat count.
  */
-         return(handlehuge(i, j)) ;
-      } else {
+            return (handlehuge(i, j));
+        } else {
             while (i > 0) {
                 j = j * 16 + getnyb();
-             i-- ; 
-             } 
-           return ( j - 15 + ( 13 - dynf ) * 16 + dynf ) ; 
-         } 
+                i--;
+            }
+            return (j - 15 + (13 - dynf) * 16 + dynf);
+        }
     } else if (i <= dynf)
         return (i);
     else if (i < 14)
@@ -174,49 +174,49 @@
     else {
         if (i == 14)
             repeatcount = pkpackednum();
-    else 
+        else
             repeatcount = 1;
 #ifdef DEBUG
         printf("[%d]", (int) repeatcount);
 #endif
-      return ( (*realfunc)() ) ;
-      } 
-    } 
+        return ((*realfunc) ());
+    }
+}
 
 static halfword rest(void)
 {
-   halfword i ;
+    halfword i;
 
-   if (pk_remainder < 0) {
-      pk_remainder = - pk_remainder ;
-      return ( 0 ) ;
-   } else if (pk_remainder > 0) {
-      if (pk_remainder > 4000) {
-         pk_remainder = 4000 - pk_remainder ;
-         return ( 4000 ) ;
-      } else {
-         i = pk_remainder ;
-         pk_remainder = 0 ;
-         realfunc = pkpackednum ;
-         return ( i ) ;
-      }
-   } else {
-      pdftex_fail("shouldn't happen") ;
+    if (pk_remainder < 0) {
+        pk_remainder = -pk_remainder;
+        return (0);
+    } else if (pk_remainder > 0) {
+        if (pk_remainder > 4000) {
+            pk_remainder = 4000 - pk_remainder;
+            return (4000);
+        } else {
+            i = pk_remainder;
+            pk_remainder = 0;
+            realfunc = pkpackednum;
+            return (i);
+        }
+    } else {
+        pdftex_fail("shouldn't happen");
         return 0;
      /*NOTREACHED*/}
 }
 
-static halfword handlehuge(halfword i, halfword  k)
+static halfword handlehuge(halfword i, halfword k)
 {
-   register long j = k ;
+    register long j = k;
 
-   while (i) {
-      j = (j << 4L) + getnyb() ;
-      i-- ;
-   }
-   pk_remainder = j - 15 + ( 13 - dynf ) * 16 + dynf ;
-   realfunc = rest ;
-   return ( rest() ) ;
+    while (i) {
+        j = (j << 4L) + getnyb();
+        i--;
+    }
+    pk_remainder = j - 15 + (13 - dynf) * 16 + dynf;
+    realfunc = rest;
+    return (rest());
 }
 
 /*
@@ -227,55 +227,55 @@
     255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535
 };
 
-static void unpack(chardesc *cd)
-{ 
-  register integer i, j ; 
-  register halfword word, wordweight ;
-  halfword *raster;
-  shalfword rowsleft ; 
-  boolean turnon ; 
-  shalfword hbit ; 
-  halfword count ; 
-  shalfword  wordwidth ;
-
-      wordwidth = (cd->cwidth + 15) / 16 ;
-      i = 2 * cd->cheight * (long)wordwidth ;
-      if (i <= 0)
-         i = 2 ;
-      if (i > cd->rastersize) {
+static void unpack(chardesc * cd)
+{
+    register integer i, j;
+    register halfword word, wordweight;
+    halfword *raster;
+    shalfword rowsleft;
+    boolean turnon;
+    shalfword hbit;
+    halfword count;
+    shalfword wordwidth;
+
+    wordwidth = (cd->cwidth + 15) / 16;
+    i = 2 * cd->cheight * (long) wordwidth;
+    if (i <= 0)
+        i = 2;
+    if (i > cd->rastersize) {
         xfree(cd->raster);
         cd->rastersize = i;
         cd->raster = xtalloc(cd->rastersize, halfword);
-      }
-      raster = cd->raster;
-      realfunc = pkpackednum ;
-      dynf = flagbyte / 16 ; 
-      turnon = flagbyte & 8 ; 
+    }
+    raster = cd->raster;
+    realfunc = pkpackednum;
+    dynf = flagbyte / 16;
+    turnon = flagbyte & 8;
     if (dynf == 14) {
         bitweight = 0;
         for (i = 1; i <= cd->cheight; i++) {
             word = 0;
-            wordweight = 32768 ; 
+            wordweight = 32768;
             for (j = 1; j <= cd->cwidth; j++) {
                 if (getbit())
                     word += wordweight;
-                wordweight >>= 1 ;
+                wordweight >>= 1;
                 if (wordweight == 0) {
                     *raster++ = word;
-                  word = 0 ;
-                  wordweight = 32768 ; 
-                  } 
-                } 
-              if ( wordweight != 32768 ) 
-                 *raster++ = word ; 
-            } 
-      } else {
-        rowsleft = cd->cheight ; 
-        hbit = cd->cwidth ; 
-        repeatcount = 0 ; 
-        wordweight = 16 ; 
-        word = 0 ; 
-        bitweight = 0 ;
+                    word = 0;
+                    wordweight = 32768;
+                }
+            }
+            if (wordweight != 32768)
+                *raster++ = word;
+        }
+    } else {
+        rowsleft = cd->cheight;
+        hbit = cd->cwidth;
+        repeatcount = 0;
+        wordweight = 16;
+        word = 0;
+        bitweight = 0;
         while (rowsleft > 0) {
             count = (*realfunc) ();
 #ifdef DEBUG
@@ -288,40 +288,40 @@
                 if ((count < wordweight) && (count < hbit)) {
                     if (turnon)
                         word += gpower[wordweight] - gpower[wordweight - count];
-                  hbit -= count ; 
-                  wordweight -= count ; 
-                  count = 0 ; 
+                    hbit -= count;
+                    wordweight -= count;
+                    count = 0;
                 } else if ((count >= hbit) && (hbit <= wordweight)) {
                     if (turnon)
                         word += gpower[wordweight] - gpower[wordweight - hbit];
-                  *raster++ = word ; 
-                  for ( i = 1 ; i <= repeatcount ; i ++ ) {
-                    for ( j = 1 ; j <= wordwidth ; j ++ ) {
-                      *raster = *(raster - wordwidth) ;
-                      raster++ ;
+                    *raster++ = word;
+                    for (i = 1; i <= repeatcount; i++) {
+                        for (j = 1; j <= wordwidth; j++) {
+                            *raster = *(raster - wordwidth);
+                            raster++;
+                        }
                     }
-                  }
-                  rowsleft -= repeatcount + 1 ; 
-                  repeatcount = 0 ; 
-                  word = 0 ; 
-                  wordweight = 16 ; 
-                  count -= hbit ; 
-                  hbit = cd->cwidth ; 
+                    rowsleft -= repeatcount + 1;
+                    repeatcount = 0;
+                    word = 0;
+                    wordweight = 16;
+                    count -= hbit;
+                    hbit = cd->cwidth;
                 } else {
                     if (turnon)
                         word += gpower[wordweight];
-                  *raster++ = word ;
-                  word = 0 ; 
-                  count -= wordweight ; 
-                  hbit -= wordweight ; 
-                  wordweight = 16 ; 
-                  } 
-                } 
-              turnon = ! turnon ; 
-   }
-          if ( ( rowsleft != 0 ) || ( (integer)hbit != cd->cwidth ) ) 
-             pdftex_fail("error while unpacking; more bits than required"); 
-        } 
+                    *raster++ = word;
+                    word = 0;
+                    count -= wordweight;
+                    hbit -= wordweight;
+                    wordweight = 16;
+                }
+            }
+            turnon = !turnon;
+        }
+        if ((rowsleft != 0) || ((integer) hbit != cd->cwidth))
+            pdftex_fail("error while unpacking; more bits than required");
+    }
 }
 
 /*
@@ -337,103 +337,103 @@
  *   return EOF if no character definition is available
  */
 
-int readchar(boolean check_preamble, chardesc *cd)
+int readchar(boolean check_preamble, chardesc * cd)
 {
-   register shalfword i ;
-   register integer k ;
-   register integer length=0 ;
+    register shalfword i;
+    register integer k;
+    register integer length = 0;
 
 /*
  *   Check the preamble of the pkfile
  */
-   if (check_preamble) {
-       if (pkbyte()!=247)
-          pdftex_fail("bad pk file, expected pre") ;
-       if (pkbyte()!=89)
-          pdftex_fail("bad version of pk file") ;
-       for(i=pkbyte(); i>0; i--) /* creator of pkfile */
-          (void)pkbyte() ;   
-       (void)pkquad(); /* design size */
-       k = pkquad() ;  /* checksum    */
-       k = pkquad() ;  /* hppp        */
-       k = pkquad() ;  /* vppp   */
-   }
+    if (check_preamble) {
+        if (pkbyte() != 247)
+            pdftex_fail("bad pk file, expected pre");
+        if (pkbyte() != 89)
+            pdftex_fail("bad version of pk file");
+        for (i = pkbyte(); i > 0; i--)  /* creator of pkfile */
+            (void) pkbyte();
+        (void) pkquad();        /* design size */
+        k = pkquad();           /* checksum    */
+        k = pkquad();           /* hppp        */
+        k = pkquad();           /* vppp   */
+    }
 /*
  *   Now we skip to the desired character definition
  */
-   while ((flagbyte=pkbyte())!=245) {
-      if (flagbyte < 240) {
-         switch (flagbyte & 7) {
+    while ((flagbyte = pkbyte()) != 245) {
+        if (flagbyte < 240) {
+            switch (flagbyte & 7) {
             case 0:
             case 1:
             case 2:
             case 3:
-            length = (flagbyte & 7) * 256 + pkbyte() - 3;
-            cd->charcode = pkbyte() ;
-            (void) pktrio() ;  /* TFMwidth */
-            cd->xescape = pkbyte() ;      /* pixel width */
-            cd->cwidth = pkbyte() ;
-            cd->cheight = pkbyte() ;
-            cd->xoff = pkbyte() ;
-            cd->yoff = pkbyte() ;
-            if (cd->xoff > 127)
-               cd->xoff -= 256 ;
-            if (cd->yoff > 127)
-               cd->yoff -= 256 ;
-            break ;
+                length = (flagbyte & 7) * 256 + pkbyte() - 3;
+                cd->charcode = pkbyte();
+                (void) pktrio();        /* TFMwidth */
+                cd->xescape = pkbyte(); /* pixel width */
+                cd->cwidth = pkbyte();
+                cd->cheight = pkbyte();
+                cd->xoff = pkbyte();
+                cd->yoff = pkbyte();
+                if (cd->xoff > 127)
+                    cd->xoff -= 256;
+                if (cd->yoff > 127)
+                    cd->yoff -= 256;
+                break;
             case 4:
             case 5:
             case 6:
-            length = (flagbyte & 3) * 65536L + pkbyte() * 256L ;
-            length = length + pkbyte() - 4L ;
-            cd->charcode = pkbyte() ;
-            (void) pktrio() ;           /* TFMwidth */
-            cd->xescape  = pkduo() ;      /* pixelwidth */
-            cd->cwidth = pkduo() ;
-            cd->cheight = pkduo() ;
-            cd->xoff = pkduo() ;
-            cd->yoff = pkduo() ;
-            break ;
-case 7:
-            length = pkquad() - 9L;
-            cd->charcode = pkquad();
-            (void) pkquad() ;  /* TFMwidth */
-            cd->xescape =  pkquad();      /* pixelwidth */
-            k = pkquad() ;
-            cd->cwidth = pkquad();
-            cd->cheight = pkquad();
-            cd->xoff = pkquad();
-            cd->yoff = pkquad();
-         }
-         if (length <= 0)
-            pdftex_fail("packet length (%i) too small", (int)length) ;
-         unpack(cd);
-         return 1;
-      } else {
-         k = 0 ;
-         switch (flagbyte) {
-case 243:
-            k = pkbyte() ;
-            if (k > 127)
-               k -= 256 ;
-case 242:
-            k = k * 256 + pkbyte() ;
-case 241:
-            k = k * 256 + pkbyte() ;
-case 240:
-            k = k * 256 + pkbyte() ;
-            while (k-- > 0)
-               i = pkbyte() ;
-            break ;
-case 244:
-            k = pkquad() ;
-            break ;
-case 246:
-            break ;
-default:
-            pdftex_fail("unexpected command (%i)", (int)flagbyte) ;
-         }
-      }
-   }
-   return 0; /* character not found */
+                length = (flagbyte & 3) * 65536L + pkbyte() * 256L;
+                length = length + pkbyte() - 4L;
+                cd->charcode = pkbyte();
+                (void) pktrio();        /* TFMwidth */
+                cd->xescape = pkduo();  /* pixelwidth */
+                cd->cwidth = pkduo();
+                cd->cheight = pkduo();
+                cd->xoff = pkduo();
+                cd->yoff = pkduo();
+                break;
+            case 7:
+                length = pkquad() - 9L;
+                cd->charcode = pkquad();
+                (void) pkquad();        /* TFMwidth */
+                cd->xescape = pkquad(); /* pixelwidth */
+                k = pkquad();
+                cd->cwidth = pkquad();
+                cd->cheight = pkquad();
+                cd->xoff = pkquad();
+                cd->yoff = pkquad();
+            }
+            if (length <= 0)
+                pdftex_fail("packet length (%i) too small", (int) length);
+            unpack(cd);
+            return 1;
+        } else {
+            k = 0;
+            switch (flagbyte) {
+            case 243:
+                k = pkbyte();
+                if (k > 127)
+                    k -= 256;
+            case 242:
+                k = k * 256 + pkbyte();
+            case 241:
+                k = k * 256 + pkbyte();
+            case 240:
+                k = k * 256 + pkbyte();
+                while (k-- > 0)
+                    i = pkbyte();
+                break;
+            case 244:
+                k = pkquad();
+                break;
+            case 246:
+                break;
+            default:
+                pdftex_fail("unexpected command (%i)", (int) flagbyte);
+            }
+        }
+    }
+    return 0;                   /* character not found */
 }
--- tetex-src-3.0/texk/web2c/pdftexdir/ptexmac.h.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/ptexmac.h	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2006 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,77 +13,77 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: ptexmac.h,v 1.14 2005/11/29 22:05:23 hahe Exp $
+$Id: ptexmac.h 217 2007-07-31 16:55:39Z oneiros $
 */
 
 #ifndef PDFTEXMAC
-#define PDFTEXMAC
+#  define PDFTEXMAC
 
 /* Not all systems define it. */
-#ifndef M_PI
+#  ifndef M_PI
 #    define M_PI           3.14159265358979323846
                                                 /* pi */
 #    define M_PI_2         1.5707963267948966192E0
                                                 /*Hex  2^ 0 * 1.921FB54442D18 */
 #    define M_PI_4         7.8539816339744830962E-1
                                                 /*Hex  2^-1 * 1.921FB54442D18 */
-#endif
+#  endif
 
-#ifdef WIN32
+#  ifdef WIN32
 // Why relying on gmalloc() ???
-#define gmalloc(n) xmalloc(n)
-#define gfree(p) free(p)
-#define inline __inline
-#define srandom(n) srand(n)
-#define random() rand()
-#endif
+#    define gmalloc(n) xmalloc(n)
+#    define gfree(p) free(p)
+#    define inline __inline
+#    define srandom(n) srand(n)
+#    define random() rand()
+#  endif
 
 /* Pascal WEB macros */
-#define maxinteger 0x7FFFFFFF
-#define maxdimen   0x3FFFFFFF
+#  define maxinteger 0x7FFFFFFF
+#  define maxdimen   0x3FFFFFFF
 
-#define objinfo(n) objtab[n].int0
+#  define objinfo(n) objtab[n].int0
 
-#define pdfroom(n) do {                                 \
+#  define pdfroom(n) do {                                      \
     if ((unsigned)(n + pdfptr) > (unsigned)pdfbufsize) {     \
         if (pdfosmode)                                       \
             zpdfosgetosbuf(n);                               \
         else {                                               \
             if ((unsigned)(n) > (unsigned)pdfbufsize)        \
-        pdftex_fail("PDF output buffer overflowed");    \
+                pdftex_fail("PDF output buffer overflowed"); \
             else                                             \
-        pdfflush();                                     \
+                pdfflush();                                  \
         }                                                    \
     }                                                        \
 } while (0)
 
-#define pdfout(c)  do {             \
+#  define pdfout(c)  do {   \
     pdfroom(1);           \
-    pdfbuf[pdfptr++] = c;           \
+    pdfbuf[pdfptr++] = c; \
 } while (0)
 
-#define pdfoffset()     (pdfgone + pdfptr)
+#  define pdfoffset()     (pdfgone + pdfptr)
 
-#define MAX_CHAR_CODE       255
-#define PRINTF_BUF_SIZE     1024
+#  define MAX_CHAR_CODE       255
+#  define PRINTF_BUF_SIZE     1024
 #  define MAX_CSTRING_LEN     1024 * 1024
-#define MAX_PSTRING_LEN     1024
-#define SMALL_BUF_SIZE      256
-#define SMALL_ARRAY_SIZE    256
+#  define MAX_PSTRING_LEN     1024
+#  define SMALL_BUF_SIZE      256
+#  define SMALL_ARRAY_SIZE    256
 #  define FONTNAME_BUF_SIZE   128
                                 /* a PDF name can be maximum 127 chars long */
 
 #  define pdftex_debug    tex_printf
 
-#define check_buf(size, buf_size)                          \
+#  define check_buf(size, buf_size)                          \
     if ((unsigned)(size) > (unsigned)(buf_size))                               \
         pdftex_fail("buffer overflow at file %s, line %d", __FILE__,  __LINE__ )
 
-#define append_char_to_buf(c, p, buf, buf_size) do {       \
+#  define append_char_to_buf(c, p, buf, buf_size) do {       \
     if (c == 9)                                            \
         c = 32;                                            \
     if (c == 13 || c == EOF)                               \
@@ -94,7 +94,7 @@
     }                                                      \
 } while (0)
 
-#define append_eol(p, buf, buf_size) do {                  \
+#  define append_eol(p, buf, buf_size) do {                  \
     check_buf(p - buf + 2, (buf_size));                    \
     if (p - buf > 1 && p[-1] != 10)                        \
         *p++ = 10;                                         \
@@ -105,15 +105,15 @@
     *p = 0;                                                \
 } while (0)
 
-#define remove_eol(p, buf) do {                            \
+#  define remove_eol(p, buf) do {                            \
     p = strend(buf) - 1;                                   \
     if (*p == 10)                                          \
         *p = 0;                                            \
 } while (0)
 
-#define skip(p, c)   if (*p == c)  p++
+#  define skip(p, c)   if (*p == c)  p++
 
-#define alloc_array(T, n, s) do {                           \
+#  define alloc_array(T, n, s) do {                           \
     if (T##_array == NULL) {                                \
         T##_limit = (s);                                    \
         if ((unsigned)(n) > T##_limit)                      \
@@ -131,21 +131,21 @@
     }                                                       \
 } while (0)
 
-#define is_cfg_comment(c) \
+#  define is_cfg_comment(c) \
     (c == 10 || c == '*' || c == '#' || c == ';' || c == '%')
 
-#define define_array(T)                     \
+#  define define_array(T)                     \
 T##_entry      *T##_ptr, *T##_array = NULL;    \
 size_t          T##_limit
 
-#define xfree(p)            do { if (p != NULL) free(p); p = NULL; } while (0)
-#define strend(s)           strchr(s, 0)
-#define xtalloc             XTALLOC
-#define xretalloc           XRETALLOC
-
-#define ASCENT_CODE         0
-#define CAPHEIGHT_CODE      1
-#define DESCENT_CODE        2
+#  define xfree(p)            do { if (p != NULL) free(p); p = NULL; } while (0)
+#  define strend(s)           strchr(s, 0)
+#  define xtalloc             XTALLOC
+#  define xretalloc           XRETALLOC
+
+#  define ASCENT_CODE         0
+#  define CAPHEIGHT_CODE      1
+#  define DESCENT_CODE        2
 #  define ITALIC_ANGLE_CODE   3
 #  define STEMV_CODE          4
 #  define XHEIGHT_CODE        5
@@ -155,33 +155,33 @@
 #  define FONTBBOX4_CODE      9
 #  define FONTNAME_CODE       10
 #  define GEN_KEY_NUM         (XHEIGHT_CODE + 1)
-#define MAX_KEY_CODE        (FONTBBOX1_CODE + 1)
+#  define MAX_KEY_CODE        (FONTBBOX1_CODE + 1)
 #  define INT_KEYS_NUM        (FONTBBOX4_CODE + 1)
 #  define FONT_KEYS_NUM       (FONTNAME_CODE + 1)
 
-#define F_INCLUDED          0x01
-#define F_SUBSETTED         0x02
+#  define F_INCLUDED          0x01
+#  define F_SUBSETTED         0x02
 #  define F_STDT1FONT         0x04
 #  define F_SUBFONT           0x08
 #  define F_TYPE1             0x10
 #  define F_TRUETYPE          0x20
 #  define F_OTF               0x40
 
-#define set_included(fm)    ((fm)->type |= F_INCLUDED)
-#define set_subsetted(fm)   ((fm)->type |= F_SUBSETTED)
+#  define set_included(fm)    ((fm)->type |= F_INCLUDED)
+#  define set_subsetted(fm)   ((fm)->type |= F_SUBSETTED)
 #  define set_std_t1font(fm)  ((fm)->type |= F_STDT1FONT)
 #  define set_subfont(fm)     ((fm)->type |= F_SUBFONT)
 #  define set_type1(fm)       ((fm)->type |= F_TYPE1)
-#define set_truetype(fm)    ((fm)->type |= F_TRUETYPE)
+#  define set_truetype(fm)    ((fm)->type |= F_TRUETYPE)
 #  define set_opentype(fm)    ((fm)->type |= F_OTF)
 #  define set_subfont(fm)     ((fm)->type |= F_SUBFONT)
 
-#define unset_included(fm)  ((fm)->type &= ~F_INCLUDED)
-#define unset_subsetted(fm) ((fm)->type &= ~F_SUBSETTED)
+#  define unset_included(fm)  ((fm)->type &= ~F_INCLUDED)
+#  define unset_subsetted(fm) ((fm)->type &= ~F_SUBSETTED)
 #  define unset_std_t1font(fm)((fm)->type &= ~F_STDT1FONT)
 #  define unset_subfont(fm)   ((fm)->type &= ~F_SUBFONT)
 #  define unset_type1(fm)     ((fm)->type &= ~F_TYPE1)
-#define unset_truetype(fm)  ((fm)->type &= ~F_TRUETYPE)
+#  define unset_truetype(fm)  ((fm)->type &= ~F_TRUETYPE)
 #  define unset_opentype(fm)  ((fm)->type &= ~F_OTF)
 #  define unset_subfont(fm)   ((fm)->type &= ~F_SUBFONT)
 
@@ -194,26 +194,26 @@
 #  define is_opentype(fm)     (((fm)->type & F_OTF) != 0)
 #  define is_subfont(fm)      (((fm)->type & F_SUBFONT) != 0)
 
-#define fm_slant(fm)        (fm)->slant
-#define fm_extend(fm)       (fm)->extend
-#define fm_fontfile(fm)     (fm)->ff_name
+#  define fm_slant(fm)        (fm)->slant
+#  define fm_extend(fm)       (fm)->extend
+#  define fm_fontfile(fm)     (fm)->ff_name
 
 #  define is_reencoded(fm)    ((fm)->encname != NULL)
-#define is_fontfile(fm)     (fm_fontfile(fm) != NULL)
+#  define is_fontfile(fm)     (fm_fontfile(fm) != NULL)
 #  define is_t1fontfile(fm)   (is_fontfile(fm) && is_type1(fm))
 #  define is_builtin(fm)      (!is_fontfile(fm))
 
-#define LINK_TFM            0x01
-#define LINK_PS             0x02
-#define set_tfmlink(fm)     ((fm)->links |= LINK_TFM)
-#define set_pslink(fm)      ((fm)->links |= LINK_PS)
-#define unset_tfmlink(fm)   ((fm)->links &= ~LINK_TFM)
-#define unset_pslink(fm)    ((fm)->links &= ~LINK_PS)
-#define has_tfmlink(fm)     ((fm)->links & LINK_TFM)
-#define has_pslink(fm)      ((fm)->links & LINK_PS)
+#  define LINK_TFM            0x01
+#  define LINK_PS             0x02
+#  define set_tfmlink(fm)     ((fm)->links |= LINK_TFM)
+#  define set_pslink(fm)      ((fm)->links |= LINK_PS)
+#  define unset_tfmlink(fm)   ((fm)->links &= ~LINK_TFM)
+#  define unset_pslink(fm)    ((fm)->links &= ~LINK_PS)
+#  define has_tfmlink(fm)     ((fm)->links & LINK_TFM)
+#  define has_pslink(fm)      ((fm)->links & LINK_PS)
 
 
-#define set_cur_file_name(s)      \
+#  define set_cur_file_name(s)      \
     cur_file_name = s;      \
     packfilename(maketexstring(cur_file_name), getnullstr(), getnullstr())
 
@@ -225,4 +225,4 @@
 
 #  define str_prefix(s1, s2)  (strncmp((s1), (s2), strlen(s2)) == 0)
 
-#endif  /* PDFTEXMAC */
+#endif                          /* PDFTEXMAC */
--- tetex-src-3.0/texk/web2c/pdftexdir/utils.c.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/utils.c	2008-01-06 17:43:23.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2006 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: //depot/Build/source.development/TeX/texk/web2c/pdftexdir/utils.c#24 $
+$Id: utils.c 217 2007-07-31 16:55:39Z oneiros $
 */
 
 
@@ -48,19 +48,19 @@
 static char print_buf[PRINTF_BUF_SIZE];
 static char *jobname_cstr = NULL;
 static char *job_id_string = NULL;
-extern string ptexbanner; /* from web2c/lib/texmfmp.c */
-extern string versionstring; /* from web2c/lib/version.c */         
-extern KPSEDLL string kpathsea_version_string; /* from kpathsea/version.c */
+extern string ptexbanner;       /* from web2c/lib/texmfmp.c */
+extern string versionstring;    /* from web2c/lib/version.c */
+extern KPSEDLL string kpathsea_version_string;  /* from kpathsea/version.c */
 
-size_t last_ptr_index; /* for use with alloc_array */
+size_t last_ptr_index;          /* for use with alloc_array */
 
 /* define fb_ptr, fb_array & fb_limit */
 typedef char fb_entry;
-define_array(fb);   
+define_array(fb);
 
 /* define char_ptr, char_array & char_limit */
 typedef char char_entry;
-define_array(char);   
+define_array(char);
 
 /* define vf_e_fnts_ptr, vf_e_fnts_array & vf_e_fnts_limit */
 typedef integer vf_e_fnts_entry;
@@ -77,7 +77,7 @@
 
 void fb_seek(integer offset)
 {
-     fb_ptr = fb_array + offset;
+    fb_ptr = fb_array + offset;
 }
 
 void fb_putchar(eightbits b)
@@ -94,7 +94,7 @@
         n = pdfbufsize - pdfptr;
         if (fb_ptr - p < n)
             n = fb_ptr - p;
-        memcpy(pdfbuf + pdfptr, p, (unsigned)n);
+        memcpy(pdfbuf + pdfptr, p, (unsigned) n);
         pdfptr += n;
         if (pdfptr == pdfbufsize)
             pdfflush();
@@ -159,12 +159,12 @@
 }
 
 __attribute__ ((format(printf, 1, 2)))
-void pdf_printf(const char *fmt,...)
+void pdf_printf(const char *fmt, ...)
 {
     va_list args;
     va_start(args, fmt);
     vsnprintf(print_buf, PRINTF_BUF_SIZE, fmt, args);
-    pdf_puts(print_buf);                                    
+    pdf_puts(print_buf);
     va_end(args);
 }
 
@@ -217,7 +217,7 @@
    The output format of this fuction must be the same as pdf_error in
    pdftex.web! */
 __attribute__ ((noreturn, format(printf, 1, 2)))
-void pdftex_fail(const char *fmt,...)
+void pdftex_fail(const char *fmt, ...)
 {
     va_list args;
     va_start(args, fmt);
@@ -247,7 +247,7 @@
 /* The output format of this fuction must be the same as pdf_warn in
    pdftex.web! */
 __attribute__ ((format(printf, 1, 2)))
-void pdftex_warn(const char *fmt,...)
+void pdftex_warn(const char *fmt, ...)
 {
     va_list args;
     va_start(args, fmt);
@@ -309,17 +309,17 @@
     name_string = xstrdup(makecstring(jobname));
     format_string = xstrdup(makecstring(formatident));
     slen = SMALL_BUF_SIZE +
-                strlen(name_string) + 
-                strlen(format_string) + 
-                strlen(ptexbanner) + 
+        strlen(name_string) +
+        strlen(format_string) +
+        strlen(ptexbanner) +
         strlen(versionstring) + strlen(kpathsea_version_string);
     s = xtalloc(slen, char);
     /* The Web2c version string starts with a space.  */
     i = snprintf(s, slen,
                  "%.4d/%.2d/%.2d %.2d:%.2d %s %s %s%s %s",
-            year, month, day, time/60, time%60, 
-            name_string, format_string, ptexbanner, 
-            versionstring, kpathsea_version_string);
+                 year, month, day, time / 60, time % 60,
+                 name_string, format_string, ptexbanner,
+                 versionstring, kpathsea_version_string);
     check_nprintf(i, slen);
     job_id_string = xstrdup(s);
     xfree(s);
@@ -338,7 +338,7 @@
         return;
 
     slen = SMALL_BUF_SIZE +
-                strlen(ptexbanner) + 
+        strlen(ptexbanner) +
         strlen(versionstring) + strlen(kpathsea_version_string);
     s = xtalloc(slen, char);
     /* The Web2c version string starts with a space.  */
@@ -356,13 +356,13 @@
 /* "!\"$&'*+,-.0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" */
 /* "^_`abcdefghijklmnopqrstuvwxyz|~"; */
     static char name_str[] =
-"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
-    char prefix[7]; /* make a tag of 6 chars long */
+        "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
+    char prefix[7];             /* make a tag of 6 chars long */
     unsigned long crc;
     int i;
     size_t base = strlen(name_str);
     crc = crc32(0L, Z_NULL, 0);
-    crc = crc32(crc, (Bytef*)job_id_string, strlen(job_id_string));
+    crc = crc32(crc, (Bytef *) job_id_string, strlen(job_id_string));
     for (i = 0; i < 6; i++) {
         prefix[i] = name_str[crc % base];
         crc /= base;
@@ -371,21 +371,21 @@
     return maketexstring(prefix);
 }
 
-size_t xfwrite(void *ptr, size_t size, size_t nmemb, FILE *stream)
+size_t xfwrite(void *ptr, size_t size, size_t nmemb, FILE * stream)
 {
     if (fwrite(ptr, size, nmemb, stream) != nmemb)
         pdftex_fail("fwrite() failed");
     return nmemb;
 }
 
-int xfflush(FILE *stream)
+int xfflush(FILE * stream)
 {
     if (fflush(stream) != 0)
         pdftex_fail("fflush() failed");
     return 0;
 }
 
-int xgetc(FILE *stream)
+int xgetc(FILE * stream)
 {
     int c = getc(stream);
     if (c < 0 && c != EOF)
@@ -393,7 +393,7 @@
     return c;
 }
 
-int xputc(int c, FILE *stream)
+int xputc(int c, FILE * stream)
 {
     int i = putc(c, stream);
     if (i < 0)
@@ -406,20 +406,20 @@
     if (jobname_cstr == NULL)
         jobname_cstr = xstrdup(makecstring(jobname));
     if (fixedpdfdraftmode == 0) {
-    xfseek(pdffile, offset, SEEK_SET, jobname_cstr);
-    fprintf(pdffile, "%li", (long int)length);
-    xfseek(pdffile, pdfoffset(), SEEK_SET, jobname_cstr);
-}
+        xfseek(pdffile, offset, SEEK_SET, jobname_cstr);
+        fprintf(pdffile, "%li", (long int) length);
+        xfseek(pdffile, pdfoffset(), SEEK_SET, jobname_cstr);
+    }
 }
 
 scaled extxnoverd(scaled x, scaled n, scaled d)
 {
-    double r = (((double)x)*((double)n))/((double)d);
+    double r = (((double) x) * ((double) n)) / ((double) d);
     if (r > DBL_EPSILON)
         r += 0.5;
     else
         r -= 0.5;
-    if (r >= (double)maxinteger || r <= -(double)maxinteger)
+    if (r >= (double) maxinteger || r <= -(double) maxinteger)
         pdftex_warn("arithmetic: number too big");
     return (scaled) r;
 }
@@ -438,6 +438,7 @@
     ttf_free();
     sfd_free();
     glyph_unicode_free();
+    zip_free();
 }
 
 /* Converts any string given in in in an allowed PDF string which can be
@@ -454,7 +455,7 @@
     char buf[5];
     for (i = 0; i < len; i++) {
         check_buf(j + sizeof(buf), MAX_PSTRING_LEN);
-        if (((unsigned char)in[i] < '!') || ((unsigned char)in[i] > '~')){
+        if (((unsigned char) in[i] < '!') || ((unsigned char) in[i] > '~')) {
             /* convert control characters into oct */
             k = snprintf(buf, sizeof(buf),
                          "\\%03o", (unsigned int) (unsigned char) in[i]);
@@ -474,8 +475,8 @@
         } else {
             /* copy char :-) */
             out[j++] = in[i];
-            }
         }
+    }
     out[j] = '\0';
     return pstrbuf;
 }
@@ -499,9 +500,9 @@
             /* error by str_toks that calls str_room(1) */
             return;
         }
-        
-        ch = (unsigned char)strpool[in++];
-        
+
+        ch = (unsigned char) strpool[in++];
+
         if ((ch < '!') || (ch > '~')) {
             /* convert control characters into oct */
             int i = snprintf((char *) &strpool[poolptr], 5,
@@ -521,7 +522,7 @@
 
 /* Convert any given string in a PDF name using escaping mechanism
    of PDF 1.2. The result does not include the leading slash.
-   
+
    PDF specification 1.6, section 3.2.6 "Name Objects" explains:
    <blockquote>
     Beginning with PDF 1.2, any character except null (character code 0) may
@@ -552,7 +553,7 @@
      125       escaped  delimiter "}"
      127..255  escaped  recommended
      else      copy     regular characters
-     
+
    Parameter "in" is a pointer into the string pool where
    the input string is located. The output string is written
    as temporary string right after the input string.
@@ -565,16 +566,16 @@
     const poolpointer out = poolptr;
     unsigned char ch;
     int i;
-    
+
     while (in < out) {
         if (poolptr + 3 >= poolsize) {
             poolptr = poolsize;
             /* error by str_toks that calls str_room(1) */
             return;
         }
-        
-        ch = (unsigned char)strpool[in++];
-        
+
+        ch = (unsigned char) strpool[in++];
+
         if ((ch >= 1 && ch <= 32) || ch >= 127) {
             /* escape */
             i = snprintf((char *) &strpool[poolptr], 4,
@@ -613,9 +614,9 @@
 
 /* Convert any given string in a PDF hexadecimal string. The
    result does not include the angle brackets.
-   
+
    This procedure uses uppercase hexadecimal letters.
-   
+
    See escapename for description of parameters.
 */
 void escapehex(poolpointer in)
@@ -623,7 +624,7 @@
     const poolpointer out = poolptr;
     unsigned char ch;
     int i;
-    
+
     while (in < out) {
         if (poolptr + 2 >= poolsize) {
             poolptr = poolsize;
@@ -631,8 +632,8 @@
             return;
         }
 
-        ch = (unsigned char)strpool[in++];
-    
+        ch = (unsigned char) strpool[in++];
+
         i = snprintf((char *) &strpool[poolptr], 3, "%.2X", (unsigned int) ch);
         check_nprintf(i, 3);
         poolptr += 2;
@@ -643,7 +644,7 @@
 
    Last hex digit can be omitted, it is replaced by zero, see
    PDF specification.
-   
+
    Invalid digits are silently ignored.
 
    See escapename for description of parameters.
@@ -654,7 +655,7 @@
     unsigned char ch;
     unsigned char a = 0;        /* to avoid warning about uninitialized use of a */
     boolean first = true;
-    
+
     while (in < out) {
         if (poolptr + 1 >= poolsize) {
             poolptr = poolsize;
@@ -662,7 +663,7 @@
             return;
         }
 
-        ch = (unsigned char)strpool[in++];
+        ch = (unsigned char) strpool[in++];
 
         if ((ch >= '0') && (ch <= '9')) {
             ch -= '0';
@@ -671,25 +672,25 @@
         } else if ((ch >= 'a') && (ch <= 'f')) {
             ch -= 'a' - 10;
         } else {
-            continue; /* ignore wrong character */
+            continue;           /* ignore wrong character */
         }
-        
+
         if (first) {
             a = ch << 4;
             first = false;
             continue;
         }
-        
+
         strpool[poolptr++] = a + ch;
         first = true;
     }
-    if (!first) { /* last hex digit is omitted */
-        strpool[poolptr++] = ch << 4;
+    if (!first) {               /* last hex digit is omitted */
+        strpool[poolptr++] = a;
     }
 }
 
 
-/* Converts any string given in in in an allowed PDF string which is 
+/* Converts any string given in in in an allowed PDF string which is
  * hexadecimal encoded;
  * sizeof(out) should be at least lin*2+1.
  */
@@ -704,7 +705,7 @@
         check_nprintf(k, sizeof(buf));
         out[j++] = buf[0];
         out[j++] = buf[1];
-        }
+    }
     out[j] = '\0';
 }
 
@@ -721,15 +722,15 @@
     identifiers are set to the same value. If both identifiers match when a
     file reference is resolved, it is very likely that the correct file has
     been found; if only the first identifier matches, then a different
-    version of the correct file has been found. 
+    version of the correct file has been found.
         To help ensure the uniqueness of file identifiers, it is recommend
     that they be computed using a message digest algorithm such as MD5
     (described in Internet RFC 1321, The MD5 Message-Digest Algorithm; see
     the Bibliography), using the following information (see implementation
-    note 106 in Appendix H): 
-    - The current time 
-    - A string representation of the file's location, usually a pathname 
-    - The size of the file in bytes 
+    note 106 in Appendix H):
+    - The current time
+    - A string representation of the file's location, usually a pathname
+    - The size of the file in bytes
     - The values of all entries in the file's document information
       dictionary (see Section 9.2.1,  Document Information Dictionary )
   </blockquote>
@@ -739,7 +740,7 @@
   scanning the info dict is also difficult, we start with a simpler
   implementation using just the first two items.
  */
-void printID (strnumber filename)
+void printID(strnumber filename)
 {
     time_t t;
     size_t size;
@@ -753,19 +754,19 @@
     md5_init(&state);
     /* get the time */
     t = time(NULL);
-    size = strftime (time_str, sizeof(time_str), "%Y%m%dT%H%M%SZ", gmtime(&t));
-    md5_append(&state, (const md5_byte_t *)time_str, size);
+    size = strftime(time_str, sizeof(time_str), "%Y%m%dT%H%M%SZ", gmtime(&t));
+    md5_append(&state, (const md5_byte_t *) time_str, size);
     /* get the file name */
     if (getcwd(pwd, sizeof(pwd)) == NULL)
         pdftex_fail("getcwd() failed (path too long?)");
     file_name = makecstring(filename);
-    md5_append(&state, (const md5_byte_t *)pwd, strlen(pwd));
-    md5_append(&state, (const md5_byte_t *)"/", 1);
-    md5_append(&state, (const md5_byte_t *)file_name, strlen(file_name));
+    md5_append(&state, (const md5_byte_t *) pwd, strlen(pwd));
+    md5_append(&state, (const md5_byte_t *) "/", 1);
+    md5_append(&state, (const md5_byte_t *) file_name, strlen(file_name));
     /* finish md5 */
     md5_finish(&state, digest);
     /* write the IDs */
-    convertStringToHexString ((char*)digest, id, 16);
+    convertStringToHexString((char *) digest, id, 16);
     pdf_printf("/ID [<%s> <%s>]", id, id);
 }
 
@@ -816,7 +817,7 @@
 
   The main difficulty is get the time zone offset. strftime() does this in ISO
   C99 (e.g. newer glibc) with %z, but we have to work with other systems (e.g.
-  Solaris 2.5). 
+  Solaris 2.5).
 */
 
 static time_t start_time = 0;
@@ -824,14 +825,14 @@
 static char start_time_str[TIME_STR_SIZE];
 static char time_str[TIME_STR_SIZE];
     /* minimum size for time_str is 24: "D:YYYYmmddHHMMSS+HH'MM'" */
-    
+
 static void makepdftime(time_t t, char *time_str)
 {
-            
+
     struct tm lt, gmt;
     size_t size;
     int i, off, off_hours, off_mins;
- 
+
     /* get the time */
     lt = *localtime(&t);
     size = strftime(time_str, TIME_STR_SIZE, "D:%Y%m%d%H%M%S", &lt);
@@ -843,19 +844,19 @@
     }
 
     /* correction for seconds: %S can be in range 00..61,
-       the PDF reference expects 00..59,   
+       the PDF reference expects 00..59,
        therefore we map "60" and "61" to "59" */
     if (time_str[14] == '6') {
         time_str[14] = '5';
         time_str[15] = '9';
-        time_str[16] = '\0'; /* for safety */
+        time_str[16] = '\0';    /* for safety */
     }
 
     /* get the time zone offset */
     gmt = *gmtime(&t);
 
     /* this calculation method was found in exim's tod.c */
-    off = 60*(lt.tm_hour - gmt.tm_hour) + lt.tm_min - gmt.tm_min;
+    off = 60 * (lt.tm_hour - gmt.tm_hour) + lt.tm_min - gmt.tm_min;
     if (lt.tm_year != gmt.tm_year) {
         off += (lt.tm_year > gmt.tm_year) ? 1440 : -1440;
     } else if (lt.tm_yday != gmt.tm_yday) {
@@ -866,8 +867,8 @@
         time_str[size++] = 'Z';
         time_str[size] = 0;
     } else {
-        off_hours = off/60;
-        off_mins = abs(off - off_hours*60);
+        off_hours = off / 60;
+        off_mins = abs(off - off_hours * 60);
         i = snprintf(&time_str[size], 9, "%+03d'%02d'", off_hours, off_mins);
         check_nprintf(i, 9);
     }
@@ -897,9 +898,9 @@
 {
     /* put creation date on top of string pool and update poolptr */
     size_t len = strlen(start_time_str);
-    
+
     initstarttime();
-    
+
     if ((unsigned) (poolptr + len) >= (unsigned) (poolsize)) {
         poolptr = poolsize;
         /* error by str_toks that calls str_room(1) */
@@ -913,16 +914,17 @@
 void getfilemoddate(strnumber s)
 {
     struct stat file_data;
-    
+
     char *file_name = kpse_find_tex(makecfilename(s));
     if (file_name == NULL) {
-        return; /* empty string */
+        return;                 /* empty string */
     }
-    
+
+    /* recorder_record_input(file_name); */
     /* get file status */
     if (stat(file_name, &file_data) == 0) {
         size_t len;
-        
+
         makepdftime(file_data.st_mtime, time_str);
         len = strlen(time_str);
         if ((unsigned) (poolptr + len) >= (unsigned) (poolsize)) {
@@ -934,7 +936,7 @@
         }
     }
     /* else { errno contains error code } */
-    
+
     xfree(file_name);
 }
 
@@ -942,17 +944,18 @@
 {
     struct stat file_data;
     int i;
-    
+
     char *file_name = kpse_find_tex(makecfilename(s));
     if (file_name == NULL) {
-        return; /* empty string */
+        return;                 /* empty string */
     }
-    
+
+    /* recorder_record_input(file_name); */
     /* get file status */
     if (stat(file_name, &file_data) == 0) {
         size_t len;
         char buf[20];
-        
+
         /* st_size has type off_t */
         i = snprintf(buf, sizeof(buf),
                      "%lu", (long unsigned int) file_data.st_size);
@@ -967,7 +970,7 @@
         }
     }
     /* else { errno contains error code } */
-    
+
     xfree(file_name);
 }
 
@@ -980,46 +983,47 @@
     md5_byte_t digest[DIGEST_SIZE];
     char outbuf[2 * DIGEST_SIZE + 1];
     int len = 2 * DIGEST_SIZE;
-    
+
     if (file) {
         char file_buf[FILE_BUF_SIZE];
         int read = 0;
         FILE *f;
-        
+
         char *file_name = kpse_find_tex(makecfilename(s));
         if (file_name == NULL) {
-            return; /* empty string */
+            return;             /* empty string */
         }
         /* in case of error the empty string is returned,
            no need for xfopen that aborts on error.
-        */
+         */
         f = fopen(file_name, FOPEN_RBIN_MODE);
         if (f == NULL) {
             xfree(file_name);
             return;
         }
+        /* recorder_record_input(file_name); */
         md5_init(&state);
         while ((read = fread(&file_buf, sizeof(char), FILE_BUF_SIZE, f)) > 0) {
-            md5_append(&state, (const md5_byte_t *)file_buf, read);
+            md5_append(&state, (const md5_byte_t *) file_buf, read);
         }
         md5_finish(&state, digest);
         fclose(f);
-        
+
         xfree(file_name);
     } else {
-      /* s contains the data */
-      md5_init(&state);
-      md5_append(&state,
-          (const md5_byte_t *)&strpool[strstart[s]],
-          strstart[s + 1] - strstart[s]);
-      md5_finish(&state, digest);
+        /* s contains the data */
+        md5_init(&state);
+        md5_append(&state,
+                   (const md5_byte_t *) &strpool[strstart[s]],
+                   strstart[s + 1] - strstart[s]);
+        md5_finish(&state, digest);
     }
-    
+
     if (poolptr + len >= poolsize) {
         /* error by str_toks that calls str_room(1) */
         return;
     }
-    convertStringToHexString((char*)digest, outbuf, DIGEST_SIZE);
+    convertStringToHexString((char *) digest, outbuf, DIGEST_SIZE);
     memcpy(&strpool[poolptr], outbuf, len);
     poolptr += len;
 }
@@ -1036,26 +1040,27 @@
         /* empty result string */
         return;
     }
-    
+
     if (poolptr + 2 * length + 1 >= poolsize) {
         /* no place for result */
         poolptr = poolsize;
         /* error by str_toks that calls str_room(1) */
         return;
     }
-    
+
     file_name = kpse_find_tex(makecfilename(s));
     if (file_name == NULL) {
-        return; /* empty string */
+        return;                 /* empty string */
     }
-    
+
     /* read file data */
     f = fopen(file_name, FOPEN_RBIN_MODE);
     if (f == NULL) {
         xfree(file_name);
         return;
     }
-    if (fseek(f, (long)offset, SEEK_SET) != 0) {
+    /* recorder_record_input(file_name); */
+    if (fseek(f, (long) offset, SEEK_SET) != 0) {
         xfree(file_name);
         return;
     }
@@ -1090,16 +1095,16 @@
     int eflags = 0;
     int ret;
     char *str;
-    
+
     if (icase) {
         cflags |= REG_ICASE;
     }
-    
+
     if (poolptr + 10 >= poolsize) {
         poolptr = poolsize;
         return;
     }
-    
+
     str = makecstring(s);
     ret = regcomp(&preg, str, cflags);
     if (ret != 0) {
@@ -1115,24 +1120,24 @@
         sub_match_count = ((subcount < 0) ? DEFAULT_SUB_MATCH_COUNT : subcount);
         xfree(pmatch);
         if (sub_match_count > 0) {
-           pmatch = xtalloc(sub_match_count, regmatch_t);
+            pmatch = xtalloc(sub_match_count, regmatch_t);
         }
         ret = regexec(&preg, str, sub_match_count, pmatch, eflags);
         xfree(match_string);
         match_string = xstrdup(str);
         strpool[poolptr++] = ((ret == 0) ? '1' : '0');
     }
-    
+
     regfree(&preg);
 }
 
 void getmatch(int i)
 {
     int size, len = 0;          /* to avoid warning about uninitialized use of len */
-    
+
     boolean found = i < sub_match_count
         && match_string != NULL && pmatch[i].rm_so >= 0 && i >= 0;
-    
+
     if (found) {
         len = pmatch[i].rm_eo - pmatch[i].rm_so;
         size = 20 + len;
@@ -1140,12 +1145,12 @@
     } else {
         size = 4;
     }
-    
+
     if (poolptr + size >= poolsize) {
         poolptr = poolsize;
         return;
     }
-    
+
     if (found) {
         int j = snprintf((char *) &strpool[poolptr], 20, "%d",
                          (int) pmatch[i].rm_so);
@@ -1157,7 +1162,7 @@
         poolptr += len;
         return;
     }
-    
+
     strpool[poolptr++] = '-';
     strpool[poolptr++] = '1';
     strpool[poolptr++] = '-';
@@ -1639,7 +1644,7 @@
 void pdfshipoutend(boolean shipping_page)
 {
     if (pos_stack_used > 0) {
-        pdftex_warn("%u unmatched \\pdfsave after %s shipout",
+        pdftex_fail("%u unmatched \\pdfsave after %s shipout",
                     (unsigned int) pos_stack_used,
                     ((shipping_page) ? "page" : "form"));
     }
--- tetex-src-3.0/texk/web2c/pdftexdir/vfpacket.c.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/vfpacket.c	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2002 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,32 +13,31 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: //depot/Build/source.development/TeX/texk/web2c/pdftexdir/vfpacket.c#7 $
+$Id: vfpacket.c 217 2007-07-31 16:55:39Z oneiros $
 */
 
 #include "ptexlib.h"
 
 typedef struct {
-    internalfontnumber font;
     char *dataptr;
-    int  len;
+    integer len;
 } packet_entry;
 
 /* define packet_ptr, packet_array & packet_limit */
-define_array(packet);   
+define_array(packet);
 
 typedef struct {
     char **data;
     int *len;
-    internalfontnumber font;
-}  vf_entry;
+    int char_count;
+} vf_entry;
 
 /* define vf_ptr, vf_array & vf_limit */
-define_array(vf);   
+define_array(vf);
 
 static char *packet_data_ptr;
 
@@ -48,27 +47,38 @@
     alloc_array(vf, 1, SMALL_ARRAY_SIZE);
     vf_ptr->len = xtalloc(n, int);
     vf_ptr->data = xtalloc(n, char *);
+    vf_ptr->char_count = n;
     for (i = 0; i < n; i++) {
         vf_ptr->data[i] = NULL;
         vf_ptr->len[i] = 0;
     }
-    vf_ptr->font = f;
     return vf_ptr++ - vf_array;
 }
 
-void storepacket(integer f, integer c, integer s)
+void storepacket(internalfontnumber f, eightbits c, strnumber s)
 {
     int l = strstart[s + 1] - strstart[s];
     vf_array[vfpacketbase[f]].len[c - fontbc[f]] = l;
     vf_array[vfpacketbase[f]].data[c - fontbc[f]] = xtalloc(l, char);
-    memcpy((void *)vf_array[vfpacketbase[f]].data[c - fontbc[f]], 
-           (void *)(strpool + strstart[s]), (unsigned)l);
+    memcpy((void *) vf_array[vfpacketbase[f]].data[c - fontbc[f]],
+           (void *) (strpool + strstart[s]), (unsigned) l);
+}
+
+void startpacket(internalfontnumber f, eightbits c)
+{
+    packet_data_ptr = vf_array[vfpacketbase[f]].data[c - fontbc[f]];
+    vfpacketlength = vf_array[vfpacketbase[f]].len[c - fontbc[f]];
+}
+
+eightbits packetbyte()
+{
+    vfpacketlength--;
+    return *packet_data_ptr++;
 }
 
 void pushpacketstate()
 {
     alloc_array(packet, 1, SMALL_ARRAY_SIZE);
-    packet_ptr->font = f;
     packet_ptr->dataptr = packet_data_ptr;
     packet_ptr->len = vfpacketlength;
     packet_ptr++;
@@ -79,33 +89,18 @@
     if (packet_ptr == packet_array)
         pdftex_fail("packet stack empty, impossible to pop");
     packet_ptr--;
-    f = packet_ptr->font;
     packet_data_ptr = packet_ptr->dataptr;
     vfpacketlength = packet_ptr->len;
 }
 
-void startpacket(internalfontnumber f, integer c)
-{
-    packet_data_ptr = vf_array[vfpacketbase[f]].data[c - fontbc[f]];
-    vfpacketlength = vf_array[vfpacketbase[f]].len[c - fontbc[f]];
-}
-
-eightbits packetbyte()
-{
-    vfpacketlength--;
-    return *packet_data_ptr++;
-}
-
 void vf_free(void)
 {
     vf_entry *v;
-    int n;
     char **p;
     if (vf_array != NULL) {
         for (v = vf_array; v < vf_ptr; v++) {
             xfree(v->len);
-            n = fontec[v->font] - fontbc[v->font] + 1;
-            for (p = v->data; p - v->data < n ; p++)
+            for (p = v->data; p - v->data < v->char_count; p++)
                 xfree(*p);
             xfree(v->data);
         }
@@ -113,3 +108,42 @@
     }
     xfree(packet_array);
 }
+
+/* this function was copied/borrowed/stolen from dvipdfm code */
+#define SIGNED_QUAD scaled
+#define fixword integer
+SIGNED_QUAD sqxfw(SIGNED_QUAD sq, fixword fw)
+{
+    int sign = 1;
+    unsigned long a, b, c, d, ad, bd, bc, ac;
+    unsigned long e, f, g, h, i, j, k;
+    unsigned long result;
+    /* Make positive. */
+    if (sq < 0) {
+        sign = -sign;
+        sq = -sq;
+    }
+    if (fw < 0) {
+        sign = -sign;
+        fw = -fw;
+    }
+    a = ((unsigned long) sq) >> 16u;
+    b = ((unsigned long) sq) & 0xffffu;
+    c = ((unsigned long) fw) >> 16u;
+    d = ((unsigned long) fw) & 0xffffu;
+    ad = a * d;
+    bd = b * d;
+    bc = b * c;
+    ac = a * c;
+    e = bd >> 16u;
+    f = ad >> 16u;
+    g = ad & 0xffffu;
+    h = bc >> 16u;
+    i = bc & 0xffffu;
+    j = ac >> 16u;
+    k = ac & 0xffffu;
+    result = (e + g + i + (1 << 3)) >> 4u;      /* 1<<3 is for rounding */
+    result += (f + h + k) << 12u;
+    result += j << 28u;
+    return (sign > 0) ? result : -result;
+}
--- tetex-src-3.0/texk/web2c/pdftexdir/pdftex.ch.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/pdftex.ch	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 %
-% Copyright (c) 1996-2006 Han The Thanh, <thanh@pdftex.org>
+% Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 %
 % This file is part of pdfTeX.
 %
@@ -13,11 +13,11 @@
 % MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 % GNU General Public License for more details.
 %
-% You should have received a copy of the GNU General Public License
-% along with pdfTeX; if not, write to the Free Software
-% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+% You should have received a copy of the GNU General Public License along with
+% pdfTeX; if not, write to the Free Software Foundation, Inc., 51 Franklin
+% Street, Fifth Floor, Boston, MA 02110-1301 USA.
 %
-% $Id: //depot/Build/source.development/TeX/texk/web2c/pdfetexdir/pdfetex.ch2#20 $
+% $Id: pdftex.ch 217 2007-07-31 16:55:39Z oneiros $
 %
 @x [0.0] l.83 - WEAVE: we want the whole file
   \def\?##1]{\hbox{Changes to \hbox to 1em{\hfil##1}.\ }}
@@ -77,7 +77,7 @@
 @y
 @d pdftex_first_integer_code = web2c_int_pars {base for \pdfTeX's integer parameters}
 @z
- 
+
 % start of tex.pch
 @x (MLTeX) l. 12945
       begin i := char_tag(char_info(f)(c));
--- tetex-src-3.0/texk/web2c/pdftexdir/epdf.c.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/epdf.c	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2002 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: epdf.c,v 1.45 2006/08/20 10:56:04 hahe Exp hahe $
+$Id: epdf.c 217 2007-07-31 16:55:39Z oneiros $
 */
 
 #include "ptexlib.h"
@@ -29,7 +29,7 @@
 extern void register_fd_entry(fd_entry *);
 
 
-int is_subsetable(fm_entry *fm)
+int is_subsetable(fm_entry * fm)
 {
     assert(is_included(fm));
     return is_subsetted(fm);
--- tetex-src-3.0/texk/web2c/pdftexdir/writejbig2.c.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/writejbig2.c	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /***********************************************************************
-Copyright (c) 2002-2006 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 2002-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -14,8 +14,8 @@
 for more details.
 
 You should have received a copy of the GNU General Public License along
-with pdfTeX; if not, write to the Free Software Foundation, Inc., 59
-Temple Place, Suite 330, Boston, MA 02111-1307 USA
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
 This is experimental JBIG2 image support to pdfTeX. JBIG2 image decoding
 is part of Adobe PDF-1.4, and requires Acroread 5.0 or later.
@@ -75,7 +75,7 @@
 
 09 Dec. 2002: JBIG2 seg. page numbers > 0 are now set to 1, see PDF Ref.
 
-$Id: writejbig2.c,v 1.347 2006/05/31 19:18:32 hahe Exp hahe $
+$Id: writejbig2.c 217 2007-07-31 16:55:39Z oneiros $
 ***********************************************************************/
 
 #include "writejbig2.h"
--- tetex-src-3.0/texk/web2c/pdftexdir/writet1.c.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/writet1.c	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2006 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,31 +13,31 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: writet1.c,v 1.6 2006/12/12 20:38:11 hahe Exp hahe $
+$Id: writet1.c 217 2007-07-31 16:55:39Z oneiros $
 */
 
-#include "ptexlib.h"           
+#include "ptexlib.h"
 #include <kpathsea/c-vararg.h>
 #include <kpathsea/c-proto.h>
 #include <string.h>
 
-#define t1_log(s)           tex_printf(s)
-#define get_length1()       t1_length1 = t1_offset() - t1_save_offset
-#define get_length2()       t1_length2 = t1_offset() - t1_save_offset
+#define t1_log(s)        tex_printf("%s",s)
+#define get_length1()    t1_length1 = t1_offset() - t1_save_offset
+#define get_length2()    t1_length2 = t1_offset() - t1_save_offset
 #define get_length3()    t1_length3 = fixedcontent? t1_offset() - t1_save_offset : 0
-#define save_offset()       t1_save_offset = t1_offset()
+#define save_offset()    t1_save_offset = t1_offset()
 
 #define t1_open()        open_input(&t1_file, kpse_type1_format, FOPEN_RBIN_MODE)
 #define t1_close()       xfclose(t1_file, cur_file_name)
-#define t1_getchar()    getc(t1_file)
+#define t1_getchar()     getc(t1_file)
 #define t1_putchar       fb_putchar
 #define t1_offset        fb_offset
-#define t1_ungetchar(c) ungetc(c, t1_file)
-#define t1_eof()        feof(t1_file)
+#define t1_ungetchar(c)  ungetc(c, t1_file)
+#define t1_eof()         feof(t1_file)
 
 #define t1_prefix(s)     str_prefix(t1_line_array, s)
 #define t1_buf_prefix(s) str_prefix(t1_buf_array, s)
@@ -50,31 +50,31 @@
 
 #define enc_open()       open_input(&enc_file, kpse_enc_format, FOPEN_RBIN_MODE)
 #define enc_close()      xfclose(enc_file, cur_file_name)
-#define enc_getchar()   getc(enc_file)
-#define enc_eof()       feof(enc_file)
+#define enc_getchar()    getc(enc_file)
+#define enc_eof()        feof(enc_file)
 
 #define valid_code(c)    (c >= 0 && c < 256)
 #define fixedcontent     false
 
 static const char *standard_glyph_names[256] = {
     /* 0x00 */
-notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,
+    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,
     notdef, notdef, notdef, notdef, notdef, notdef, notdef,
     /* 0x10 */
-notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,
+    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,
     notdef, notdef, notdef, notdef, notdef, notdef, notdef,
     /* 0x20 */
     "space", "exclam", "quotedbl", "numbersign", "dollar", "percent",
     "ampersand", "quoteright", "parenleft", "parenright", "asterisk",
     "plus", "comma", "hyphen", "period", "slash",
     /* 0x30 */
-"zero", "one", "two", "three", "four", "five", "six", "seven", "eight",
+    "zero", "one", "two", "three", "four", "five", "six", "seven", "eight",
     "nine", "colon", "semicolon", "less", "equal", "greater", "question",
     /* 0x40 */
     "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N",
     "O",
     /* 0x50 */
-"P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft",
+    "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft",
     "backslash", "bracketright", "asciicircum", "underscore",
     /* 0x60 */
     "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l",
@@ -83,14 +83,14 @@
     "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar",
     "braceright", "asciitilde", notdef,
     /* 0x80 */
-notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,
+    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,
     notdef, notdef, notdef, notdef, notdef, notdef, notdef,
     /* 0x90 */
-notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,
+    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,
     notdef, notdef, notdef, notdef, notdef, notdef, notdef,
     /* 0xa0 */
-notdef, "exclamdown", "cent", "sterling", "fraction", "yen", "florin",
-"section", "currency", "quotesingle", "quotedblleft", "guillemotleft",
+    notdef, "exclamdown", "cent", "sterling", "fraction", "yen", "florin",
+    "section", "currency", "quotesingle", "quotedblleft", "guillemotleft",
     "guilsinglleft", "guilsinglright", "fi", "fl",
     /* 0xb0 */
     notdef, "endash", "dagger", "daggerdbl", "periodcentered", notdef,
@@ -123,54 +123,54 @@
 
 enum { ENC_STANDARD, ENC_BUILTIN } t1_encoding;
 
-#define T1_BUF_SIZE   0x10
-#define ENC_BUF_SIZE  0x1000
+#define T1_BUF_SIZE      0x10
+#define ENC_BUF_SIZE     0x1000
 
-#define CS_HSTEM            1
-#define CS_VSTEM            3
-#define CS_VMOVETO          4
-#define CS_RLINETO          5
-#define CS_HLINETO          6
-#define CS_VLINETO          7
-#define CS_RRCURVETO        8
-#define CS_CLOSEPATH        9
-#define CS_CALLSUBR         10
-#define CS_RETURN           11
-#define CS_ESCAPE           12
-#define CS_HSBW             13
-#define CS_ENDCHAR          14
-#define CS_RMOVETO          21
-#define CS_HMOVETO          22
-#define CS_VHCURVETO        30
-#define CS_HVCURVETO        31
-#define CS_1BYTE_MAX        (CS_HVCURVETO + 1)
-
-#define CS_DOTSECTION       CS_1BYTE_MAX + 0
-#define CS_VSTEM3           CS_1BYTE_MAX + 1
-#define CS_HSTEM3           CS_1BYTE_MAX + 2
-#define CS_SEAC             CS_1BYTE_MAX + 6
-#define CS_SBW              CS_1BYTE_MAX + 7
-#define CS_DIV              CS_1BYTE_MAX + 12
-#define CS_CALLOTHERSUBR    CS_1BYTE_MAX + 16
-#define CS_POP              CS_1BYTE_MAX + 17
-#define CS_SETCURRENTPOINT  CS_1BYTE_MAX + 33
-#define CS_2BYTE_MAX        (CS_SETCURRENTPOINT + 1)
-#define CS_MAX              CS_2BYTE_MAX
+#define CS_HSTEM         1
+#define CS_VSTEM         3
+#define CS_VMOVETO       4
+#define CS_RLINETO       5
+#define CS_HLINETO       6
+#define CS_VLINETO       7
+#define CS_RRCURVETO     8
+#define CS_CLOSEPATH     9
+#define CS_CALLSUBR      10
+#define CS_RETURN        11
+#define CS_ESCAPE        12
+#define CS_HSBW          13
+#define CS_ENDCHAR       14
+#define CS_RMOVETO       21
+#define CS_HMOVETO       22
+#define CS_VHCURVETO     30
+#define CS_HVCURVETO     31
+#define CS_1BYTE_MAX     (CS_HVCURVETO + 1)
+
+#define CS_DOTSECTION    CS_1BYTE_MAX + 0
+#define CS_VSTEM3        CS_1BYTE_MAX + 1
+#define CS_HSTEM3        CS_1BYTE_MAX + 2
+#define CS_SEAC          CS_1BYTE_MAX + 6
+#define CS_SBW           CS_1BYTE_MAX + 7
+#define CS_DIV           CS_1BYTE_MAX + 12
+#define CS_CALLOTHERSUBR CS_1BYTE_MAX + 16
+#define CS_POP           CS_1BYTE_MAX + 17
+#define CS_SETCURRENTPOINT CS_1BYTE_MAX + 33
+#define CS_2BYTE_MAX     (CS_SETCURRENTPOINT + 1)
+#define CS_MAX           CS_2BYTE_MAX
 
 typedef unsigned char byte;
 
 typedef struct {
-    byte nargs;     /* number of arguments */
-    boolean bottom; /* take arguments from bottom of stack? */
-    boolean clear;  /* clear stack? */
+    byte nargs;                 /* number of arguments */
+    boolean bottom;             /* take arguments from bottom of stack? */
+    boolean clear;              /* clear stack? */
     boolean valid;
-} cc_entry; /* CharString Command */
+} cc_entry;                     /* CharString Command */
 
 typedef struct {
-    char *name;             /* glyph name (or notdef for Subrs entry) */
+    char *name;                 /* glyph name (or notdef for Subrs entry) */
     byte *data;
-    unsigned short len;     /* length of the whole string */
-    unsigned short cslen;   /* length of the encoded part of the string */
+    unsigned short len;         /* length of the whole string */
+    unsigned short cslen;       /* length of the encoded part of the string */
     boolean used;
     boolean valid;
 } cs_entry;
@@ -183,11 +183,11 @@
 
 /* define t1_line_ptr, t1_line_array & t1_line_limit */
 typedef char t1_line_entry;
-define_array(t1_line);   
+define_array(t1_line);
 
 /* define t1_buf_ptr, t1_buf_array & t1_buf_limit */
 typedef char t1_buf_entry;
-define_array(t1_buf);   
+define_array(t1_buf);
 
 static int cs_start;
 
@@ -200,21 +200,21 @@
 static int subr_max, subr_size, subr_size_pos;
 
 /* This list contains the begin/end tokens commonly used in the */
-/* /Subrs array of a Type 1 font.                                */
+/* /Subrs array of a Type 1 font.                               */
 
 static const char *cs_token_pairs_list[][2] = {
-  {" RD", "NP"},
-  {" -|", "|"},
-  {" RD", "noaccess put"},
-  {" -|", "noaccess put"},
-  {NULL, NULL}
+    {" RD", "NP"},
+    {" -|", "|"},
+    {" RD", "noaccess put"},
+    {" -|", "noaccess put"},
+    {NULL, NULL}
 };
 static const char **cs_token_pair;
 
 static boolean t1_pfa, t1_cs, t1_scan, t1_eexec_encrypt, t1_synthetic;
-static int  t1_in_eexec; /* 0 before eexec-encrypted, 1 during, 2 after */
+static int t1_in_eexec;         /* 0 before eexec-encrypted, 1 during, 2 after */
 static long t1_block_length;
-static int  last_hexbyte;
+static int last_hexbyte;
 static FILE *t1_file;
 static FILE *enc_file;
 
@@ -222,7 +222,7 @@
 {
     char *p;
     int c;
-restart:
+  restart:
     if (enc_eof())
         pdftex_fail("unexpected end of file");
     p = enc_line;
@@ -245,7 +245,7 @@
     char **glyph_names;
     set_cur_file_name(enc_name);
     if (!enc_open()) {
-        pdftex_warn("cannot open encoding file for reading");
+        pdftex_fail("cannot open encoding file for reading");
         cur_file_name = NULL;
         return NULL;
     }
@@ -261,7 +261,7 @@
             ("invalid encoding vector (a name or `[' missing): `%s'", enc_line);
     }
     names_count = 0;
-    r++; /* skip '[' */
+    r++;                        /* skip '[' */
     skip(r, ' ');
     for (;;) {
         while (*r == '/') {
@@ -288,7 +288,7 @@
         enc_getline();
         r = enc_line;
     }
-done:
+  done:
     enc_close();
     t1_log("}");
     cur_file_name = NULL;
@@ -356,29 +356,29 @@
             cipher = t1_getbyte();
         last_hexbyte = cipher = (hexval(cipher) << 4) + hexval(t1_getbyte());
     }
-    plain = (cipher^(t1_dr >> 8));
-    t1_dr = (cipher + t1_dr)*t1_c1 + t1_c2;
+    plain = (cipher ^ (t1_dr >> 8));
+    t1_dr = (cipher + t1_dr) * t1_c1 + t1_c2;
     return plain;
 }
 
 static byte cdecrypt(byte cipher, unsigned short *cr)
 {
     const byte plain = (cipher ^ (*cr >> 8));
-    *cr = (cipher + *cr)*t1_c1 + t1_c2;
+    *cr = (cipher + *cr) * t1_c1 + t1_c2;
     return plain;
 }
 
 static byte eencrypt(byte plain)
 {
     const byte cipher = (plain ^ (t1_er >> 8));
-    t1_er = (cipher + t1_er)*t1_c1 + t1_c2;
+    t1_er = (cipher + t1_er) * t1_c1 + t1_c2;
     return cipher;
 }
 
 static byte cencrypt(byte plain, unsigned short *cr)
 {
     const byte cipher = (plain ^ (*cr >> 8));
-    *cr = (cipher + *cr)*t1_c1 + t1_c2;
+    *cr = (cipher + *cr) * t1_c1 + t1_c2;
     return cipher;
 }
 
@@ -401,15 +401,15 @@
         pdftex_fail("a number expected: `%s'", t1_line_array);
     }
     if (r != NULL) {
-        for (; isdigit(*p) || *p == '.' || 
-               *p == 'e' || *p == 'E' || *p == '+' || *p == '-'; p++);
+        for (; isdigit(*p) || *p == '.' ||
+             *p == 'e' || *p == 'E' || *p == '+' || *p == '-'; p++);
         *r = p;
     }
     return f;
 }
 
-static boolean str_suffix(const char *begin_buf, const char *end_buf, 
-                          const char *s) 
+static boolean str_suffix(const char *begin_buf, const char *end_buf,
+                          const char *s)
 {
     const char *s1 = end_buf - 1, *s2 = strend(s) - 1;
     if (*s1 == 10)
@@ -421,13 +421,13 @@
     return s2 < s;
 }
 
-static void t1_getline(void) 
+static void t1_getline(void)
 {
     int c, l, eexec_scan;
     char *p;
     static const char eexec_str[] = "currentfile eexec";
-    static int eexec_len = 17; /* strlen(eexec_str) */
-restart:
+    static int eexec_len = 17;  /* strlen(eexec_str) */
+  restart:
     if (t1_eof())
         pdftex_fail("unexpected end of file");
     t1_line_ptr = t1_line_array;
@@ -438,7 +438,7 @@
     if (c == EOF)
         goto exit;
     while (!t1_eof()) {
-        if (t1_in_eexec == 1) 
+        if (t1_in_eexec == 1)
             c = edecrypt(c);
         alloc_array(t1_line, 1, T1_BUF_SIZE);
         append_char_to_buf(c, t1_line_ptr, t1_line_array, t1_line_limit);
@@ -450,37 +450,37 @@
         }
         if (c == 10 || (t1_pfa && eexec_scan == eexec_len && c == 32))
             break;
-        if (t1_cs && t1_cslen == 0 && (t1_line_ptr - t1_line_array > 4) && 
-           (t1_suffix(" RD ") || t1_suffix(" -| "))) {
+        if (t1_cs && t1_cslen == 0 && (t1_line_ptr - t1_line_array > 4) &&
+            (t1_suffix(" RD ") || t1_suffix(" -| "))) {
             p = t1_line_ptr - 5;
             while (*p != ' ')
                 p--;
             t1_cslen = l = t1_scan_num(p + 1, 0);
-            cs_start = t1_line_ptr - t1_line_array; /* cs_start is an index now */
+            cs_start = t1_line_ptr - t1_line_array;     /* cs_start is an index now */
             alloc_array(t1_line, l, T1_BUF_SIZE);
             while (l-- > 0)
                 *t1_line_ptr++ = edecrypt(t1_getbyte());
         }
         c = t1_getbyte();
     }
-    alloc_array(t1_line, 2, T1_BUF_SIZE); /* append_eol can append 2 chars */
+    alloc_array(t1_line, 2, T1_BUF_SIZE);       /* append_eol can append 2 chars */
     append_eol(t1_line_ptr, t1_line_array, t1_line_limit);
     if (t1_line_ptr - t1_line_array < 2)
         goto restart;
     if (eexec_scan == eexec_len)
         t1_in_eexec = 1;
-exit:
+  exit:
     /* ensure that t1_buf_array has as much room as t1_line_array */
     t1_buf_ptr = t1_buf_array;
     alloc_array(t1_buf, t1_line_limit, t1_line_limit);
 }
 
-static void t1_putline(void) 
+static void t1_putline(void)
 {
     char *p = t1_line_array;
     if (t1_line_ptr - t1_line_array <= 1)
         return;
-    if (t1_eexec_encrypt)  {
+    if (t1_eexec_encrypt) {
         while (p < t1_line_ptr)
             t1_putchar(eencrypt(*p++));
     } else
@@ -497,16 +497,16 @@
 }
 
 __attribute__ ((format(printf, 1, 2)))
-static void t1_printf(const char *fmt,...)
+static void t1_printf(const char *fmt, ...)
 {
     va_list args;
     va_start(args, fmt);
     vsprintf(t1_line_array, fmt, args);
-    t1_puts(t1_line_array);                                    
+    t1_puts(t1_line_array);
     va_end(args);
 }
 
-static void t1_init_params(const char *open_name_prefix) 
+static void t1_init_params(const char *open_name_prefix)
 {
     t1_log(open_name_prefix);
     t1_log(cur_file_name);
@@ -533,15 +533,13 @@
 {
     int l, c;
     if (t1_block_length == 0)
-       return;
+        return;
     c = t1_getbyte();
-    if (decrypt) 
+    if (decrypt)
         c = edecrypt(c);
     l = t1_block_length;
     if (!(l == 0 && (c == 10 || c == 13))) {
-        pdftex_warn("%i bytes more than expected were ignored", l + 1);
-        while (l-- > 0)
-            t1_getbyte();
+        pdftex_fail("%i bytes more than expected", l + 1);
     }
 }
 
@@ -549,8 +547,8 @@
 {
     int i;
     assert(is_included(fd_cur->fm));
-        get_length1();
-        save_offset();
+    get_length1();
+    save_offset();
     if (!t1_pfa)
         t1_check_block_len(false);
     for (t1_line_ptr = t1_line_array, i = 0; i < 4; i++) {
@@ -558,15 +556,15 @@
         *t1_line_ptr++ = 0;
     }
     t1_eexec_encrypt = true;
-        t1_putline(); /* to put the first four bytes */
+    t1_putline();               /* to put the first four bytes */
 }
 
 static void t1_stop_eexec(void)
 {
     int c;
     assert(is_included(fd_cur->fm));
-        get_length2();
-        save_offset();
+    get_length2();
+    save_offset();
     t1_eexec_encrypt = false;
     if (!t1_pfa)
         t1_check_block_len(true);
@@ -576,7 +574,7 @@
             if (last_hexbyte == 0)
                 t1_puts("00");
             else
-                pdftex_warn("unexpected data after eexec");
+                pdftex_fail("unexpected data after eexec");
         }
     }
     t1_cs = false;
@@ -604,28 +602,28 @@
 
 static void t1_modify_fm(void)
 {
- /*
-  * font matrix is given as six numbers a0..a5, which stands for the matrix
-  * 
-  *           a0 a1 0
-  *     M =   a2 a3 0
-  *           a4 a5 1
-  * 
-  * ExtendFont is given as
-  * 
-  *           e 0 0
-  *     E =   0 1 0
-  *           0 0 1
-  * 
-  * SlantFont is given as
-  * 
-  *           1 0 0
-  *     S =   s 1 0
-  *           0 0 1
-  * 
+    /*
+     * font matrix is given as six numbers a0..a5, which stands for the matrix
+     *
+     *           a0 a1 0
+     *     M =   a2 a3 0
+     *           a4 a5 1
+     *
+     * ExtendFont is given as
+     *
+     *           e 0 0
+     *     E =   0 1 0
+     *           0 0 1
+     *
+     * SlantFont is given as
+     *
+     *           1 0 0
+     *     S =   s 1 0
+     *           0 0 1
+     *
      * The slant transform must be done _before_ the extend transform
      * for compatibility!
-  */
+     */
     float a[6];
     int i, c;
     char *p, *q, *r;
@@ -634,7 +632,7 @@
             remove_eol(p, t1_line_array);
             pdftex_fail("FontMatrix: an array expected: `%s'", t1_line_array);
         }
-    c = *p++; /* save the character '[' resp. '{' */
+    c = *p++;                   /* save the character '[' resp. '{' */
     strncpy(t1_buf_array, t1_line_array, (size_t) (p - t1_line_array));
     r = t1_buf_array + (p - t1_line_array);
     for (i = 0; i < 6; i++) {
@@ -709,7 +707,7 @@
     for (key = (key_entry *) font_key; key - font_key < FONT_KEYS_NUM; key++) {
         if (key->t1name[0] != '\0' &&
             str_prefix(t1_line_array + 1, key->t1name))
-          break;
+            break;
     }
     if (key - font_key == FONT_KEYS_NUM)
         return;
@@ -720,7 +718,7 @@
             remove_eol(p, t1_line_array);
             pdftex_fail("a name expected: `%s'", t1_line_array);
         }
-        r = ++p; /* skip the slash */
+        r = ++p;                /* skip the slash */
         for (q = t1_buf_array; *p != ' ' && *p != 10; *q++ = *p++);
         *q = 0;
         if (fm_slant(fd_cur->fm) != 0) {
@@ -732,7 +730,7 @@
         }
         xfree(fd_cur->fontname);
         fd_cur->fontname = xstrdup(t1_buf_array);
-        /* at this moment we cannot call make_subset_tag() yet, as the encoding 
+        /* at this moment we cannot call make_subset_tag() yet, as the encoding
          * is not read; thus we mark the offset of the subset tag and write it
          * later */
         if (is_subsetted(fd_cur->fm)) {
@@ -759,7 +757,7 @@
     fd_cur->font_dim[k].set = true;
 }
 
-static void t1_scan_param(void) 
+static void t1_scan_param(void)
 {
     static const char *lenIV = "/lenIV";
     if (!t1_scan || *t1_line_array != '/')
@@ -775,7 +773,7 @@
 {
     if (glyph_names[b] != notdef) {
         xfree(glyph_names[b]);
-        glyph_names[b] = (char*) notdef;
+        glyph_names[b] = (char *) notdef;
     }
     if (glyph_names[a] != notdef) {
         glyph_names[b] = xstrdup(glyph_names[a]);
@@ -792,40 +790,40 @@
     glyph_names = xtalloc(256, char *);
     for (i = 0; i < 256; i++)
         glyph_names[i] = (char *) notdef;
-    if (t1_suffix("def")) { /* predefined encoding */
+    if (t1_suffix("def")) {     /* predefined encoding */
         sscanf(t1_line_array + strlen("/Encoding"), "%256s", t1_buf_array);
         if (strcmp(t1_buf_array, "StandardEncoding") == 0) {
             t1_encoding = ENC_STANDARD;
             for (i = 0; i < 256; i++) {
                 if (standard_glyph_names[i] != notdef)
                     glyph_names[i] = xstrdup(standard_glyph_names[i]);
-        }
+            }
             return glyph_names;
-    } else
+        } else
             pdftex_fail
                 ("cannot subset font (unknown predefined encoding `%s')",
                  t1_buf_array);
     }
     /* At this moment "/Encoding" is the prefix of t1_line_array, and the encoding is
      * not a predefined encoding.
-    * 
-    * We have two possible forms of Encoding vector. The first case is
-    * 
-    *     /Encoding [/a /b /c...] readonly def
-    * 
-    * and the second case can look like
-    * 
-    *     /Encoding 256 array 0 1 255 {1 index exch /.notdef put} for
-    *     dup 0 /x put
-    *     dup 1 /y put
-    *     ...
-    *     readonly def
-    */
+     *
+     * We have two possible forms of Encoding vector. The first case is
+     *
+     *     /Encoding [/a /b /c...] readonly def
+     *
+     * and the second case can look like
+     *
+     *     /Encoding 256 array 0 1 255 {1 index exch /.notdef put} for
+     *     dup 0 /x put
+     *     dup 1 /y put
+     *     ...
+     *     readonly def
+     */
     t1_encoding = ENC_BUILTIN;
-    if (t1_prefix("/Encoding [") || t1_prefix("/Encoding[")) { /* the first case */
+    if (t1_prefix("/Encoding [") || t1_prefix("/Encoding[")) {  /* the first case */
         r = strchr(t1_line_array, '[') + 1;
         skip(r, ' ');
-        for(;;) {
+        for (;;) {
             while (*r == '/') {
                 for (p = t1_buf_array, r++;
                      *r != 32 && *r != 10 && *r != ']' && *r != '/';
@@ -846,23 +844,23 @@
                     remove_eol(r, t1_line_array);
                     pdftex_fail
                         ("a name or `] def' or `] readonly def' expected: `%s'",
-                                t1_line_array);
+                         t1_line_array);
                 }
             }
             t1_getline();
             r = t1_line_array;
         }
     } else {                    /* the second case */
-        p = strchr(t1_line_array, 10); 
+        p = strchr(t1_line_array, 10);
         for (;;) {
             if (*p == 10) {
                 t1_getline();
                 p = t1_line_array;
             }
             /*
-             check for `dup <index> <glyph> put'
+               check for `dup <index> <glyph> put'
              */
-            if (sscanf(p, "dup %i%256s put", &i, t1_buf_array) == 2 && 
+            if (sscanf(p, "dup %i%256s put", &i, t1_buf_array) == 2 &&
                 *t1_buf_array == '/' && valid_code(i)) {
                 if (strcmp(t1_buf_array + 1, notdef) != 0)
                     glyph_names[i] = xstrdup(t1_buf_array + 1);
@@ -870,7 +868,7 @@
                 skip(p, ' ');
             }
             /*
-             check for `dup dup <to> exch <from> get put'
+               check for `dup dup <to> exch <from> get put'
              */
             else if (sscanf(p, "dup dup %i exch %i get put", &b, &a) == 2
                      && valid_code(a) && valid_code(b)) {
@@ -879,7 +877,7 @@
                 skip(p, ' ');
             }
             /*
-             check for `dup dup <from> <size> getinterval <to> exch putinterval'
+               check for `dup dup <from> <size> getinterval <to> exch putinterval'
              */
             else if (sscanf
                      (p, "dup dup %i %i getinterval %i exch putinterval",
@@ -891,17 +889,17 @@
                 skip(p, ' ');
             }
             /*
-             check for `def' or `readonly def'
+               check for `def' or `readonly def'
              */
             else if ((p == t1_line_array || (p > t1_line_array && p[-1] == ' '))
                      && strcmp(p, "def\n") == 0)
                 return glyph_names;
-            /* 
-             skip an unrecognizable word 
+            /*
+               skip an unrecognizable word
              */
             else {
                 while (*p != ' ' && *p != 10)
-                    p++;    
+                    p++;
                 skip(p, ' ');
             }
         }
@@ -922,11 +920,12 @@
 {
     ff_entry *ff;
     ff = check_ff_exist(fd_cur->fm->ff_name, is_truetype(fd_cur->fm));
-    if (ff->ff_path != NULL)
+    if (ff->ff_path != NULL) {
         t1_file = xfopen(cur_file_name = ff->ff_path, FOPEN_RBIN_MODE);
-    else {
+        /* recorder_record_input(ff->ff_path); */
+    } else {
         set_cur_file_name(fd_cur->fm->ff_name);
-        pdftex_warn("cannot open Type 1 font file for reading");
+        pdftex_fail("cannot open Type 1 font file for reading");
         return false;
     }
     t1_init_params(open_name_prefix);
@@ -956,10 +955,10 @@
     while (!t1_end_eexec());
     t1_stop_eexec();
     if (fixedcontent) {         /* copy 512 zeros (not needed for PDF) */
-    do {
-        t1_getline();
-        t1_putline();
-}
+        do {
+            t1_getline();
+            t1_putline();
+        }
         while (!t1_cleartomark());
         t1_check_end();         /* write "{restore}if" if found */
     }
@@ -972,8 +971,8 @@
 
 static const char **check_cs_token_pair()
 {
-    const char **p = (const char**) cs_token_pairs_list;
-    for (; p[0] != NULL; ++p) 
+    const char **p = (const char **) cs_token_pairs_list;
+    for (; p[0] != NULL; ++p)
         if (t1_buf_prefix(p[0]) && t1_buf_suffix(p[1]))
             return p;
     return NULL;
@@ -996,10 +995,10 @@
         if (cs_ptr - cs_tab > cs_size)
             pdftex_fail
                 ("CharStrings dict: more entries than dict size (%i)", cs_size);
-        if (strcmp(t1_buf_array + 1, notdef) == 0) /* skip the slash */
-            ptr->name = (char*) notdef;
+        if (strcmp(t1_buf_array + 1, notdef) == 0)      /* skip the slash */
+            ptr->name = (char *) notdef;
         else
-            ptr->name = xstrdup(t1_buf_array + 1); 
+            ptr->name = xstrdup(t1_buf_array + 1);
     }
     /* copy " RD " + cs data to t1_buf_array */
     memcpy(t1_buf_array, t1_line_array + cs_start - 4,
@@ -1017,28 +1016,28 @@
     ptr->valid = true;
 }
 
-#define store_subr()    cs_store(true)
-#define store_cs()      cs_store(false)
+#define store_subr()     cs_store(true)
+#define store_cs()       cs_store(false)
 
-#define CC_STACK_SIZE       24
+#define CC_STACK_SIZE    24
 
 static integer cc_stack[CC_STACK_SIZE], *stack_ptr = cc_stack;
 static cc_entry cc_tab[CS_MAX];
 static boolean is_cc_init = false;
 
-#define cc_pop(N)                       \
-    if (stack_ptr - cc_stack < (N))     \
-        stack_error(N);                 \
+#define cc_pop(N)                   \
+    if (stack_ptr - cc_stack < (N)) \
+        stack_error(N);             \
     stack_ptr -= N
 
-#define stack_error(N) {                \
-    pdftex_warn("CharString: invalid access (%i) to stack (%i entries)", \
-                 (int) N, (int)(stack_ptr - cc_stack));                  \
-    goto cs_error;                    \
+#define stack_error(N) {            \
+    pdftex_fail("CharString: invalid access (%i) to stack (%i entries)", \
+                (int) N, (int)(stack_ptr - cc_stack));                  \
+    goto cs_error;                  \
 }
 
 /*
-static integer cc_get(integer index) 
+static integer cc_get(integer index)
 {
     if (index <  0) {
         if (stack_ptr + index < cc_stack )
@@ -1061,7 +1060,7 @@
     cc_tab[N].bottom = B;  \
     cc_tab[N].clear = C;   \
     cc_tab[N].valid = true
-    
+
 static void cc_init(void)
 {
     int i;
@@ -1069,44 +1068,44 @@
         return;
     for (i = 0; i < CS_MAX; i++)
         cc_tab[i].valid = false;
-    set_cc(CS_HSTEM,           true,   2, true);
-    set_cc(CS_VSTEM,           true,   2, true);
-    set_cc(CS_VMOVETO,         true,   1, true);
-    set_cc(CS_RLINETO,         true,   2, true);
-    set_cc(CS_HLINETO,         true,   1, true);
-    set_cc(CS_VLINETO,         true,   1, true);
-    set_cc(CS_RRCURVETO,       true,   6, true);
-    set_cc(CS_CLOSEPATH,       false,  0, true);
-    set_cc(CS_CALLSUBR,        false,  1, false);
-    set_cc(CS_RETURN,          false,  0, false);
+    set_cc(CS_HSTEM, true, 2, true);
+    set_cc(CS_VSTEM, true, 2, true);
+    set_cc(CS_VMOVETO, true, 1, true);
+    set_cc(CS_RLINETO, true, 2, true);
+    set_cc(CS_HLINETO, true, 1, true);
+    set_cc(CS_VLINETO, true, 1, true);
+    set_cc(CS_RRCURVETO, true, 6, true);
+    set_cc(CS_CLOSEPATH, false, 0, true);
+    set_cc(CS_CALLSUBR, false, 1, false);
+    set_cc(CS_RETURN, false, 0, false);
     /*
-    set_cc(CS_ESCAPE,          false,  0, false);
-    */
-    set_cc(CS_HSBW,            true,   2, true);
-    set_cc(CS_ENDCHAR,         false,  0, true);
-    set_cc(CS_RMOVETO,         true,   2, true);
-    set_cc(CS_HMOVETO,         true,   1, true);
-    set_cc(CS_VHCURVETO,       true,   4, true);
-    set_cc(CS_HVCURVETO,       true,   4, true);
-    set_cc(CS_DOTSECTION,      false,  0, true);
-    set_cc(CS_VSTEM3,          true,   6, true);
-    set_cc(CS_HSTEM3,          true,   6, true);
-    set_cc(CS_SEAC,            true,   5, true);
-    set_cc(CS_SBW,             true,   4, true);
-    set_cc(CS_DIV,             false,  2, false);
-    set_cc(CS_CALLOTHERSUBR,   false,  0, false);
-    set_cc(CS_POP,             false,  0, false);
-    set_cc(CS_SETCURRENTPOINT, true,   2, true);
+       set_cc(CS_ESCAPE,          false,  0, false);
+     */
+    set_cc(CS_HSBW, true, 2, true);
+    set_cc(CS_ENDCHAR, false, 0, true);
+    set_cc(CS_RMOVETO, true, 2, true);
+    set_cc(CS_HMOVETO, true, 1, true);
+    set_cc(CS_VHCURVETO, true, 4, true);
+    set_cc(CS_HVCURVETO, true, 4, true);
+    set_cc(CS_DOTSECTION, false, 0, true);
+    set_cc(CS_VSTEM3, true, 6, true);
+    set_cc(CS_HSTEM3, true, 6, true);
+    set_cc(CS_SEAC, true, 5, true);
+    set_cc(CS_SBW, true, 4, true);
+    set_cc(CS_DIV, false, 2, false);
+    set_cc(CS_CALLOTHERSUBR, false, 0, false);
+    set_cc(CS_POP, false, 0, false);
+    set_cc(CS_SETCURRENTPOINT, true, 2, true);
     is_cc_init = true;
 }
 
-#define cs_getchar()    cdecrypt(*data++, &cr)
+#define cs_getchar()     cdecrypt(*data++, &cr)
 
-#define mark_subr(n)    cs_mark(0, n)
-#define mark_cs(s)      cs_mark(s, 0)
+#define mark_subr(n)     cs_mark(0, n)
+#define mark_cs(s)       cs_mark(s, 0)
 
 __attribute__ ((format(printf, 3, 4)))
-static void cs_warn(const char *cs_name, int subr, const char *fmt,...)
+static void cs_fail(const char *cs_name, int subr, const char *fmt, ...)
 {
     char buf[SMALL_BUF_SIZE];
     va_list args;
@@ -1114,9 +1113,9 @@
     vsprintf(buf, fmt, args);
     va_end(args);
     if (cs_name == NULL)
-        pdftex_warn("Subr (%i): %s", (int)subr, buf);
+        pdftex_fail("Subr (%i): %s", (int) subr, buf);
     else
-        pdftex_warn("CharString (/%s): %s", cs_name, buf);
+        pdftex_fail("CharString (/%s): %s", cs_name, buf);
 }
 
 static void cs_mark(const char *cs_name, int subr)
@@ -1125,8 +1124,8 @@
     int i, b, cs_len;
     integer a, a1, a2;
     unsigned short cr;
-    static integer lastargOtherSubr3 = 3; /* the argument of last call to 
-                                             OtherSubrs[3] */
+    static integer lastargOtherSubr3 = 3;       /* the argument of last call to
+                                                   OtherSubrs[3] */
     cs_entry *ptr;
     cc_entry *cc;
     if (cs_name == NULL) {
@@ -1135,7 +1134,7 @@
         if (!ptr->valid)
             return;
     } else {
-        if (cs_notdef != NULL && 
+        if (cs_notdef != NULL &&
             (cs_name == notdef || strcmp(cs_name, notdef) == 0))
             ptr = cs_notdef;
         else {
@@ -1153,9 +1152,9 @@
     /* only marked CharString entries and invalid entries can be skipped;
        valid marked subrs must be parsed to keep the stack in sync */
     if (!ptr->valid || (ptr->used && cs_name != NULL))
-        return; 
+        return;
     ptr->used = true;
-    cr = 4330; 
+    cr = 4330;
     cs_len = ptr->cslen;
     data = ptr->data + 4;
     for (i = 0; i < t1_lenIV; i++, cs_len--)
@@ -1174,10 +1173,10 @@
                 a = -((b - 251) << 8) - 108 - cs_getchar();
             } else {
                 cs_len -= 4;
-                a =  (cs_getchar() & 0xff) << 24;
+                a = (cs_getchar() & 0xff) << 24;
                 a |= (cs_getchar() & 0xff) << 16;
-                a |= (cs_getchar() & 0xff) <<  8;
-                a |= (cs_getchar() & 0xff) <<  0;
+                a |= (cs_getchar() & 0xff) << 8;
+                a |= (cs_getchar() & 0xff) << 0;
                 if (sizeof(integer) > 4 && (a & 0x80000000))
                     a |= ~0x7FFFFFFF;
             }
@@ -1188,24 +1187,24 @@
                 cs_len--;
             }
             if (b >= CS_MAX) {
-                cs_warn(cs_name, subr, "command value out of range: %i",
+                cs_fail(cs_name, subr, "command value out of range: %i",
                         (int) b);
                 goto cs_error;
             }
             cc = cc_tab + b;
             if (!cc->valid) {
-                cs_warn(cs_name, subr, "command not valid: %i", (int)b);
+                cs_fail(cs_name, subr, "command not valid: %i", (int) b);
                 goto cs_error;
             }
             if (cc->bottom) {
                 if (stack_ptr - cc_stack < cc->nargs)
-                    cs_warn(cs_name, subr, 
+                    cs_fail(cs_name, subr,
                             "less arguments on stack (%i) than required (%i)",
-                            (int)(stack_ptr - cc_stack), (int)cc->nargs);
+                            (int) (stack_ptr - cc_stack), (int) cc->nargs);
                 else if (stack_ptr - cc_stack > cc->nargs)
-                    cs_warn(cs_name, subr, 
+                    cs_fail(cs_name, subr,
                             "more arguments on stack (%i) than required (%i)",
-                            (int)(stack_ptr - cc_stack), (int)cc->nargs);
+                            (int) (stack_ptr - cc_stack), (int) cc->nargs);
             }
             switch (cc - cc_tab) {
             case CS_CALLSUBR:
@@ -1213,7 +1212,7 @@
                 cc_pop(1);
                 mark_subr(a1);
                 if (!subr_tab[a1].valid) {
-                    cs_warn(cs_name, subr, "cannot call subr (%i)", (int) a1);
+                    cs_fail(cs_name, subr, "cannot call subr (%i)", (int) a1);
                     goto cs_error;
                 }
                 break;
@@ -1231,7 +1230,7 @@
                 cc_push(lastargOtherSubr3);
                 /* the only case when we care about the value being pushed onto
                    stack is when POP follows CALLOTHERSUBR (changing hints by
-                   OtherSubrs[3]) 
+                   OtherSubrs[3])
                  */
                 break;
             case CS_SEAC:
@@ -1248,7 +1247,7 @@
         }
     }
     return;
-cs_error: /* an error occured during parsing */
+  cs_error:                    /* an error occured during parsing */
     cc_clear();
     ptr->valid = false;
     ptr->used = false;
@@ -1318,7 +1317,7 @@
                     assert(aa != NULL);
                 }
             }
-    }
+        }
         make_subset_tag(fd_cur);
         assert(t1_fontname_offset != 0);
         strncpy(fb_array + t1_fontname_offset, fd_cur->subset_tag, 6);
@@ -1341,25 +1340,25 @@
         }
         destroy_t1_glyph_tree(gl_tree);
         if (j == 0)
-        /* We didn't mark anything for the Encoding array. */
-        /* We add "dup 0 /.notdef put" for compatibility   */
-        /* with Acrobat 5.0.                               */
+            /* We didn't mark anything for the Encoding array. */
+            /* We add "dup 0 /.notdef put" for compatibility   */
+            /* with Acrobat 5.0.                               */
             t1_puts("dup 0 /.notdef put\n");
         t1_puts("readonly def\n");
     }
     do {
         t1_getline();
         t1_scan_param();
-        if (!t1_prefix("/UniqueID")) /* ignore UniqueID for subsetted fonts */
+        if (!t1_prefix("/UniqueID"))    /* ignore UniqueID for subsetted fonts */
             t1_putline();
-}
+    }
     while (t1_in_eexec == 0);
 }
 
 static void cs_init(void)
 {
     cs_ptr = cs_tab = NULL;
-    cs_dict_start =  cs_dict_end = NULL;
+    cs_dict_start = cs_dict_end = NULL;
     cs_count = cs_size = cs_size_pos = 0;
     cs_token_pair = NULL;
     subr_tab = NULL;
@@ -1367,7 +1366,7 @@
     subr_max = subr_size = subr_size_pos = 0;
 }
 
-static void init_cs_entry(cs_entry *cs)
+static void init_cs_entry(cs_entry * cs)
 {
     cs->data = NULL;
     cs->name = NULL;
@@ -1383,16 +1382,17 @@
     cs_entry *ptr;
     t1_getline();
     while (!(t1_charstrings() || t1_subrs())) {
-        t1_scan_param(); 
-        t1_putline();
+        t1_scan_param();
+        if (!t1_prefix("/UniqueID"))    /* ignore UniqueID for subsetted fonts */
+            t1_putline();
         t1_getline();
     }
-found:
+  found:
     t1_cs = true;
     t1_scan = false;
     if (!t1_subrs())
-       return;
-    subr_size_pos = strlen("/Subrs") + 1; 
+        return;
+    subr_size_pos = strlen("/Subrs") + 1;
     /* subr_size_pos points to the number indicating dict size after "/Subrs" */
     subr_size = t1_scan_num(t1_line_array + subr_size_pos, 0);
     if (subr_size == 0) {
@@ -1420,20 +1420,20 @@
        Subrs is found
      */
 
-#define POST_SUBRS_SCAN     5
+#define POST_SUBRS_SCAN  5
 
     s = 0;
     *t1_buf_array = 0;
     for (i = 0; i < POST_SUBRS_SCAN; i++) {
         if (t1_charstrings())
-               break;
+            break;
         s += t1_line_ptr - t1_line_array;
         alloc_array(t1_buf, s, T1_BUF_SIZE);
         strcat(t1_buf_array, t1_line_array);
         t1_getline();
     }
     subr_array_end = xstrdup(t1_buf_array);
-    if (i == POST_SUBRS_SCAN) { /* CharStrings not found; 
+    if (i == POST_SUBRS_SCAN) { /* CharStrings not found;
                                    suppose synthetic font */
         for (ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)
             if (ptr->valid)
@@ -1472,7 +1472,7 @@
         start_line = cs_dict_start;
         line_end = cs_dict_end;
         size_pos = cs_size_pos;
-        tab =  cs_tab;
+        tab = cs_tab;
         end_tab = cs_ptr;
         count = cs_count;
     }
@@ -1563,7 +1563,7 @@
     for (glyph = (char *) avl_t_first(&t, fd_cur->gl_tree); glyph != NULL;
          glyph = (char *) avl_t_next(&t)) {
         mark_cs(glyph);
-        }
+    }
     if (subr_tab != NULL)
         for (subr_max = -1, ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)
             if (ptr->used && ptr - subr_tab > subr_max)
@@ -1574,7 +1574,7 @@
 {
     cs_entry *ptr;
     cs_size_pos = strstr(t1_line_array, charstringname) + strlen(charstringname)
-                  - t1_line_array + 1; 
+        - t1_line_array + 1;
     /* cs_size_pos points to the number indicating
        dict size after "/CharStrings" */
     cs_size = t1_scan_num(t1_line_array + cs_size_pos, 0);
@@ -1604,27 +1604,27 @@
 
 static void t1_subset_end(void)
 {
-    if (t1_synthetic) { /* copy to "dup /FontName get exch definefont pop" */
+    if (t1_synthetic) {         /* copy to "dup /FontName get exch definefont pop" */
         while (!strstr(t1_line_array, "definefont")) {
             t1_getline();
             t1_putline();
         }
         while (!t1_end_eexec())
-            t1_getline();   /* ignore the rest */
-        t1_putline();       /* write "mark currentfile closefile" */
+            t1_getline();       /* ignore the rest */
+        t1_putline();           /* write "mark currentfile closefile" */
     } else
         while (!t1_end_eexec()) {       /* copy to "mark currentfile closefile" */
-        t1_getline();
-        t1_putline();
-    }
+            t1_getline();
+            t1_putline();
+        }
     t1_stop_eexec();
     if (fixedcontent) {         /* copy 512 zeros (not needed for PDF) */
-    while (!t1_cleartomark()) {
-        t1_getline();
-        t1_putline();
-    }
-    if (!t1_synthetic)  /* don't check "{restore}if" for synthetic fonts */
-        t1_check_end(); /* write "{restore}if" if found */
+        while (!t1_cleartomark()) {
+            t1_getline();
+            t1_putline();
+        }
+        if (!t1_synthetic)      /* don't check "{restore}if" for synthetic fonts */
+            t1_check_end();     /* write "{restore}if" if found */
     }
     get_length3();
 }
@@ -1643,7 +1643,7 @@
         t1_include();
         t1_close_font_file(">>");
         return;
-    } 
+    }
     /* partial downloading */
     if (!(fd->ff_found = t1_open_fontfile("<")))
         return;
--- tetex-src-3.0/texk/web2c/pdftexdir/NEWS.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/NEWS	2007-07-31 19:04:09.000000000 +0200
@@ -1,4 +1,45 @@
 -------------------------------------------------
+pdfTeX 3.141592-1.40.5 was released on 2007-07-31
+-------------------------------------------------
+- Bugfixes: 
+  - calling 'pdftex %' would crash (830)
+  - fflush the recorder file
+- pdfTeX uses xpdf 3.02pl1
+
+-------------------------------------------------
+pdfTeX 3.141592-1.40.4 was released on 2007-07-11
+-------------------------------------------------
+- Bugfixes: 
+  - It was impossible to set the font Flags to 4 in map entries (762)
+  - The font Flags of non-embedded fonts were wrong (794)
+    Now pdfTeX uses the Flags from map entries (if found) or guesses values for
+    the base14 fonts. It also warns when you not-embedd a font without Flags
+  - Subsetted fonts still had their private UniqueID copied (774)
+  - \pdfunescapehex returned a wrong result if the last character was not a
+    hexadecimal digit and the last hex pair was incomplete (777)
+  - Copying a box with \pdfstartlink inside produced the same /Link annotation
+    object multiply, with same object number and identical coordinates on the
+    page (799)
+  - When trying to use a font without TFM, without map entry, and no PK font
+    available, a broken PDF was produced. Now no PDF is generated and the error
+    messages have been improved (721)
+  - Problems with vf fonts (722)
+  - Font expansion led to wrong log output of \kerns (736)
+  - \pdfprimitive was broken (see
+    http://www.ntg.nl/pipermail/ntg-pdftex/2007-April/002860.html)
+  - The -recorder option of web2c didn't record fonts, included images and some
+    other files (772)
+  - Using \pdfximage in IniTeX before \dump caused a crash when the format was
+    used (824)
+  - \letterspacefont had some problems (712)
+  - \letterspacefont and \pdffontexpand had some problems (747)
+- Improvements: 
+  - pdf compression is now a bit faster (patch 726)
+  - the behaviour of TeX when it asks for a file name has been improved (756)
+- pdfTeX uses libpng 1.2.18
+- pdfTeX uses xpdf 3.02
+
+-------------------------------------------------
 pdfTeX 3.141592-1.40.3 was released on 2007-02-04
 -------------------------------------------------
 - bugfix: document which used type 1 and truetype or opentype fonts resulted in
@@ -167,7 +208,7 @@
 - pdftex knows two new units:
   - new Didot (1nd=0.375mm)
   - new Cicero (1nc=12nd)
-- New primitives: 
+- New primitives:
   - Inclusion of pngs has been greatly improved: It now does
     - alpha channel and transparency (only if %!PDF >=1.4)
     - 16-bit colour (only if %!PDF >=1.5); this must be enabled by setting
@@ -178,7 +219,7 @@
     - fast direct embedding of png streams, if their structure allows this; the
       automatic fall-back is to decompress and re-compress as before.
   - pdfTeX now has an interface to the precise system time (if available) as an
-    aid in benchmarking TeX macro code. 
+    aid in benchmarking TeX macro code.
     - \pdfelapsedtime is a read-only integer that (initially) returns the
       amount of time passed since the start of this run. This amount is given
       in `scaled seconds': the value 65536 counts as one second. If more time
@@ -189,7 +230,7 @@
     - \pdfuniformdeviate <count> generates a uniformly distributed random
       integer value between 0 (inclusive) and <count> (exclusive).
     - \pdfnormaldeviate expands to a random integer value with a mean of 0 and
-      a unit of 65536. 
+      a unit of 65536.
     - \pdfrandomseed allows access to the current seed value.
     - \pdfsetrandomseed <count> sets the random seed to a specific value.
   - \pdfnoligatures\f disables ligatures for the loaded font \f.
@@ -236,7 +277,7 @@
 - New experimental primitives:
   - \pdfmatch [icase] [subcount <number>}] {<pattern>}{<string>}
     Implements pattern matching using the POSIX regex.
-    It returns the same values as \pdfstrcmp, but with the following semantics: 
+    It returns the same values as \pdfstrcmp, but with the following semantics:
       -1: error case (invalid pattern, ...)
        0: no match
        1: match found
@@ -370,7 +411,7 @@
 - The PTEX.FullBanner key is now inserted in the document info dict instead of
   the catalog. Newer versions of Acrobat display it.
 - Now includes support for encTeX.
-- Extended \pdfannot to use reserveobjnum/useobjnum 
+- Extended \pdfannot to use reserveobjnum/useobjnum
   See http://www.ntg.nl/pipermail/ntg-pdftex/2004-March/000424.html
 - Bugfix: pdfTeX would read an .xpdfrc when including pdfs.
   See http://tug.org/pipermail/pdftex/2004-March/004835.html
@@ -384,7 +425,7 @@
 - pdfTeX uses zlib 1.2.1
 - pdfTeX uses xpdf 3.00
 - pdfTeX uses libpng 1.2.7
-  
+
 ------------------------------------------------
 pdfTeX 3.141592-1.11b was released on 2003-10-06
 ------------------------------------------------
@@ -399,7 +440,7 @@
 - The behaviour when an included pdf has a newer version than the one specified
   with \pdfoptionpdfminorversion can be controlled by the new internal integer
   \pdfoptionpdfinclusionerrorlevel: If it's 0, pdfTeX gives only a warning; if
-  it's 1, it raises an error. 
+  it's 1, it raises an error.
     This can also be set in pdftex.cfg with pdf_inclusion_errorlevel
 - The syntax for outlines has been extended to allow attributes:
   <outline spec> --> <attr spec> <action spec> [count <number>] <general text>
@@ -411,7 +452,7 @@
   <object contents> --> <file spec>
                       | <general text>
   When the optional keyword `reserveobjnum' and `useobjnum' is not given, the
-  behaviour is unchanged. 
+  behaviour is unchanged.
   See also http://tug.org/mailman/htdig/pdftex/2003-March/003814.html
 - Bugfix: /CreationDate didn't care for the timezone and could be fooled.
   See http://www.ntg.nl/pipermail/ntg-pdftex/2003-July/000223.html
@@ -423,7 +464,7 @@
   See http://tug.org/pipermail/pdftex/2003-July/004262.html
 - Bugfix: \pdfstartlink would produce spurious /NewWindow entries. Also the
   syntax of <action spec> and <goto-action spec> has been cleaned up.
-  See http://www.ntg.nl/pipermail/ntg-pdftex/2003-June/000167.html 
+  See http://www.ntg.nl/pipermail/ntg-pdftex/2003-June/000167.html
 - Bugfix: \pdffontattr was not used for T3 fonts.
   See http://tug.org/pipermail/pdftex/2003-June/004127.html
 - Bugfix: The cropbox of an included pdf would sometimes not be used.
@@ -450,7 +491,7 @@
   http://tug.org/pipermail/pdftex/2002-March/002367.html).
 - Bugfix: decimal_digits defaulted to 0, which caused problems with included
   images when including pdfs (see
-  http://tug.org/pipermail/pdftex/2003-February/003518.html). 
+  http://tug.org/pipermail/pdftex/2003-February/003518.html).
   It now defaults to 4.
 - Bugfix: the type of included images was decided based only on the extensions;
   now pdfTeX looks for magic bytes at the start of files (see
@@ -464,16 +505,16 @@
   - Additional attributes like MetaData are copied from included pdfs.
   - Currently the Page Group attribute (see sections 7.3.6 and 7.5.5 of the pdf
     1.4 reference) of included pdfs is NOT copied (as we don't know how to
-    handle this when imposing pdfs). 
+    handle this when imposing pdfs).
       This means including pdfs with transparency features will work as long as
     the included pdf doesn't use Page Groups; if it does, the result might not
     be what is expected (One application known to use Page Groups is Adobe
     Illustrator v9++). The distributed pdfTeX binaries will give a warning
     about any occurance of a Page Group in an included pdf and ignore the Page
     Group (thus producing syntactically correct pdfs but probably not the
-    intended output).  
+    intended output).
       Acrobat 5++ and newer versions of Jaws display files without Page Groups
-    correctly, so this might not really be a problem.  
+    correctly, so this might not really be a problem.
       See pdftoepdf.cc for preprocessor flags which allow this behaviour to be
     changed (copying the Page Group (most likely producing incorrect pdf) or
     treating Page Groups as errors).
@@ -481,7 +522,7 @@
   generated file and the latest allowed pdf version of included pdfs:
         \pdfoptionpdfminorversion=3
   tells pdfTeX to set the pdf version to 1.3 and allows only included pdfs with
-  versions <= 1.3 . 
+  versions <= 1.3 .
     The default for \pdfoptionpdfminorversion is 4 for pdf 1.4
     This must appear before any data is written to the generated pdf file, so
   you should put it at the very start of your files.
@@ -505,7 +546,7 @@
   (thanks to Hartmut Henkel).
 - The support for the inclusion of tif images has been removed as it was of
   limited use (it worked only for gray-scale and rgb images) and produced wrong
-  results (all other images types where treated as rgb images). 
+  results (all other images types where treated as rgb images).
   Tif images can be converted on *nix on-the-fly to pngs with the help of
   ImageMagick, epstopdf.sty or pdftex.def v0.4 or newer, and this rule:
     \DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `basename #1 .tif`.png}
@@ -530,5 +571,5 @@
 pdfTeX 3.14159-1.00a-pretest-20010804 was released on 2001-08-04
 ----------------------------------------------------------------
 
-$Id: //depot/Build/source.development/TeX/texk/web2c/pdftexdir/NEWS#86 $
+$Id: NEWS 217 2007-07-31 16:55:39Z oneiros $
 // vim: tw=79:ts=2:expandtab:autoindent
--- tetex-src-3.0/texk/web2c/pdftexdir/subfont.c.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/subfont.c	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 2005-2006 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 2005-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,9 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+$Id: subfont.c 217 2007-07-31 16:55:39Z oneiros $
 */
 
 #include "ptexlib.h"
--- tetex-src-3.0/texk/web2c/pdftexdir/tex.ch0.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/tex.ch0	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 %
-% Copyright (c) 1996-2002 Han The Thanh, <thanh@pdftex.org>
+% Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 %
 % This file is part of pdfTeX.
 %
@@ -13,11 +13,11 @@
 % MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 % GNU General Public License for more details.
 %
-% You should have received a copy of the GNU General Public License
-% along with pdfTeX; if not, write to the Free Software
-% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+% You should have received a copy of the GNU General Public License along with
+% pdfTeX; if not, write to the Free Software Foundation, Inc., 51 Franklin
+% Street, Fifth Floor, Boston, MA 02110-1301 USA.
 %
-% $Id: //depot/Build/source.development/TeX/texk/web2c/pdfetexdir/tex.ch0#10 $
+% $Id: tex.ch0 217 2007-07-31 16:55:39Z oneiros $
 %
 % Change file to assist in creating the web2c-specific change file.
 % This one comes first, resolves inconsistencies between the generated
--- tetex-src-3.0/texk/web2c/pdftexdir/avlstuff.h.pdf1405	2004-03-16 10:44:03.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/avlstuff.h	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 2004 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 2004-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by Free
@@ -12,12 +12,10 @@
 for more details.
 
 You should have received a copy of the GNU General Public License along
-with this file; if not, write to the Free Software Foundation, Inc.,
-59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: //depot/Build/source.development/TeX/texk/web2c/pdftexdir/avlstuff.h#5 $
-
-formatted by indent -kr
+$Id: avlstuff.h 217 2007-07-31 16:55:39Z oneiros $
 */
 
 #include "avl.h"
--- tetex-src-3.0/texk/web2c/pdftexdir/ptexlib.h.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/ptexlib.h	2008-01-06 17:39:23.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2006 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,27 +13,27 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: //depot/Build/source.development/TeX/texk/web2c/pdftexdir/ptexlib.h#26 $
+$Id: ptexlib.h 217 2007-07-31 16:55:39Z oneiros $
 */
 
 #ifndef PDFTEXLIB
-#define PDFTEXLIB
+#  define PDFTEXLIB
 
 /* WEB2C macros and prototypes */
-#if !defined(PDFTEXCOERCE) && !defined(PDFETEXCOERCE)
-#ifdef pdfTeX
-#undef pdfTeX /* to avoid warning about redefining pdfTeX in pdftexd.h */
-#endif /* pdfTeX */
-#define EXTERN extern
-#include "pdftexd.h"
-#endif
+#  if !defined(PDFTEXCOERCE) && !defined(PDFETEXCOERCE)
+#    ifdef pdfTeX
+#      undef pdfTeX             /* to avoid warning about redefining pdfTeX in pdftexd.h */
+#    endif                      /* pdfTeX */
+#    define EXTERN extern
+#    include "pdftexd.h"
+#  endif
 
 /* pdftexlib macros */
-#include "ptexmac.h"
+#  include "ptexmac.h"
 
 /* avl */
 #  include "avlstuff.h"
@@ -64,7 +64,7 @@
 
 typedef struct {
     integer fe_objnum;          /* object number */
-    char *name;                     /* encoding file name */
+    char *name;                 /* encoding file name */
     char **glyph_names;         /* array of glyph names */
     struct avl_table *tx_tree;  /* tree of encoding positions marked as used by TeX */
 } fe_entry;
@@ -76,6 +76,11 @@
     char *unicode_seq;          /* multiple unicode sequence */
 } glyph_unicode_entry;
 
+#  define FD_FLAGS_NOT_SET_IN_MAPLINE -1
+#  define FD_FLAGS_DEFAULT_EMBED  4     /* a symbol font */
+#  define FD_FLAGS_DEFAULT_NON_EMBED 0x22
+                                        /* a nonsymbolic serif font */
+
 typedef struct {
     /* parameters scanned from the map file: */
     char *tfm_name;             /* TFM file name (1st field in map line) */
@@ -143,10 +148,10 @@
     char *ff_path;              /* full path to font file */
 } ff_entry;
 
-typedef short shalfword ;
+typedef short shalfword;
 typedef struct {
     integer charcode, cwidth, cheight, xoff, yoff, xescape, rastersize;
-   halfword *raster;
+    halfword *raster;
 } chardesc;
 
 /* pdftexlib variable declarations */
@@ -167,7 +172,7 @@
 extern void epdf_free(void);
 
 /* mapfile.c */
-extern fm_entry * lookup_fontmap(char *);
+extern fm_entry *lookup_fontmap(char *);
 extern boolean hasfmentry(internalfontnumber);
 extern void fm_free(void);
 extern void fm_read_info(void);
@@ -178,6 +183,7 @@
 extern fm_entry *new_fm_entry(void);
 extern void delete_fm_entry(fm_entry *);
 extern int avl_do_entry(fm_entry *, int);
+extern int check_std_t1font(char *s);
 
 /* papersiz.c */
 extern integer myatodim(char **);
@@ -213,12 +219,12 @@
 extern char *makecfilename(strnumber s);
 extern void make_subset_tag(fd_entry *);
 __attribute__ ((format(printf, 1, 2)))
-extern void pdf_printf(const char *,...);
+extern void pdf_printf(const char *, ...);
 extern void pdf_puts(const char *);
 __attribute__ ((noreturn, format(printf, 1, 2)))
-extern void pdftex_fail(const char *,...);
+extern void pdftex_fail(const char *, ...);
 __attribute__ ((format(printf, 1, 2)))
-extern void pdftex_warn(const char *,...);
+extern void pdftex_warn(const char *, ...);
 extern void setjobid(int, int, int, int);
 __attribute__ ((format(printf, 1, 2)))
 extern void tex_printf(const char *, ...);
@@ -266,13 +272,17 @@
 extern void allocvffnts();
 
 /* vfpacket.c */
-extern eightbits packetbyte(void);
 extern integer newvfpacket(internalfontnumber);
+extern void storepacket(internalfontnumber, eightbits, strnumber);
+extern void startpacket(internalfontnumber, eightbits);
+extern eightbits packetbyte(void);
 extern void poppacketstate(void);
 extern void pushpacketstate(void);
-extern void startpacket(internalfontnumber, integer);
-extern void storepacket(integer, integer, integer);
 extern void vf_free(void);
+#  define SIGNED_QUAD scaled
+#  define fixword integer
+extern SIGNED_QUAD sqxfw(SIGNED_QUAD sq, fixword fw);
+
 
 /* writeenc.c */
 extern fe_entry *get_fe_entry(char *);
@@ -300,10 +310,12 @@
 extern integer readimage(strnumber, integer, strnumber, integer, integer,
                          integer, integer);
 extern void deleteimage(integer);
-extern void img_free(void) ;
+extern void img_free(void);
 extern void updateimageprocset(integer);
 extern void writeimage(integer);
 extern integer imagecolordepth(integer img);
+extern void dumpimagemeta();
+extern void undumpimagemeta(integer, integer);
 
 /* writejbig2.c */
 extern void flushjbig2page0objects();
@@ -325,6 +337,7 @@
 
 /* writezip.c */
 extern void writezip(boolean);
+extern void zip_free(void);
 
 /* avlstuff.c */
 extern int comp_int_entry(const void *, const void *, void *);
@@ -348,4 +361,5 @@
 };
 
 /**********************************************************************/
-#endif  /* PDFTEXLIB */
+#endif                          /* PDFTEXLIB */
+// vim: ts=4
--- tetex-src-3.0/texk/web2c/pdftexdir/writeenc.c.pdf1405	2008-01-06 16:24:15.000000000 +0100
+++ tetex-src-3.0/texk/web2c/pdftexdir/writeenc.c	2008-01-06 17:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 1996-2005 Han The Thanh, <thanh@pdftex.org>
+Copyright (c) 1996-2007 Han The Thanh, <thanh@pdftex.org>
 
 This file is part of pdfTeX.
 
@@ -13,11 +13,11 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with pdfTeX; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+You should have received a copy of the GNU General Public License along
+with pdfTeX; if not, write to the Free Software Foundation, Inc., 51
+Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-$Id: writeenc.c,v 1.3 2005/12/26 14:20:13 hahe Exp hahe $
+$Id: writeenc.c 217 2007-07-31 16:55:39Z oneiros $
 */
 
 #include "ptexlib.h"
@@ -43,7 +43,7 @@
     fe->glyph_names = NULL;     /* encoding file not yet read in */
     fe->tx_tree = NULL;
     return fe;
-            }
+}
 
 fe_entry *lookup_fe_entry(char *s)
 {
@@ -53,9 +53,9 @@
     if (fe_tree == NULL) {
         fe_tree = avl_create(comp_fe_entry, NULL, &avl_xallocator);
         assert(fe_tree != NULL);
-        }
-    return (fe_entry *) avl_find(fe_tree, &fe);
     }
+    return (fe_entry *) avl_find(fe_tree, &fe);
+}
 
 void register_fe_entry(fe_entry * fe)
 {
@@ -93,7 +93,7 @@
     assert(fe_objnum != 0);
     pdfbegindict(fe_objnum, 1);
     pdf_puts("/Type /Encoding\n");
-    pdf_printf("/Differences [");
+    pdf_puts("/Differences [");
     for (i = 0, i_old = -2; i < 256; i++)
         if (glyph_names[i] != notdef) {
             if (i == i_old + 1) /* no gap */
@@ -119,7 +119,7 @@
     assert(fe_objnum != 0);
     pdfbegindict(fe_objnum, 1);
     pdf_puts("/Type /Encoding\n");
-    pdf_printf("/Differences [");
+    pdf_puts("/Differences [");
     avl_t_init(&t, tx_tree);
     for (i_old = -2, p = (int *) avl_t_first(&t, tx_tree); p != NULL;
          p = (int *) avl_t_next(&t)) {
